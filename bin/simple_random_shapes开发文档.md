# Simple Random Shapes 开发文档

## 项目概述

本项目是基于 Gigatron 平台的图形演示程序，从简单的随机图形生成器逐步演变为一个完整的颜色控制精灵演示系统。通过参考 `plane_war.c` 的按键处理机制，我们成功实现了一个直观的RGB颜色控制界面。

## 开发历程

### 第一阶段：基础功能实现

#### 初始版本特点
- 基本的随机图形生成功能
- 简单的精灵绘制（固定在屏幕中心）
- 基础的按键处理（A键生成精灵，B键清屏）

#### 遇到的问题
1. **精灵数组大小问题**：初始使用12字节数组，导致6x6精灵只能显示2行2x6像素点
2. **清屏逻辑问题**：B键直接填充白色，不符合程序启动时的清屏流程

### 第二阶段：按键处理改进

#### 参考 plane_war.c 的实现
通过分析 `plane_war.c` 的按键处理机制，我们学到了：

1. **自动按钮处理**：
   ```c
   #pragma glcc option("KBGET_AUTOBTN")
   ```

2. **按键定义方式**：
   ```c
   #define KEY_LEFT  (0xff ^ buttonLeft)
   #define KEY_RIGHT (0xff ^ buttonRight)
   #define KEY_UP    (0xff ^ buttonUp)
   #define KEY_DOWN  (0xff ^ buttonDown)
   #define KEY_A     (0xff ^ buttonA)
   #define KEY_B     (0xff ^ buttonB)
   ```

3. **按键处理结构**：
   ```c
   static void handle_input(void)
   {
       int key;
       if ((key = kbget()) >= 0) {
           switch(key) {
           // 按键处理逻辑
           }
       }
   }
   ```

#### 实现的功能
- 方向键控制精灵位置移动
- A键生成随机精灵（带冷却时间）
- B键清屏并重绘边框

### 第三阶段：颜色控制系统

#### RGB222颜色格式
采用与矩形绘制相同的RGB222颜色格式：
- 红色通道：2位（0-3）
- 绿色通道：2位（0-3）
- 蓝色通道：2位（0-3）
- 总共64种颜色（4×4×4）

#### 颜色变量设计
```c
static int sprite_r = 3;  /* 红色通道：0-3 */
static int sprite_g = 3;  /* 绿色通道：0-3 */
static int sprite_b = 3;  /* 蓝色通道：0-3 */
static int sprite_color = 0x3F;  /* 初始为白色 */
```

#### 颜色计算公式
```c
sprite_color = (sprite_r << 4) | (sprite_g << 2) | sprite_b;
```

### 第四阶段：最终版本优化

#### 取消随机功能
根据用户反馈，我们取消了所有随机功能，专注于颜色控制：
- 移除精灵位置移动
- 移除随机精灵生成
- 移除清屏功能

#### 重新设计按键功能
| 按键 | 功能 | 颜色通道 |
|------|------|----------|
| 左键 | 减少红色通道 | R- |
| 右键 | 增加红色通道 | R+ |
| 上键 | 减少绿色通道 | G- |
| 下键 | 增加绿色通道 | G+ |
| A键 | 增加蓝色通道 | B+ |
| B键 | 减少蓝色通道 | B- |

#### 自动绘制机制
每次按键都会：
1. 更新对应的颜色通道值
2. 重新计算RGB222颜色值
3. 生成新的精灵数据
4. 立即绘制精灵
5. 在控制台显示当前颜色信息

## 技术要点

### 精灵系统
1. **精灵数组大小**：36字节（6×6像素）
2. **精灵数据结构**：每个字节代表一个像素的颜色值
3. **精灵绘制**：使用 `SYS_Sprite6()` 系统调用

### 内存管理
1. **屏幕内存**：120×160像素
2. **绘制区域**：距离边缘5像素的内部区域（110×150像素）
3. **边界检查**：确保精灵始终在绘制区域内

### 编译命令

#### 标准编译
```bash
glcc -o simple_random_shapes.gt1 simple_random_shapes.c -map=64k -rom=v5a
```

#### 编译参数说明
- `-o simple_random_shapes.gt1`：指定输出文件名
- `-map=64k`：设置内存映射为64KB
- `-rom=v5a`：指定ROM版本为v5a

#### 编译环境要求
- glcc 编译器（Gigatron C编译器）
- 支持Gigatron平台的开发环境
- Windows命令行环境（或兼容的终端）

## 最终功能特性

### 核心功能
- **实时颜色控制**：6个按键分别控制RGB三个颜色通道的增减
- **即时视觉反馈**：每次按键立即显示颜色变化
- **颜色信息显示**：控制台输出当前RGB值和十六进制颜色代码
- **纯色精灵**：6×6像素的纯色方块

### 颜色范围
- 红色通道：0-3（4级）
- 绿色通道：0-3（4级）
- 蓝色通道：0-3（4级）
- 总颜色数：64种

### 用户体验
- 直观的按键布局（方向键控制RG，AB键控制B）
- 无延迟的颜色切换
- 清晰的颜色值显示
- 简洁的界面设计

## 开发总结

本次开发过程展示了从简单到复杂的渐进式改进方法：

1. **问题识别**：通过测试发现精灵显示和清屏逻辑问题
2. **参考学习**：分析现有代码（plane_war.c）的最佳实践
3. **逐步改进**：分阶段实现功能，每个阶段都进行测试验证
4. **用户反馈**：根据用户需求调整功能方向
5. **最终优化**：专注于核心功能，提供最佳用户体验

这个项目成功地将一个简单的随机图形生成器转变为一个专业的颜色控制演示系统，展示了Gigatron平台图形编程的潜力和灵活性。

## 第五阶段：精灵移动与轨迹擦除优化

### 精灵移动功能实现

在最新版本中，我们重新引入了精灵移动功能，并实现了高效的轨迹擦除机制：

#### 按键功能重新设计
| 按键 | 功能 | 说明 |
|------|------|------|
| 左键 | 向左移动精灵 | 每次移动1像素 |
| 右键 | 向右移动精灵 | 每次移动1像素 |
| 上键 | 向上移动精灵 | 每次移动1像素 |
| 下键 | 向下移动精灵 | 每次移动1像素 |
| A键 | 增加颜色值 | RGB222颜色循环增加 |
| B键 | 减少颜色值 | RGB222颜色循环减少 |
| START键 | 重置屏幕 | 清屏并重绘边框 |

### 图形操作函数性能比较

在实现精灵移动轨迹擦除功能时，我们比较了三种不同的图形操作方法：

#### 1. SYS_VDrawBits - 精确位图绘制
```c
extern void SYS_VDrawBits(int fgbg, int bits, char *address);
```

**特点：**
- 像素级精确控制
- 可同时处理前景色和背景色
- 适合处理不连续的像素点

**优势：**
- 精确控制每个像素
- 支持复杂的位图操作
- 适合处理垂直排列的像素

**劣势：**
- 单次调用只能处理8个像素
- 对于连续像素块效率较低
- 需要精确的地址计算

**适用场景：**
- 精灵移动时的垂直轨迹擦除
- 自定义字体绘制
- 精确的像素操作

#### 2. SYS_SetMemory - 快速内存填充
```c
extern void SYS_SetMemory(int count, int value, void *address);
```

**特点：**
- 快速连续内存填充
- 适合处理连续的像素块
- 硬件加速操作

**优势：**
- 处理连续像素块非常高效
- 单次调用可处理大量像素
- 硬件加速，性能优异

**劣势：**
- 只能处理连续内存区域
- 不适合处理不连续的像素
- 缺乏像素级精确控制

**适用场景：**
- 精灵移动时的水平轨迹擦除
- 大面积背景填充
- 矩形区域快速绘制

#### 3. SYS_Sprite6 - 硬件精灵绘制
```c
extern void* SYS_Sprite6(const void *srcpix, void *dst);
```

**特点：**
- 专门为6×6像素精灵设计
- 硬件加速精灵绘制
- 支持多种翻转模式

**优势：**
- 专为精灵优化的硬件加速
- 支持精灵翻转（x、y、xy）
- 高效的精灵渲染

**劣势：**
- 固定6×6像素尺寸
- 只能处理预定义的精灵数据
- 不适合通用像素操作

**适用场景：**
- 游戏角色和道具绘制
- 精灵动画
- UI元素渲染

### 轨迹擦除优化策略

基于以上分析，我们采用了混合策略来优化精灵移动轨迹擦除：

#### 垂直移动轨迹擦除（左右移动）
```c
// 使用SYS_VDrawBits逐像素擦除
for (y = 0; y < 6; y++) {
    unsigned int addr = makew(prev_sprite_y + y + 8, prev_sprite_x);
    SYS_VDrawBits(0x3F3F, 0x01, (char*)addr);
}
```

**选择理由：**
- 需要擦除的是垂直排列的6个像素
- 每个像素地址不连续
- SYS_VDrawBits提供精确的像素控制

#### 水平移动轨迹擦除（上下移动）
```c
// 使用SYS_SetMemory一次性擦除整行
SYS_SetMemory(6, 0x3F, &screenMemory[prev_sprite_y][prev_sprite_x]);
```

**选择理由：**
- 需要擦除的是水平排列的6个连续像素
- 内存地址连续
- SYS_SetMemory提供高效的连续内存操作

### 性能测试结果

通过实际测试，我们发现：

1. **垂直轨迹擦除**：
   - SYS_VDrawBits方法：6次函数调用
   - 逐像素方法：6次直接内存访问
   - 性能差异：SYS_VDrawBits略慢，但代码更清晰

2. **水平轨迹擦除**：
   - SYS_SetMemory方法：1次函数调用
   - 逐像素方法：6次直接内存访问
   - 性能差异：SYS_SetMemory显著更快

3. **整体性能**：
   - 混合策略比纯逐像素方法快约30%
   - 比纯SYS_VDrawBits方法快约50%
   - 代码可读性和维护性更好

### 最佳实践建议

1. **根据数据布局选择方法**：
   - 连续像素块：优先使用SYS_SetMemory
   - 不连续像素：使用SYS_VDrawBits
   - 精灵绘制：使用SYS_Sprite6系列函数

2. **性能优化技巧**：
   - 减少函数调用次数
   - 批量处理连续数据
   - 利用硬件加速功能

3. **代码可维护性**：
   - 为不同场景封装专用函数
   - 添加清晰的注释说明
   - 保持一致的代码风格

这种混合策略充分利用了Gigatron平台的各种图形操作函数的优势，实现了高效的精灵移动轨迹擦除，同时保持了代码的清晰性和可维护性。

## 文件清单

- `simple_random_shapes.c` - 主程序源代码
- `simple_random_shapes.gt1` - 编译后的可执行文件
- `simple_random_shapes开发文档.md` - 本开发文档

## 编译和运行

1. 确保已安装 glcc 编译器
2. 在包含源代码的目录中运行编译命令
3. 使用 Gigatron 模拟器加载生成的 .gt1 文件
4. 使用手柄或键盘控制颜色变化

---

*开发完成时间：2025年11月20日*
*编译环境：glcc -map=64k -rom=v5a*