#VCPUv5

# ======== ('CODE', '_avl_add', code0)
def code0():
	label('_avl_add');
	_PROLOGUE(48,4,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	_SP(-2+48);STW(R4);
	LDI(0);DOKE(R4);
	_BRA('.6');
	label('.5');
	LDW(R6);STW(R8);
	LDW(R7);DEEK();STW(R9);
	CALL(R5);
	STW(R3);
	_BNE('.8');
	LDW(R7);DEEK();
	_BRA('.3');
	label('.8');
	LDW(R3);_BGE('.10');
	LDW(R7);DEEK();ADDI(2);STW(R7);
	_BRA('.11');
	label('.10');
	LDW(R7);DEEK();ADDI(4);STW(R7);
	label('.11');
	label('.6');
	LDW(R4);SUBI(-v(-2));STW(R4);
	LDW(R7);DOKE(R4);
	DEEK();_BNE('.5');
	LDI(4);ADDW(R6);STW(R23);
	LDI(0);DOKE(R23);
	LDI(2);ADDW(R6);STW(R23);
	LDI(0);DOKE(R23);
	LDW(R6);DOKE(R7);
	LDW(R4);STW(R8);
	CALLI('__avl_rebal');
	LDI(0);
	label('.3');
	_EPILOGUE(48,4,0xf8,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', '_avl_add'),
	('CODE', '_avl_add', code0),
	('IMPORT', '__avl_rebal') ]
module(code=code, name='../gigatron/libc/_avladd.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_avl_del', code0)
def code0():
	label('_avl_del');
	_PROLOGUE(52,6,0xfc); # save=R2-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	_SP(-2+52);STW(R4);
	LDI(0);DOKE(R4);
	label('.5');
	label('.9');
	LDW(R4);SUBI(-v(-2));STW(R4);
	LDW(R7);DOKE(R4);
	DEEK();_BNE('.10');
	LDI(0);
	_BRA('.3');
	label('.10');
	LDW(R6);STW(R8);
	LDW(R7);DEEK();STW(R9);
	CALL(R5);
	STW(R2);
	_BNE('.12');
	_BRA('.7');
	label('.12');
	LDW(R2);_BGE('.14');
	LDW(R7);DEEK();ADDI(2);STW(R7);
	_BRA('.5');
	label('.14');
	LDW(R7);DEEK();ADDI(4);STW(R7);
	_BRA('.5');
	label('.7');
	LDW(R7);DEEK();STW(R6);
	LDI(2);ADDW(R6);DEEK();_BNE('.16');
	LDI(4);ADDW(R6);DEEK();DOKE(R7);
	_BRA('.17');
	label('.16');
	LDI(4);ADDW(R6);
	STW(R3);
	DEEK();_BNE('.21');
	LDI(2);ADDW(R6);DEEK();DOKE(R7);
	_BRA('.19');
	label('.20');
	LDW(R3);DEEK();ADDI(2);STW(R3);
	label('.21');
	LDW(R3);DEEK();ADDI(2);DEEK();_BNE('.20');
	LDW(R3);DEEK();ADDI(4);DEEK();STW(R2);
	LDW(R3);DEEK();DOKE(R7);
	LDW(R6);DOKE(R3);
	LDW(R7);DEEK();ADDI(2);STW(R23);
	LDI(2);ADDW(R6);DEEK();DOKE(R23);
	LDW(R7);DEEK();ADDI(4);STW(R23);
	LDI(4);ADDW(R6);DEEK();DOKE(R23);
	LDI(2);ADDW(R6);STW(R23);
	LDI(0);DOKE(R23);
	LDI(4);ADDW(R6);STW(R23);
	LDW(R2);DOKE(R23);
	LDW(R7);DEEK();ADDI(4);STW(R7);
	_BRA('.9');
	label('.19');
	label('.17');
	LDW(R4);STW(R8);
	CALLI('__avl_rebal');
	LDW(R6);
	label('.3');
	_EPILOGUE(52,6,0xfc,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', '_avl_del'),
	('CODE', '_avl_del', code0),
	('IMPORT', '__avl_rebal') ]
module(code=code, name='../gigatron/libc/_avldel.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', '_mask', code0, 8, 1)
def code0():
	label('_mask');
	bytes(1,2);
	bytes(4,8);
	bytes(16,32);
	bytes(64,128);
# ======== ('CODE', '_bitset_clear', code1)
def code1():
	label('_bitset_clear');
	PUSH();
	LDI(0);STW(R19);
	_BRA('.7');
	label('.4');
	LDW(R19);ADDW(R8);STW(R23);
	LDI(0);POKE(R23);
	label('.5');
	LDI(1);ADDW(R19);STW(R19);
	label('.7');
	LDW(R19);XORW(R9);_BNE('.4');
	label('.3');
	tryhop(2);POP();RET()
# ======== ('CODE', '_bitset_compl', code2)
def code2():
	label('_bitset_compl');
	PUSH();
	LDI(0);STW(R19);
	_BRA('.12');
	label('.9');
	LDW(R19);ADDW(R8);STW(R23);
	PEEK();XORI(255);POKE(R23);
	label('.10');
	LDI(1);ADDW(R19);STW(R19);
	label('.12');
	LDW(R19);XORW(R9);_BNE('.9');
	label('.8');
	tryhop(2);POP();RET()
# ======== ('CODE', '_bitset_set', code3)
def code3():
	label('_bitset_set');
	PUSH();
	LDW(R9);_SHRIU(3);ADDW(R8);STW(R19);
	LDWI('_mask');STW(R23);
	LDW(R9);ANDI(7);ADDW(R23);PEEK();STW(R18);
	LD(R18);STW(R23);
	LDW(R19);PEEK();ORW(R23);POKE(R19);
	label('.13');
	tryhop(2);POP();RET()
# ======== ('CODE', '_bitset_clr', code4)
def code4():
	label('_bitset_clr');
	PUSH();
	LDW(R9);_SHRIU(3);ADDW(R8);STW(R19);
	LDWI('_mask');STW(R23);
	LDW(R9);ANDI(7);ADDW(R23);PEEK();STW(R18);
	LD(R18);XORI(255);STW(R23);
	LDW(R19);PEEK();ANDW(R23);POKE(R19);
	label('.14');
	tryhop(2);POP();RET()
# ======== ('CODE', '_bitset_test', code5)
def code5():
	label('_bitset_test');
	PUSH();
	LDW(R9);_SHRIU(3);ADDW(R8);STW(R19);
	LDWI('_mask');STW(R23);
	LDW(R9);ANDI(7);ADDW(R23);PEEK();STW(R18);
	LD(R18);STW(R23);
	LDW(R19);PEEK();ANDW(R23);
	label('.15');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('DATA', '_mask', code0, 8, 1),
	('EXPORT', '_bitset_clear'),
	('CODE', '_bitset_clear', code1),
	('EXPORT', '_bitset_compl'),
	('CODE', '_bitset_compl', code2),
	('EXPORT', '_bitset_set'),
	('CODE', '_bitset_set', code3),
	('EXPORT', '_bitset_clr'),
	('CODE', '_bitset_clr', code4),
	('EXPORT', '_bitset_test'),
	('CODE', '_bitset_test', code5) ]
module(code=code, name='../gigatron/libc/_bitset.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', '.6', code0, 0, 1)
def code0():
	label('.6');
	bytes(32,43,32,35,48,32,45,32);
	bytes(0);
# ======== ('DATA', '.7', code1, 0, 1)
def code1():
	label('.7');
	bytes(8,4);
	bytes(0,16);
	bytes(2,0);
	bytes(1,0);
# ======== ('CODE', 'parsespec', code2)
def code2():
	label('parsespec');
	PUSH();
	LDW(R9);PEEK();STW(R19);
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R18);
	label('.8');
	LDW(R18);_SHRIS(2);XORW(R18);ANDI(7);STW(R16);
	LDWI('.6');ADDW(R16);PEEK();XORW(R18);_BEQ('.12');
	_BRA('.10');
	label('.12');
	LDWI('.7');ADDW(R16);PEEK();ORW(R19);STW(R19);
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R18);
	_BRA('.8');
	label('.10');
	LDI(64);STW(R16);
	LDI(2);ADDW(R9);STW(R17);
	label('.14');
	LDW(R18);XORI(42);_BNE('.20');
	LDW(R19);ORW(R16);STW(R19);
	LDWI(0xfffe);STW(R23);
	LDW(R10);DEEK();ADDI(3);ANDW(R23);
	DOKE(R10);
	SUBI(-v(-2));DEEK();DOKE(R17);
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R18);
	_BRA('.16');
	label('.19');
	LDW(R19);ORW(R16);STW(R19);
	LDW(R17);DEEK();STW(T3);LSLW();LSLW();ADDW(T3);LSLW();ADDW(R18);SUBI(48);DOKE(R17);
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R18);
	label('.20');
	LDW(R18);SUBI(48);_BLT('.22');
	LDW(R18);SUBI(57);_BLE('.19');
	label('.22');
	label('.16');
	LDW(R16);XORI(64);_BNE('.23');
	LDW(R17);DEEK();_BGE('.25');
	LDW(R19);ORI(1);STW(R19);
	LDW(R17);DEEK();STW(R23);
	LDI(0);SUBW(R23);DOKE(R17);
	label('.25');
	LDW(R18);XORI(46);_BNE('.27');
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R18);
	LDI(128);STW(R16);
	LDI(4);ADDW(R9);STW(R17);
	_BRA('.14');
	label('.27');
	label('.23');
	label('.29');
	LDW(R18);XORI(108);_BNE('.33');
	LDW(R19);ORI(32);STW(R19);
	_BRA('.34');
	label('.33');
	LDW(R18);XORI(104);_BEQ('.35');
	_BRA('.31');
	label('.35');
	label('.34');
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R18);
	_BRA('.29');
	label('.31');
	LDW(R18);XORI(112);_BNE('.37');
	LDW(R19);ORI(16);STW(R19);
	label('.37');
	LDW(R19);POKE(R9);
	LDI(1);ADDW(R9);STW(R23);
	LDW(R18);POKE(R23);
	LDW(R8);
	label('.5');
	tryhop(2);POP();RET()
# ======== ('CODE', 'do_str', code3)
def code3():
	label('do_str');
	_PROLOGUE(20,6,0xfc); # save=R2-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R7);PEEK();STW(R3);
	LDI(0);STW(R2);
	LDW(R5);_BNE('.40');
	LDWI(0xffff);STW(R5);
	LDW(R3);ANDI(128);_BEQ('.42');
	LDI(4);ADDW(R7);DEEK();STW(R5);
	label('.42');
	label('.40');
	LDW(R6);STW(R8);
	LDI(0);STW(R9);
	LDW(R5);STW(R10);
	CALLI('memchr');
	STW(R4);
	_BEQ('.44');
	LDW(R4);SUBW(R6);STW(R5);
	label('.44');
	LDW(R3);ANDI(64);_BEQ('.46');
	LDI(2);ADDW(R7);DEEK();SUBW(R5);STW(R2);
	label('.46');
	LDW(R2);_BLE('.48');
	LDW(R3);ANDI(1);_BNE('.48');
	LDI(32);STW(R8);
	LDW(R2);STW(R9);
	CALLI('_doprint_putc');
	label('.48');
	LDW(R6);STW(R8);
	LDW(R5);STW(R9);
	CALLI('_doprint_puts');
	LDW(R2);_BLE('.50');
	LDW(R3);ANDI(1);_BEQ('.50');
	LDI(32);STW(R8);
	LDW(R2);STW(R9);
	CALLI('_doprint_putc');
	label('.50');
	label('.39');
	_EPILOGUE(20,6,0xfc);
# ======== ('CODE', 'upcase', code4)
def code4():
	label('upcase');
	PUSH();
	_BRA('.54');
	label('.53');
	LDW(R19);SUBI(97);_BLT('.56');
	LDW(R19);SUBI(122);_BGT('.56');
	LDW(R19);XORI(32);POKE(R8);
	label('.56');
	LDI(1);ADDW(R8);STW(R8);
	label('.54');
	LDW(R8);PEEK();
	STW(R19);
	_BNE('.53');
	label('.52');
	tryhop(2);POP();RET()
# ======== ('CODE', '_doprint_num', code5)
def code5():
	label('_doprint_num');
	_PROLOGUE(20,4,0xfe); # save=R1-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R7);PEEK();STW(R2);
	LDWI('.59');STW(R1);
	LDW(R5);PEEK();XORI(45);_BNE('.60');
	LDWI('.62');STW(R1);
	LDI(1);ADDW(R5);STW(R5);
	_BRA('.61');
	label('.60');
	LDW(R6);ANDI(1);_BEQ('.63');
	LDW(R2);ANDI(4);_BEQ('.65');
	LDWI('.67');STW(R1);
	_BRA('.66');
	label('.65');
	LDW(R2);ANDI(8);_BEQ('.68');
	LDWI('.70');STW(R1);
	label('.68');
	label('.66');
	label('.63');
	label('.61');
	LDW(R5);PEEK();XORI(48);_BNE('.71');
	LDW(R2);ANDI(128);_BEQ('.72');
	LDI(1);ADDW(R5);STW(R5);
	_BRA('.72');
	label('.71');
	LDW(R2);ANDI(16);_BEQ('.75');
	LDW(R6);XORI(8);_BNE('.77');
	LDWI('.79');STW(R1);
	LDI(4);ADDW(R7);STW(R23);
	DEEK();SUBI(1);DOKE(R23);
	_BRA('.78');
	label('.77');
	LDW(R6);XORI(16);_BNE('.80');
	LDWI('.82');STW(R1);
	label('.80');
	label('.78');
	label('.75');
	label('.72');
	LDW(R1);STW(R8);
	CALLI('strlen');
	STW(R6);
	LDW(R5);STW(R8);
	CALLI('strlen');
	STW(R4);
	LDI(0);STW(R3);
	LDW(R2);ANDI(128);_BEQ('.83');
	LDI(4);ADDW(R7);DEEK();SUBW(R4);
	STW(R3);
	_BGE('.84');
	LDI(0);STW(R3);
	_BRA('.84');
	label('.83');
	LDW(R2);ANDI(2);_BEQ('.87');
	LDI(2);ADDW(R7);DEEK();SUBW(R4);SUBW(R6);
	STW(R3);
	_BGE('.89');
	LDI(0);STW(R3);
	label('.89');
	label('.87');
	label('.84');
	LDI(2);ADDW(R7);DEEK();SUBW(R4);SUBW(R6);SUBW(R3);STW(R6);
	LDI(1);ADDW(R7);PEEK();SUBI(97);_BGE('.91');
	LDW(R5);STW(R8);
	CALLI('upcase');
	LDI(1);ADDW(R1);PEEK();XORI(120);_BNE('.93');
	LDWI('.95');STW(R1);
	label('.93');
	label('.91');
	LDW(R6);_BLE('.96');
	LDW(R2);ANDI(1);_BNE('.96');
	LDI(32);STW(R8);
	LDW(R6);STW(R9);
	CALLI('_doprint_putc');
	label('.96');
	LDW(R1);PEEK();_BEQ('.98');
	LDW(R1);STW(R8);
	CALLI('strlen');STW(R23);
	LDW(R1);STW(R8);
	LDW(R23);STW(R9);
	CALLI('_doprint_puts');
	label('.98');
	LDW(R3);_BLE('.100');
	LDI(48);STW(R8);
	LDW(R3);STW(R9);
	CALLI('_doprint_putc');
	label('.100');
	LDW(R5);STW(R8);
	LDW(R4);STW(R9);
	CALLI('_doprint_puts');
	LDW(R6);_BLE('.102');
	LDW(R2);ANDI(1);_BEQ('.102');
	LDI(32);STW(R8);
	LDW(R6);STW(R9);
	CALLI('_doprint_putc');
	label('.102');
	label('.58');
	_EPILOGUE(20,4,0xfe);
# ======== ('CODE', 'do_int', code6)
def code6():
	label('do_int');
	_PROLOGUE(28,8,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R7);PEEK();STW(R3);
	LDW(R6);XORI(11);_BNE('.105');
	LDW(R5);STW(R8);
	_SP(-1+28);STW(R9);
	LDI(10);STW(R10);
	CALLI('_itoa');
	STW(R4);
	_BRA('.106');
	label('.105');
	LDW(R5);STW(R8);
	_SP(-1+28);STW(R9);
	LDW(R6);STW(R10);
	CALLI('_utoa');
	STW(R4);
	label('.106');
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	LDW(R4);STW(R10);
	CALLI('_doprint_num');
	label('.104');
	_EPILOGUE(28,8,0xf8);
# ======== ('DATA', '.110', code7, 0, 1)
def code7():
	label('.110');
	bytes(69,71,120,111,117,110,115,70);
	bytes(101,103,99,105,112,100,88,102);
	bytes(0);
# ======== ('DATA', '.111', code8, 0, 1)
def code8():
	label('.111');
	bytes(129,129);
	bytes(16,8);
	bytes(10,96);
	bytes(64,129);
	bytes(129,129);
	bytes(32,11);
	bytes(16,11);
	bytes(16,129);
# ======== ('CODE', '_doprint_conv_info', code9)
def code9():
	label('_doprint_conv_info');
	PUSH();
	LDW(R8);STW(R19);
	ANDI(1);_BEQ('.112');
	LDI(58);ADDW(R19);STW(R19);
	label('.112');
	LDW(R19);XORI(199);SUBI(187);_BLE('.114');
	LDW(R19);SUBI(187);STW(R19);
	label('.114');
	LDW(R19);_SHRIS(2);XORW(R19);ANDI(15);STW(R19);
	LDWI('.110');ADDW(R19);PEEK();XORW(R8);_BNE('.116');
	LDWI('.111');ADDW(R19);PEEK();
	_BRA('.109');
	label('.116');
	LDI(0);
	label('.109');
	tryhop(2);POP();RET()
# ======== ('CODE', '_doprint_c89', code10)
def code10():
	label('_doprint_c89');
	_PROLOGUE(28,8,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	_SP(2+28);STW(R23);
	LDW(R9);DOKE(R23);
	_SP(-8+28);STW(R6);
	LDI(0);DOKE(R0);
	_BRA('.122');
	label('.119');
	LDW(R7);STW(R3);
	_BRA('.124');
	label('.123');
	LDI(1);ADDW(R3);STW(R3);
	label('.124');
	LDW(R3);PEEK();
	STW(R5);
	_BEQ('.126');
	LDW(R5);XORI(37);_BNE('.123');
	label('.126');
	LDW(R3);XORW(R7);_BEQ('.127');
	label('.129');
	LDW(R7);STW(R8);
	LDW(R3);SUBW(R7);STW(R9);
	CALLI('_doprint_puts');
	_BRA('.120');
	label('.127');
	LDI(1);ADDW(R3);PEEK();XORI(37);_BNE('.130');
	LDI(1);ADDW(R7);STW(R7);
	ADDI(1);STW(R3);
	_BRA('.129');
	label('.130');
	LDW(R6);STW(R8);
	LDI(0);STW(R9);
	LDI(6);STW(R10);
	CALLI('memset');
	LDW(R3);STW(R8);
	LDW(R6);STW(R9);
	_SP(2+28);STW(R10);
	CALLI('parsespec');
	STW(R3);
	STW(R23);
	ADDI(1);STW(R3);
	LDW(R23);PEEK();STW(R8);
	CALLI('_doprint_conv_info');
	STW(R5);
	_BNE('.132');
	_BRA('.129');
	label('.132');
	LDW(R6);PEEK();ANDI(32);_BEQ('.134');
	LDW(R5);ANDI(30);_BEQ('.134');
	LDW(R6);STW(R8);
	LDW(R5);STW(R9);
	_SP(2+28);STW(R10);
	CALLI('_doprint_long');
	_BRA('.135');
	label('.134');
	LDW(R5);XORI(129);_BNE('.136');
	LDW(R6);STW(R8);
	_SP(2+28);STW(R9);
	CALLI('_doprint_double');
	_BRA('.137');
	label('.136');
	_SP(2+28);STW(R23);
	LDWI(0xfffe);STW(R22);
	_SP(2+28);DEEK();ADDI(3);ANDW(R22);DOKE(R23);
	
	SUBI(-v(-2));DEEK();STW(R4);
	LDW(R5);XORI(32);_BNE('.140');
	_SP(-1+28);STW(R23);
	LDW(R4);POKE(R23);
	LDW(R6);STW(R8);
	_SP(-1+28);STW(R9);
	LDI(1);STW(R10);
	CALLI('do_str');
	_BRA('.141');
	label('.140');
	LDW(R5);XORI(64);_BNE('.142');
	LDW(R6);STW(R8);
	LDW(R4);STW(R9);
	LDI(0);STW(R10);
	CALLI('do_str');
	_BRA('.143');
	label('.142');
	LDW(R5);XORI(96);_BNE('.144');
	LDW(R0);DEEK();DOKE(R4);
	_BRA('.145');
	label('.144');
	LDW(R6);STW(R8);
	LDW(R5);STW(R9);
	LDW(R4);STW(R10);
	CALLI('do_int');
	label('.145');
	label('.143');
	label('.141');
	label('.137');
	label('.135');
	label('.120');
	LDW(R3);STW(R7);
	label('.122');
	LDW(R7);PEEK();_BNE('.119');
	LDW(R0);DEEK();
	label('.118');
	_EPILOGUE(28,8,0xf8,saveAC=True);
# ======== ('DATA', '.95', code11, 0, 1)
def code11():
	label('.95');
	bytes(48,88,0);
# ======== ('DATA', '.82', code12, 0, 1)
def code12():
	label('.82');
	bytes(48,120,0);
# ======== ('DATA', '.79', code13, 0, 1)
def code13():
	label('.79');
	bytes(48,0);
# ======== ('DATA', '.70', code14, 0, 1)
def code14():
	label('.70');
	bytes(32,0);
# ======== ('DATA', '.67', code15, 0, 1)
def code15():
	label('.67');
	bytes(43,0);
# ======== ('DATA', '.62', code16, 0, 1)
def code16():
	label('.62');
	bytes(45,0);
# ======== ('DATA', '.59', code17, 0, 1)
def code17():
	label('.59');
	bytes(0);
# ======== (epilog)
code=[
	('DATA', '.6', code0, 0, 1),
	('DATA', '.7', code1, 0, 1),
	('CODE', 'parsespec', code2),
	('CODE', 'do_str', code3),
	('CODE', 'upcase', code4),
	('EXPORT', '_doprint_num'),
	('CODE', '_doprint_num', code5),
	('CODE', 'do_int', code6),
	('DATA', '.110', code7, 0, 1),
	('DATA', '.111', code8, 0, 1),
	('CODE', '_doprint_conv_info', code9),
	('EXPORT', '_doprint_c89'),
	('CODE', '_doprint_c89', code10),
	('IMPORT', '_doprint_long'),
	('IMPORT', '_doprint_double'),
	('IMPORT', '_doprint_puts'),
	('IMPORT', '_doprint_putc'),
	('IMPORT', '_utoa'),
	('IMPORT', '_itoa'),
	('IMPORT', 'strlen'),
	('IMPORT', 'memset'),
	('IMPORT', 'memchr'),
	('DATA', '.95', code11, 0, 1),
	('DATA', '.82', code12, 0, 1),
	('DATA', '.79', code13, 0, 1),
	('DATA', '.70', code14, 0, 1),
	('DATA', '.67', code15, 0, 1),
	('DATA', '.62', code16, 0, 1),
	('DATA', '.59', code17, 0, 1) ]
module(code=code, name='../gigatron/libc/_doprint_c89.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_doprint_double_imp', code0)
def code0():
	label('_doprint_double_imp');
	_PROLOGUE(96,14,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	DEEK();ADDI(5);STW(R23);
	DOKE(R6);
	_SP(-5+96);STW(T2);LDW(R23);SUBI(-v(-5));_MOVF([vAC],[T2]);
	LDW(R7);PEEK();STW(R5);
	LDI(4);ADDW(R7);DEEK();STW(R4);
	LDW(R5);ANDI(128);_BNE('.8');
	LDI(6);STW(R4);
	label('.8');
	_MOVF([SP,-5+96],F8);
	_SP(-69+96);STW(R11);
	LDI(1);ADDW(R7);PEEK();ORI(32);STW(R12);
	LDW(R4);STW(R13);
	CALLI('dtoa');
	STW(R3);
	LDWI(-129);ANDW(R5);POKE(R7);
	LDW(R7);STW(R8);
	LDI(129);STW(R9);
	LDW(R3);STW(R10);
	CALLI('_doprint_num');
	label('.5');
	_EPILOGUE(96,14,0xf8);
# ======== (epilog)
code=[
	('EXPORT', '_doprint_double_imp'),
	('CODE', '_doprint_double_imp', code0),
	('IMPORT', '_doprint_num'),
	('IMPORT', 'dtoa') ]
module(code=code, name='../gigatron/libc/_doprint_double.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_doprint_long_imp', code0)
def code0():
	label('_doprint_long_imp');
	_PROLOGUE(40,10,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDWI(0xfffc);STW(R23);
	LDW(R5);DEEK();ADDI(7);ANDW(R23);STW(R23);
	DOKE(R5);
	_SP(-4+40);STW(T2);LDW(R23);SUBI(-v(-4));_MOVL([vAC],[T2]);
	LDW(R6);XORI(11);_BNE('.8');
	_MOVL([SP,-4+40],L8);
	_SP(-5+40);STW(R10);
	LDI(10);STW(R11);
	CALLI('_ltoa');
	STW(R4);
	_BRA('.9');
	label('.8');
	_MOVL([SP,-4+40],L8);
	_SP(-5+40);STW(R10);
	LDW(R6);STW(R11);
	CALLI('_ultoa');
	STW(R4);
	label('.9');
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	LDW(R4);STW(R10);
	CALLI('_doprint_num');
	label('.5');
	_EPILOGUE(40,10,0xf0);
# ======== (epilog)
code=[
	('EXPORT', '_doprint_long_imp'),
	('CODE', '_doprint_long_imp', code0),
	('IMPORT', '_doprint_num'),
	('IMPORT', '_ultoa'),
	('IMPORT', '_ltoa') ]
module(code=code, name='../gigatron/libc/_doprint_long.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', 'hash1', code0, 8, 1)
def code0():
	label('hash1');
	bytes(117,105,111,99,100,120,115,115);
# ======== ('DATA', 'hash2', code1, 9, 1)
def code1():
	label('hash2');
	bytes(10,255);
	bytes(8,0);
	bytes(255,16);
	bytes(1,1);
	space(1);
# ======== ('CODE', '_doprint_simple', code2)
def code2():
	label('_doprint_simple');
	_PROLOGUE(32,8,0xfe); # save=R1-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDI(0);DOKE(R0);
	_BRA('.7');
	label('.6');
	LDW(R7);STW(R5);
	LDI(32);STW(R1);
	LDI(0);STW(R2);
	LDW(R7);PEEK();XORI(37);_BEQ('.9');
	_BRA('.12');
	label('.11');
	LDI(1);ADDW(R7);STW(R7);
	label('.12');
	LDW(R7);PEEK();
	_BEQ('.14');
	XORI(37);_BNE('.11');
	label('.14');
	LDW(R7);SUBW(R5);STW(R4);
	_BRA('.10');
	label('.9');
	LDI(1);ADDW(R7);STW(R7);
	
	PEEK();STW(R3);
	XORI(45);_BEQ('.17');
	LDW(R3);XORI(48);_BNE('.19');
	label('.17');
	LDW(R3);ST(R1);
	LDI(1);ADDW(R7);STW(R7);
	
	PEEK();STW(R3);
	_BRA('.19');
	label('.18');
	LDW(R2);LSLW();LSLW();ADDW(R2);LSLW();ADDW(R3);SUBI(48);STW(R2);
	LDI(1);ADDW(R7);STW(R7);
	
	PEEK();STW(R3);
	label('.19');
	LDW(R3);SUBI(48);_BLT('.21');
	LDW(R3);SUBI(57);_BLE('.18');
	label('.21');
	LDI(1);ADDW(R7);STW(R7);
	LDW(R3);STW(R4);
	SUBI(110);_BLE('.22');
	LDW(R4);XORI(5);STW(R4);
	label('.22');
	LDW(R4);ANDI(7);STW(R4);
	LDWI('hash1');ADDW(R4);PEEK();XORW(R3);_BEQ('.24');
	LDW(R3);XORI(37);_BEQ('.26');
	LDI(1);ADDW(R5);STW(R7);
	label('.26');
	LDI(0);STW(R2);
	LDI(1);STW(R4);
	_BRA('.25');
	label('.24');
	LDWI('hash2');ADDW(R4);PEEK();STW(R3);
	LDWI(0xfffe);STW(R23);
	LDI(3);ADDW(R6);ANDW(R23);STW(R6);
	
	SUBI(-v(-2));DEEK();STW(R4);
	LDW(R3);_BNE('.30');
	_SP(-8+32);STW(R5);
	LDW(R4);POKE(R5);
	LDI(1);STW(R4);
	_BRA('.31');
	label('.30');
	LDW(R3);XORI(1);_BNE('.32');
	LDW(R4);STW(R5);
	STW(R8);
	CALLI('strlen');
	STW(R4);
	_BRA('.33');
	label('.32');
	LDW(R3);XORI(255);_BNE('.34');
	LDW(R4);STW(R8);
	_SP(-1+32);STW(R9);
	LDI(10);STW(R10);
	CALLI('_itoa');
	STW(R5);
	LD(R1);XORI(48);_BNE('.35');
	LDW(R5);PEEK();XORI(45);_BNE('.35');
	LDI(45);STW(R8);
	LDI(1);STW(R9);
	CALLI('_doprint_putc');
	LDW(R2);SUBI(1);STW(R2);
	LDI(1);ADDW(R5);STW(R5);
	_BRA('.35');
	label('.34');
	LDW(R4);STW(R8);
	_SP(-1+32);STW(R9);
	LDW(R3);STW(R10);
	CALLI('_utoa');
	STW(R5);
	label('.35');
	_SP(-1+32);SUBW(R5);STW(R4);
	label('.33');
	label('.31');
	LDW(R2);SUBW(R4);STW(R2);
	label('.25');
	label('.10');
	LD(R1);XORI(45);_BEQ('.41');
	LDW(R2);_BLE('.41');
	LD(R1);STW(R8);
	LDW(R2);STW(R9);
	CALLI('_doprint_putc');
	label('.41');
	LDW(R5);STW(R8);
	LDW(R4);STW(R9);
	CALLI('_doprint_puts');
	LD(R1);XORI(45);_BNE('.43');
	LDW(R2);_BLE('.43');
	LDI(32);STW(R8);
	LDW(R2);STW(R9);
	CALLI('_doprint_putc');
	label('.43');
	label('.7');
	LDW(R7);PEEK();_BNE('.6');
	LDW(R0);DEEK();
	label('.5');
	_EPILOGUE(32,8,0xfe,saveAC=True);
# ======== (epilog)
code=[
	('DATA', 'hash1', code0, 8, 1),
	('DATA', 'hash2', code1, 9, 1),
	('EXPORT', '_doprint_simple'),
	('CODE', '_doprint_simple', code2),
	('IMPORT', '_doprint_puts'),
	('IMPORT', '_doprint_putc'),
	('IMPORT', '_utoa'),
	('IMPORT', '_itoa'),
	('IMPORT', 'strlen') ]
module(code=code, name='../gigatron/libc/_doprint_simple.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_doscan_next', code0)
def code0():
	label('_doscan_next');
	_PROLOGUE(8,4,0x80); # save=R7
	LDW(R8);STW(R7);
	LDI(4);ADDW(R7);STW(R23);
	DEEK();ADDI(1);DOKE(R23);
	LDI(2);ADDW(R7);DEEK();STW(R8);
	CALLI('fgetc');
	DOKE(R7);
	
	label('.6');
	_EPILOGUE(8,4,0x80,saveAC=True);
# ======== ('CODE', 'spc', code1)
def code1():
	label('spc');
	_PROLOGUE(8,4,0x80); # save=R7
	LDW(R8);STW(R7);
	_BRA('.9');
	label('.8');
	LDW(R7);STW(R8);
	CALLI('_doscan_next');
	label('.9');
	LDW(R7);DEEK();STW(R8);
	CALLI('isspace');
	_BNE('.8');
	label('.7');
	_EPILOGUE(8,4,0x80);
# ======== ('CODE', 'check_set', code2)
def code2():
	label('check_set');
	PUSH();
	LDI(0);STW(R19);
	STW(R18);
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();
	STW(R17);
	XORI(94);_BNE('.15');
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R17);
	LDI(1);STW(R19);
	_BRA('.15');
	label('.14');
	LDW(R17);XORW(R9);_BNE('.17');
	LDI(1);STW(R18);
	label('.17');
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();
	STW(R17);
	XORI(93);_BNE('.19');
	_BRA('.16');
	label('.19');
	label('.15');
	LDW(R17);_BNE('.14');
	label('.16');
	LDW(R9);_BEQ('.23');
	LDW(R18);XORW(R19);_BNE('.21');
	label('.23');
	LDW(R8);
	_BRA('.11');
	label('.21');
	LDI(0);
	label('.11');
	tryhop(2);POP();RET()
# ======== ('CODE', 'do_str', code3)
def code3():
	label('do_str');
	_PROLOGUE(20,6,0xfc); # save=R2-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R11);STW(R4);
	LDW(R12);STW(R3);
	_BRA('.26');
	label('.25');
	LDW(R5);_BEQ('.31');
	LDW(R6);XORI(115);_BNE('.32');
	LDW(R2);STW(R8);
	CALLI('isspace');
	_BNE('.31');
	label('.32');
	LDW(R6);XORI(91);_BNE('.28');
	LDW(R4);STW(R8);
	LDW(R2);STW(R9);
	CALLI('check_set');
	_BEQ('.28');
	label('.31');
	_BRA('.27');
	label('.28');
	LDW(R3);_BEQ('.33');
	LDW(R2);POKE(R3);
	LDI(1);ADDW(R3);STW(R3);
	label('.33');
	LDW(R5);SUBI(1);STW(R5);
	LDW(R7);STW(R8);
	CALLI('_doscan_next');
	label('.26');
	LDW(R7);DEEK();
	STW(R2);
	_BGT('.25');
	label('.27');
	LDW(R6);XORI(99);_BEQ('.35');
	LDI(0);POKE(R3);
	label('.35');
	LDI(1);
	label('.24');
	_EPILOGUE(20,6,0xfc,saveAC=True);
# ======== ('CODE', 'do_lng', code4)
def code4():
	label('do_lng');
	_PROLOGUE(36,4,0xff); # save=R0-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R11);STW(R4);
	_SP(-12+36);STW(R1);
	LDI(0);DOKE(R1);
	LDI(2);ADDW(R1);STW(R23);
	LDI(0);DOKE(R23);
	LDW(R6);XORI(100);_BNE('.38');
	LDI(2);ADDW(R1);STW(R23);
	LDI(10);DOKE(R23);
	_BRA('.39');
	label('.38');
	LDW(R6);XORI(120);_BNE('.40');
	LDI(2);ADDW(R1);STW(R23);
	LDI(16);DOKE(R23);
	_BRA('.41');
	label('.40');
	LDW(R6);XORI(111);_BNE('.42');
	LDI(2);ADDW(R1);STW(R23);
	LDI(8);DOKE(R23);
	label('.42');
	label('.41');
	label('.39');
	LDI(4);ADDW(R1);STW(T2);_MOVL('.44',[T2]);
	_BRA('.46');
	label('.45');
	LDW(R7);STW(R8);
	CALLI('_doscan_next');
	label('.46');
	LDW(R1);STW(R8);
	LDW(R7);DEEK();STW(R9);
	CALLI('_strtol_push');
	_BNE('.45');
	_SP(-4+36);STW(R0);
	LDW(R5);ANDI(2);_BEQ('.48');
	LDW(R4);STW(R0);
	label('.48');
	LDW(R6);XORI(100);_BEQ('.55');
	LDW(R6);XORI(105);_BNE('.53');
	label('.55');
	_SP(-14+36);STW(R23);
	LDI(1);DOKE(R23);
	_BRA('.54');
	label('.53');
	_SP(-14+36);STW(R23);
	LDI(0);DOKE(R23);
	label('.54');
	_SP(-14+36);DEEK();
	STW(R3);
	_BEQ('.50');
	LDW(R1);STW(R8);
	LDW(R0);STW(R9);
	CALLI('_strtol_decode_s');
	STW(R2);
	_BRA('.51');
	label('.50');
	LDW(R1);STW(R8);
	LDW(R0);STW(R9);
	CALLI('_strtol_decode_u');
	STW(R2);
	label('.51');
	LDW(R2);_BEQ('.56');
	LDW(R4);_BEQ('.56');
	LDW(R5);ANDI(2);_BNE('.56');
	_MOVL([SP,-4+36],L22);
	LDW(L22);DOKE(R4);
	LDW(R3);_BEQ('.61');
	_MOVL([SP,-4+36],L22);
	LDW(L22);_STLS(LAC);LDI(L22);_LCMPX();_BNE('.60');
	label('.61');
	LDW(R3);_BNE('.58');
	_MOVL([SP,-4+36],L22);
	LDW(L22);_STLU(LAC);LDI(L22);_LCMPX();_BEQ('.58');
	label('.60');
	LDWI('errno');STW(R23);
	LDI(2);DOKE(R23);
	label('.58');
	label('.56');
	LDW(R2);
	label('.37');
	_EPILOGUE(36,4,0xff,saveAC=True);
# ======== ('CODE', 'parsespec', code5)
def code5():
	label('parsespec');
	PUSH();
	LDI(0);DOKE(R9);
	DOKE(R10);
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R19);
	XORI(42);_BNE('.66');
	LDW(R10);DEEK();ORI(1);DOKE(R10);
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R19);
	_BRA('.66');
	label('.65');
	LDW(R10);DEEK();ORI(8);DOKE(R10);
	LDW(R9);DEEK();STW(T3);LSLW();LSLW();ADDW(T3);LSLW();ADDW(R19);SUBI(48);DOKE(R9);
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R19);
	label('.66');
	LDW(R19);_CMPIS(48);_BLT('.68');
	LDW(R19);_CMPIS(57);_BLE('.65');
	label('.68');
	LDW(R19);XORI(108);_BEQ('.72');
	LDW(R19);XORI(76);_BEQ('.72');
	LDW(R19);XORI(104);_BNE('.69');
	label('.72');
	LDW(R19);XORI(104);_BEQ('.73');
	LDW(R10);DEEK();ORI(2);DOKE(R10);
	label('.73');
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R19);
	label('.69');
	LDW(R10);DEEK();ANDI(8);_BNE('.75');
	LDW(R19);XORI(99);_BNE('.78');
	LDI(1);STW(R18);
	_BRA('.79');
	label('.78');
	LDWI(0xffff);STW(R18);
	label('.79');
	LDW(R18);DOKE(R9);
	label('.75');
	LDW(R8);
	label('.62');
	tryhop(2);POP();RET()
# ======== ('CODE', '_doscan', code6)
def code6():
	label('_doscan');
	_PROLOGUE(40,12,0xfe); # save=R1-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	_SP(-12+40);STW(R4);
	STW(R8);
	LDI(0);STW(R9);
	LDI(8);STW(R10);
	CALLI('memset');
	LDI(2);ADDW(R4);STW(R23);
	LDW(R7);DOKE(R23);
	STW(R8);
	CALLI('fgetc');
	DOKE(R4);
	_BRA('.84');
	label('.81');
	LDW(R1);STW(R8);
	CALLI('isspace');
	_BEQ('.85');
	LDW(R4);STW(R8);
	CALLI('spc');
	_BRA('.82');
	label('.85');
	LDW(R1);XORI(37);_BNE('.89');
	LDW(R6);STW(R23);
	ADDI(1);STW(R22);
	PEEK();XORI(37);_BNE('.87');
	LDW(R22);STW(R6);
	LDW(R23);_BEQ('.87');
	label('.89');
	LDW(R4);DEEK();XORW(R1);_BEQ('.90');
	_BRA('.83');
	label('.90');
	LDW(R4);STW(R8);
	CALLI('_doscan_next');
	_BRA('.82');
	label('.87');
	LDW(R6);STW(R8);
	_SP(-2+40);STW(R9);
	_SP(-4+40);STW(R10);
	CALLI('parsespec');
	STW(R6);
	PEEK();STW(R1);
	LDI(0);STW(R3);
	_SP(-4+40);DEEK();ANDI(1);_BNE('.92');
	LDWI(0xfffe);STW(R23);
	LDI(3);ADDW(R5);ANDW(R23);STW(R5);
	
	SUBI(-v(-2));DEEK();STW(R3);
	label('.92');
	LDW(R1);XORI(110);_BNE('.96');
	LDW(R3);_BEQ('.96');
	LDI(4);ADDW(R4);DEEK();DOKE(R3);
	_BRA('.82');
	label('.96');
	LDW(R1);XORI(99);_BEQ('.98');
	LDW(R1);XORI(91);_BEQ('.98');
	LDW(R4);STW(R8);
	CALLI('spc');
	label('.98');
	LDI(4);ADDW(R4);DEEK();STW(R2);
	LDW(R1);XORI(91);_BEQ('.102');
	LDW(R1);_CMPIS(91);_BLT('.100');
	label('.107');
	LDW(R1);_CMPIS(99);_BLT('.100');
	LDW(R1);_CMPIS(120);_BGT('.100');
	LDWI(v('.108')-198);ADDW(R1);ADDW(R1);DEEK();CALL(vAC);
	label('.102');
	LDW(R4);STW(R8);
	LDW(R1);STW(R9);
	_SP(-2+40);DEEK();STW(R10);
	LDW(R6);STW(R11);
	LDW(R3);STW(R12);
	CALLI('do_str');STW(R23);
	_SP(-2+40);STW(R22);
	LDW(R23);DOKE(R22);
	LDW(R1);XORI(91);_BNE('.101');
	LDW(R6);STW(R8);
	LDI(0);STW(R9);
	CALLI('check_set');
	STW(R6);
	_BRA('.101');
	label('.105');
	LDW(R4);STW(R8);
	LDW(R1);STW(R9);
	_SP(-4+40);DEEK();STW(R10);
	LDW(R3);STW(R11);
	CALLI('do_lng');STW(R23);
	_SP(-2+40);STW(R22);
	LDW(R23);DOKE(R22);
	_BRA('.101');
	label('.106');
	LDW(R4);STW(R8);
	LDW(R3);STW(R9);
	CALLI('_doscan_double');STW(R23);
	_SP(-2+40);STW(R22);
	LDW(R23);DOKE(R22);
	label('.100');
	label('.101');
	LDI(4);ADDW(R4);DEEK();_CMPWS(R2);_BLE('.83');
	_SP(-2+40);DEEK();_BEQ('.83');
	LDI(6);ADDW(R4);STW(R23);
	DEEK();ADDI(1);DOKE(R23);
	label('.82');
	LDI(1);ADDW(R6);STW(R6);
	label('.84');
	LDW(R6);PEEK();
	STW(R1);
	_BNE('.81');
	label('.83');
	LDW(R4);DEEK();STW(R8);
	LDI(2);ADDW(R4);DEEK();STW(R9);
	CALLI('ungetc');
	LDI(6);ADDW(R4);DEEK();
	label('.80');
	_EPILOGUE(40,12,0xfe,saveAC=True);
# ======== ('DATA', '.108', code7, 0, 2)
def code7():
	align(2);
	label('.108');
	words('.102');
	words('.105');
	words('.106');
	words('.106');
	words('.106');
	words('.100');
	words('.105');
	words('.100');
	words('.100');
	words('.100');
	words('.100');
	words('.100');
	words('.105');
	words('.105');
	words('.100');
	words('.100');
	words('.102');
	words('.100');
	words('.105');
	words('.100');
	words('.100');
	words('.105');
# ======== ('DATA', '.44', code8, 0, 4)
def code8():
	align(4);
	label('.44');
	words(0,0); # 0
# ======== (epilog)
code=[
	('EXPORT', '_doscan_next'),
	('CODE', '_doscan_next', code0),
	('CODE', 'spc', code1),
	('CODE', 'check_set', code2),
	('CODE', 'do_str', code3),
	('CODE', 'do_lng', code4),
	('EXPORT', 'parsespec'),
	('CODE', 'parsespec', code5),
	('EXPORT', '_doscan'),
	('CODE', '_doscan', code6),
	('DATA', '.108', code7, 0, 2),
	('IMPORT', '_doscan_double'),
	('IMPORT', 'ungetc'),
	('IMPORT', 'fgetc'),
	('IMPORT', '_strtol_decode_s'),
	('IMPORT', '_strtol_decode_u'),
	('IMPORT', '_strtol_push'),
	('IMPORT', 'errno'),
	('IMPORT', 'memset'),
	('IMPORT', 'isspace'),
	('DATA', '.44', code8, 0, 4) ]
module(code=code, name='../gigatron/libc/_doscan.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_doscan_double_imp', code0)
def code0():
	label('_doscan_double_imp');
	_PROLOGUE(28,8,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	_SP(-12+28);STW(R5);
	STW(R8);
	LDI(0);STW(R9);
	LDI(12);STW(R10);
	CALLI('memset');
	_BRA('.8');
	label('.7');
	LDW(R7);STW(R8);
	CALLI('_doscan_next');
	label('.8');
	LDW(R5);STW(R8);
	LDW(R7);DEEK();STW(R9);
	LDI(0);STW(R10);
	CALLI('_strtod_push');
	_BNE('.7');
	LDW(R5);STW(R8);
	LDW(R6);STW(R9);
	CALLI('_strtod_decode');
	
	label('.6');
	_EPILOGUE(28,8,0xe0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', '_doscan_double_imp'),
	('CODE', '_doscan_double_imp', code0),
	('IMPORT', '_doscan_next'),
	('IMPORT', '_strtod_decode'),
	('IMPORT', '_strtod_push'),
	('IMPORT', 'memset') ]
module(code=code, name='../gigatron/libc/_doscan_double.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', '__glink_magic_bss', code0, 2, 2)
def code0():
	align(2);
	label('__glink_magic_bss');
	words(48879);
# ======== ('CODE', '_init_bss', code1)
def code1():
	label('_init_bss');
	_PROLOGUE(12,6,0xc0); # save=R6-7
	LDWI('__glink_magic_bss');DEEK();STW(R7);
	_BRA('.3');
	label('.2');
	LDI(2);ADDW(R7);DEEK();STW(R6);
	LDWI('__glink_magic_bss');STW(R23);
	LDI(0);DOKE(R23);
	LDW(R7);STW(R8);
	LDI(0);STW(R9);
	LDW(R7);DEEK();STW(R10);
	CALLI('memset');
	LDW(R6);STW(R7);
	label('.3');
	LDW(R7);STW(R23);
	_BEQ('.5');
	LDWI(0xbeef);XORW(R23);_BNE('.2');
	label('.5');
	label('.1');
	_EPILOGUE(12,6,0xc0);
# ======== (epilog)
code=[
	('EXPORT', '__glink_magic_bss'),
	('DATA', '__glink_magic_bss', code0, 2, 2),
	('EXPORT', '_init_bss'),
	('CODE', '_init_bss', code1),
	('IMPORT', 'memset') ]
module(code=code, name='../gigatron/libc/_init1.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_sfindiob', code0)
def code0():
	label('_sfindiob');
	PUSH();
	LDWI('_iob');STW(R19);
	_BRA('.9');
	label('.6');
	LDW(R19);PEEK();_BNE('.11');
	LDW(R19);
	_BRA('.5');
	label('.11');
	label('.7');
	LDI(6);ADDW(R19);STW(R19);
	label('.9');
	LDWI(v('_iob')+24);XORW(R19);_BNE('.6');
	LDI(0);
	label('.5');
	tryhop(2);POP();RET()
# ======== ('CODE', '_sclose', code1)
def code1():
	label('_sclose');
	_PROLOGUE(12,6,0xc0); # save=R6-7
	LDW(R8);STW(R7);
	_BEQ('.14');
	PEEK();_BEQ('.14');
	LDI(2);ADDW(R7);DEEK();ADDI(4);DEEK();
	STW(R6);
	_BEQ('.16');
	LDW(R7);STW(R8);
	LDI(1);STW(R9);
	CALL(R6);
	
	_BRA('.13');
	label('.16');
	label('.14');
	LDI(0);
	label('.13');
	_EPILOGUE(12,6,0xc0,saveAC=True);
# ======== ('CODE', '_swalk', code2)
def code2():
	label('_swalk');
	_PROLOGUE(8,2,0xc0); # save=R6-7
	LDW(R8);STW(R7);
	LDWI(v('_iob')+24);STW(R6);
	label('.20');
	LDW(R6);SUBI(-v(-6));STW(R6);
	
	STW(R8);
	CALL(R7);
	label('.21');
	LDWI('_iob');XORW(R6);_BNE('.20');
	LDWI('__glink_weak__iob2');_BEQ('.23');
	STW(R8);
	CALL(R7);
	label('.23');
	LDWI('__glink_weak__iob1');_BEQ('.25');
	STW(R8);
	CALL(R7);
	label('.25');
	LDWI('__glink_weak__iob0');_BEQ('.27');
	STW(R8);
	CALL(R7);
	label('.27');
	label('.18');
	_EPILOGUE(8,2,0xc0);
# ======== ('CODE', '_fcloseall', code3)
def code3():
	label('_fcloseall');
	_PROLOGUE(4,2,0x0); # save=None
	LDWI('_sclose');STW(R8);
	CALLI('_swalk');
	label('.29');
	_EPILOGUE(4,2,0x0);
# ======== ('DATA', '__glink_magic_fini', code4, 4, 2)
def code4():
	align(2);
	label('__glink_magic_fini');
	words('_fcloseall');
	words(0);
# ======== ('COMMON', '_iob', code5, 24, 2)
def code5():
	align(2);
	label('_iob');
	space(24);
# ======== (epilog)
code=[
	('EXPORT', '_sfindiob'),
	('CODE', '_sfindiob', code0),
	('EXPORT', '_sclose'),
	('CODE', '_sclose', code1),
	('EXPORT', '_swalk'),
	('CODE', '_swalk', code2),
	('CODE', '_fcloseall', code3),
	('DATA', '__glink_magic_fini', code4, 4, 2),
	('COMMON', '_iob', code5, 24, 2) ]
module(code=code, name='../gigatron/libc/_iob.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', '_callerp', code0, 2, 2)
def code0():
	align(2);
	label('_callerp');
	words('_caller');
# ======== ('CODE', '_setcallerp', code1)
def code1():
	label('_setcallerp');
	PUSH();
	LDWI('_callerp');STW(R23);
	LDW(R8);DOKE(R23);
	label('.5');
	tryhop(2);POP();RET()
# ======== ('DATA', '_bblist', code2, 2, 2)
def code2():
	align(2);
	label('_bblist');
	words('tail');
# ======== ('CODE', 'unpack', code3)
def code3():
	label('unpack');
	PUSH();
	LDI(2);ADDW(R8);DEEK();_SHRIU(10);ANDI(63);DOKE(R9);
	LDWI(1023);STW(R23);
	LDI(2);ADDW(R8);DEEK();ANDW(R23);DOKE(R10);
	LDW(R8);DEEK();DOKE(R11);
	label('.6');
	tryhop(2);POP();RET()
# ======== ('CODE', 'profout', code4)
def code4():
	label('profout');
	_PROLOGUE(36,16,0xfc); # save=R2-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDI(0);STW(R3);
	_BRA('.11');
	label('.8');
	label('.9');
	LDI(1);ADDW(R3);STW(R3);
	label('.11');
	LDI(8);ADDW(R7);DEEK();ADDW(R3);ADDW(R3);DEEK();_BNE('.8');
	LDW(R6);STW(R8);
	LDWI('.12');STW(R9);
	LDW(R3);STW(R10);
	_STLW(4,src=R10);
	CALLI('fprintf');
	LDI(0);STW(R3);
	_BRA('.16');
	label('.13');
	LDW(R6);STW(R8);
	LDWI('.17');STW(R9);
	LDI(8);ADDW(R7);DEEK();ADDW(R3);ADDW(R3);DEEK();STW(R10);
	_STLW(4,src=R10);
	CALLI('fprintf');
	label('.14');
	LDI(1);ADDW(R3);STW(R3);
	label('.16');
	LDI(8);ADDW(R7);DEEK();ADDW(R3);ADDW(R3);DEEK();_BNE('.13');
	LDI(0);STW(R3);
	LDI(10);ADDW(R7);DEEK();STW(R4);
	_BRA('.21');
	label('.18');
	LDI(2);ADDW(R4);DEEK();
	STW(R5);
	_BEQ('.22');
	LDW(R3);SUBI(1);STW(R3);
	_BRA('.27');
	label('.24');
	LDI(1);ADDW(R3);STW(R3);
	label('.25');
	LDW(R5);DEEK();STW(R5);
	label('.27');
	LDW(R5);_BNE('.24');
	label('.22');
	label('.19');
	LDI(1);ADDW(R3);STW(R3);
	LDW(R4);DEEK();STW(R4);
	label('.21');
	LDW(R4);_BNE('.18');
	LDW(R6);STW(R8);
	LDWI('.12');STW(R9);
	LDW(R3);STW(R10);
	_STLW(4,src=R10);
	CALLI('fprintf');
	LDI(10);ADDW(R7);DEEK();STW(R4);
	_BRA('.31');
	label('.28');
	LDI(0);STW(R2);
	LDI(2);ADDW(R4);DEEK();STW(R5);
	_BRA('.35');
	label('.32');
	LDI(6);ADDW(R4);STW(R8);
	_SP(-6+36);STW(R9);
	_SP(-2+36);STW(R10);
	_SP(-4+36);STW(R11);
	CALLI('unpack');
	LDW(R6);STW(R8);
	LDWI('.36');STW(R9);
	LDI(4);ADDW(R4);DEEK();STW(R10);
	_STLW(4,src=R10);
	_SP(-6+36);DEEK();STW(R11);
	_STLW(6,src=R11);
	_SP(-2+36);DEEK();STW(R12);
	_STLW(8,src=R12);
	_SP(-4+36);DEEK();STW(R13);
	_STLW(10,src=R13);
	LDI(4);ADDW(R5);_MOVL([vAC],L14);
	_MOVL(L14,[SP,12]);
	CALLI('fprintf');
	LDI(2);ADDW(R5);DEEK();_BEQ('.37');
	LDI(2);ADDW(R5);DEEK();ADDI(4);STW(R8);
	_SP(-6+36);STW(R9);
	_SP(-2+36);STW(R10);
	_SP(-4+36);STW(R11);
	CALLI('unpack');
	LDW(R6);STW(R8);
	LDWI('.39');STW(R9);
	LDI(2);ADDW(R5);DEEK();STW(R23);
	ADDI(2);DEEK();STW(R10);
	_STLW(4,src=R10);
	LDW(R23);DEEK();STW(R11);
	_STLW(6,src=R11);
	_SP(-2+36);DEEK();STW(R12);
	_STLW(8,src=R12);
	_SP(-4+36);DEEK();STW(R13);
	_STLW(10,src=R13);
	CALLI('fprintf');
	_BRA('.38');
	label('.37');
	LDW(R6);STW(R8);
	LDWI('.40');STW(R9);
	CALLI('fprintf');
	label('.38');
	label('.33');
	LDW(R2);_STLU(LAC);LDI(4);ADDW(R5);_LADD();LDW(LAC);STW(R2);
	LDW(R5);DEEK();STW(R5);
	label('.35');
	LDW(R5);_BNE('.32');
	LDW(R2);_BNE('.41');
	LDI(6);ADDW(R4);STW(R8);
	_SP(-6+36);STW(R9);
	_SP(-2+36);STW(R10);
	_SP(-4+36);STW(R11);
	CALLI('unpack');
	LDW(R6);STW(R8);
	LDWI('.43');STW(R9);
	LDI(4);ADDW(R4);DEEK();STW(R10);
	_STLW(4,src=R10);
	_SP(-6+36);DEEK();STW(R11);
	_STLW(6,src=R11);
	_SP(-2+36);DEEK();STW(R12);
	_STLW(8,src=R12);
	_SP(-4+36);DEEK();STW(R13);
	_STLW(10,src=R13);
	CALLI('fprintf');
	label('.41');
	label('.29');
	LDW(R4);DEEK();STW(R4);
	label('.31');
	LDW(R4);_BNE('.28');
	LDW(R6);STW(R8);
	LDWI('.12');STW(R9);
	LDI(2);ADDW(R7);DEEK();STW(R10);
	_STLW(4,src=R10);
	CALLI('fprintf');
	LDI(0);STW(R3);
	_BRA('.47');
	label('.44');
	LDI(6);ADDW(R7);DEEK();STW(R23);
	LDW(R3);_SHLI(2);ADDW(R23);STW(R8);
	_SP(-6+36);STW(R9);
	_SP(-2+36);STW(R10);
	_SP(-4+36);STW(R11);
	CALLI('unpack');
	LDW(R6);STW(R8);
	LDWI('.48');STW(R9);
	_SP(-6+36);DEEK();STW(R10);
	_STLW(4,src=R10);
	_SP(-2+36);DEEK();STW(R11);
	_STLW(6,src=R11);
	_SP(-4+36);DEEK();STW(R12);
	_STLW(8,src=R12);
	LDI(4);ADDW(R7);DEEK();STW(R23);
	LDW(R3);_SHLI(2);ADDW(R23);_MOVL([vAC],L13);
	_MOVL(L13,[SP,12]);
	CALLI('fprintf');
	label('.45');
	LDI(1);ADDW(R3);STW(R3);
	label('.47');
	LDI(2);ADDW(R7);DEEK();_CMPWS(R3);_BGT('.44');
	label('.7');
	_EPILOGUE(36,16,0xfc);
# ======== ('CODE', 'bbexit', code5)
def code5():
	label('bbexit');
	_PROLOGUE(8,4,0x80); # save=R7
	LDWI('tail');STW(R23);
	LDWI('_bblist');DEEK();XORW(R23);_BEQ('.50');
	LDWI('.52');STW(R8);
	LDWI('.53');STW(R9);
	CALLI('fopen');
	STW(R7);
	_BEQ('.50');
	_BRA('.57');
	label('.54');
	LDWI('_bblist');DEEK();STW(R8);
	LDW(R7);STW(R9);
	CALLI('profout');
	label('.55');
	LDWI('_bblist');STW(R23);
	DEEK();DEEK();DOKE(R23);
	label('.57');
	LDWI('tail');STW(R23);
	LDWI('_bblist');DEEK();XORW(R23);_BNE('.54');
	LDW(R7);STW(R8);
	CALLI('fclose');
	label('.50');
	label('.49');
	_EPILOGUE(8,4,0x80);
# ======== ('CODE', '_epilogue', code6)
def code6():
	label('_epilogue');
	PUSH();
	LDWI('_callerp');DEEK();STW(R23);
	LDI(0);DOKE(R23);
	label('.58');
	tryhop(2);POP();RET()
# ======== ('BSS', '.60', code7, 2048, 4)
def code7():
	align(4);
	label('.60');
	space(2048);
# ======== ('BSS', '.61', code8, 2, 2)
def code8():
	align(2);
	label('.61');
	space(2);
# ======== ('CODE', '_prologue', code9)
def code9():
	label('_prologue');
	_PROLOGUE(12,4,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	DEEK();_BNE('.62');
	LDWI('_bblist');DEEK();DOKE(R6);
	LDWI('_bblist');STW(R23);
	LDW(R6);DOKE(R23);
	LDWI('.61');DEEK();_BNE('.64');
	LDWI('bbexit');STW(R8);
	CALLI('atexit');
	label('.64');
	label('.62');
	LDI(2);ADDW(R7);DEEK();STW(R5);
	_BRA('.69');
	label('.66');
	LDWI('_callerp');DEEK();DEEK();STW(R23);
	LDI(2);ADDW(R5);DEEK();XORW(R23);_BNE('.70');
	LDI(4);ADDW(R5);STW(R23);
	_MOVL('.72',LAC);LDW(R23);_LADD();LDW(R23);_MOVL(LAC,[vAC]);
	_BRA('.68');
	label('.70');
	label('.67');
	LDW(R5);DEEK();STW(R5);
	label('.69');
	LDW(R5);_BNE('.66');
	label('.68');
	LDW(R5);_BNE('.73');
	LDWI(256);STW(R23);
	LDWI('.61');DEEK();_CMPWU(R23);_BGE('.73');
	LDWI('.61');STW(R23);
	DEEK();STW(R22);
	ADDI(1);DOKE(R23);
	LDWI('.60');STW(R23);
	LDW(R22);_SHLI(3);ADDW(R23);STW(R5);
	LDI(2);ADDW(R5);STW(R23);
	LDWI('_callerp');DEEK();DEEK();DOKE(R23);
	LDI(4);ADDW(R5);STW(T2);_MOVL('.72',[T2]);
	LDI(2);ADDW(R7);DEEK();DOKE(R5);
	LDI(2);ADDW(R7);STW(R23);
	LDW(R5);DOKE(R23);
	label('.73');
	LDWI('_callerp');DEEK();STW(R23);
	LDI(0);DOKE(R23);
	label('.59');
	_EPILOGUE(12,4,0xe0);
# ======== ('BSS', 'tail', code10, 12, 2)
def code10():
	align(2);
	label('tail');
	space(12);
# ======== ('COMMON', '_caller', code11, 2, 2)
def code11():
	align(2);
	label('_caller');
	space(2);
# ======== ('DATA', '.72', code12, 0, 4)
def code12():
	align(4);
	label('.72');
	words(1,0); # 1
# ======== ('DATA', '.53', code13, 0, 1)
def code13():
	label('.53');
	bytes(97,0);
# ======== ('DATA', '.52', code14, 0, 1)
def code14():
	label('.52');
	bytes(112,114,111,102,46,111,117,116);
	bytes(0);
# ======== ('DATA', '.48', code15, 0, 1)
def code15():
	label('.48');
	bytes(37,100,32,37,100,32,37,100);
	bytes(32,37,108,117,10,0);
# ======== ('DATA', '.43', code16, 0, 1)
def code16():
	label('.43');
	bytes(37,115,32,37,100,32,37,100);
	bytes(32,37,100,32,48,32,63,32);
	bytes(63,32,48,32,48,10,0);
# ======== ('DATA', '.40', code17, 0, 1)
def code17():
	label('.40');
	bytes(32,63,32,63,32,48,32,48);
	bytes(10,0);
# ======== ('DATA', '.39', code18, 0, 1)
def code18():
	label('.39');
	bytes(32,37,115,32,37,115,32,37);
	bytes(100,32,37,100,10,0);
# ======== ('DATA', '.36', code19, 0, 1)
def code19():
	label('.36');
	bytes(37,115,32,37,100,32,37,100);
	bytes(32,37,100,32,37,108,117,0);
# ======== ('DATA', '.17', code20, 0, 1)
def code20():
	label('.17');
	bytes(37,115,10,0);
# ======== ('DATA', '.12', code21, 0, 1)
def code21():
	label('.12');
	bytes(37,100,10,0);
# ======== (epilog)
code=[
	('EXPORT', '_callerp'),
	('DATA', '_callerp', code0, 2, 2),
	('EXPORT', '_setcallerp'),
	('CODE', '_setcallerp', code1),
	('DATA', '_bblist', code2, 2, 2),
	('CODE', 'unpack', code3),
	('CODE', 'profout', code4),
	('CODE', 'bbexit', code5),
	('EXPORT', '_epilogue'),
	('CODE', '_epilogue', code6),
	('BSS', '.60', code7, 2048, 4),
	('BSS', '.61', code8, 2, 2),
	('EXPORT', '_prologue'),
	('CODE', '_prologue', code9),
	('BSS', 'tail', code10, 12, 2),
	('COMMON', '_caller', code11, 2, 2),
	('IMPORT', 'atexit'),
	('IMPORT', 'fprintf'),
	('IMPORT', 'fopen'),
	('IMPORT', 'fclose'),
	('DATA', '.72', code12, 0, 4),
	('DATA', '.53', code13, 0, 1),
	('DATA', '.52', code14, 0, 1),
	('DATA', '.48', code15, 0, 1),
	('DATA', '.43', code16, 0, 1),
	('DATA', '.40', code17, 0, 1),
	('DATA', '.39', code18, 0, 1),
	('DATA', '.36', code19, 0, 1),
	('DATA', '.17', code20, 0, 1),
	('DATA', '.12', code21, 0, 1) ]
module(code=code, name='../gigatron/libc/_lcc_bbexit.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_YYnull', code0)
def code0():
	label('_YYnull');
	_PROLOGUE(28,6,0xfc); # save=R2-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDWI('msg');STW(R5);
	LDW(R7);STW(R8);
	LDI(47);STW(R9);
	CALLI('strrchr');
	STW(R4);
	LDW(R5);_BEQ('.5');
	LDI(1);ADDW(R5);STW(R2);
	_BRA('.6');
	label('.5');
	LDW(R7);STW(R2);
	label('.6');
	_SP(-8+28);STW(R23);
	LDW(R2);DOKE(R23);
	_SP(-6+28);STW(R23);
	LDWI('.8');DOKE(R23);
	LDW(R6);STW(R8);
	LDWI(v('buf')+7);STW(R9);
	LDI(10);STW(R10);
	CALLI('_utoa');STW(R23);
	_SP(-4+28);STW(R22);
	LDW(R23);DOKE(R22);
	_SP(-2+28);STW(R23);
	LDWI('.12');DOKE(R23);
	LDI(0);STW(R3);
	label('.13');
	_SP(-8+28);ADDW(R3);ADDW(R3);DEEK();STW(R4);
	_BRA('.20');
	label('.17');
	LDWI(v('msg')+26);XORW(R5);_BEQ('.21');
	LDW(R5);STW(R23);
	ADDI(1);STW(R5);
	LDW(R4);PEEK();POKE(R23);
	label('.21');
	label('.18');
	LDI(1);ADDW(R4);STW(R4);
	label('.20');
	LDW(R4);PEEK();_BNE('.17');
	label('.14');
	LDI(1);ADDW(R3);STW(R3);
	XORI(4);_BNE('.13');
	LDW(R5);STW(R23);
	ADDI(1);STW(R5);
	LDI(0);POKE(R23);
	LDWI('msg');STW(R8);
	CALLI('_assertfail');
	label('.3');
	_EPILOGUE(28,6,0xfc);
# ======== ('BSS', 'buf', code1, 8, 1)
def code1():
	label('buf');
	space(8);
# ======== ('BSS', 'msg', code2, 27, 1)
def code2():
	label('msg');
	space(27);
# ======== ('DATA', '.12', code3, 0, 1)
def code3():
	label('.12');
	bytes(58,32,110,117,108,108,32,99);
	bytes(104,101,99,107,0);
# ======== ('DATA', '.8', code4, 0, 1)
def code4():
	label('.8');
	bytes(58,0);
# ======== (epilog)
code=[
	('EXPORT', '_YYnull'),
	('CODE', '_YYnull', code0),
	('BSS', 'buf', code1, 8, 1),
	('BSS', 'msg', code2, 27, 1),
	('IMPORT', '_utoa'),
	('IMPORT', 'strrchr'),
	('IMPORT', '_assertfail'),
	('DATA', '.12', code3, 0, 1),
	('DATA', '.8', code4, 0, 1) ]
module(code=code, name='../gigatron/libc/_lcc_yynull.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_openf', code0)
def code0():
	label('_openf');
	PUSH();
	LDWI('errno');STW(R23);
	LDI(10);DOKE(R23);
	LDWI(-1);
	label('.5');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', '_openf'),
	('CODE', '_openf', code0),
	('IMPORT', 'errno') ]
module(code=code, name='../gigatron/libc/_openf.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_schkread', code0)
def code0():
	label('_schkread');
	PUSH();
	LDWI('errno');STW(R18);
	LDW(R8);PEEK();STW(R17);
	_BNE('.6');
	LDI(3);DOKE(R18);
	_BRA('.7');
	label('.6');
	LDI(2);ADDW(R8);DEEK();ADDI(2);DEEK();
	STW(R19);
	_BNE('.8');
	LDI(10);DOKE(R18);
	_BRA('.9');
	label('.8');
	LDW(R17);ANDI(1);_BNE('.10');
	LDI(9);DOKE(R18);
	_BRA('.11');
	label('.10');
	LDW(R17);ANDI(12);_BNE('.12');
	LDW(R19);
	_BRA('.5');
	label('.12');
	label('.11');
	label('.9');
	label('.7');
	LDI(0);
	label('.5');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', '_schkread'),
	('CODE', '_schkread', code0),
	('IMPORT', 'errno') ]
module(code=code, name='../gigatron/libc/_schkread.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_schkwrite', code0)
def code0():
	label('_schkwrite');
	PUSH();
	LDWI('errno');STW(R18);
	LDW(R8);PEEK();STW(R17);
	_BNE('.6');
	LDI(3);DOKE(R18);
	_BRA('.7');
	label('.6');
	LDI(2);ADDW(R8);DEEK();DEEK();
	STW(R19);
	_BNE('.8');
	LDI(10);DOKE(R18);
	_BRA('.9');
	label('.8');
	LDW(R17);ANDI(2);_BNE('.10');
	LDI(9);DOKE(R18);
	_BRA('.11');
	label('.10');
	LDW(R17);ANDI(12);_BNE('.12');
	LDW(R19);
	_BRA('.5');
	label('.12');
	label('.11');
	label('.9');
	label('.7');
	LDI(0);
	label('.5');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', '_schkwrite'),
	('CODE', '_schkwrite', code0),
	('IMPORT', 'errno') ]
module(code=code, name='../gigatron/libc/_schkwrite.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'cons_read', code0)
def code0():
	label('cons_read');
	_PROLOGUE(16,6,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDI(4);ADDW(R7);STW(R4);
	LDW(R7);PEEK();ANDI(64);_BNE('.15');
	LDI(0);DOKE(R4);
	CALLI('console_waitkey');
	STW(R5);
	_BRA('.13');
	label('.14');
	LDWI('cons_ibuf');DOKE(R4);
	STW(R8);
	LDI(80);STW(R9);
	CALLI('console_readline');
	label('.15');
	LDW(R4);DEEK();
	_BEQ('.14');
	PEEK();
	STW(R5);
	_BEQ('.14');
	LDW(R4);DEEK();ADDI(1);DOKE(R4);
	label('.13');
	LDW(R5);POKE(R6);
	LDI(1);
	label('.11');
	_EPILOGUE(16,6,0xf0,saveAC=True);
# ======== ('DATA', '_iov0', code1, 8, 2)
def code1():
	align(2);
	label('_iov0');
	words(0);
	words('cons_read');
	space(4);
# ======== ('DATA', '_iob0', code2, 6, 2)
def code2():
	align(2);
	label('_iob0');
	bytes(193); # 193
	bytes(0); # 0
	words('_iov0');
	words(0);
# ======== ('BSS', 'cons_ibuf', code3, 80, 1)
def code3():
	label('cons_ibuf');
	space(80);
# ======== (epilog)
code=[
	('CODE', 'cons_read', code0),
	('DATA', '_iov0', code1, 8, 2),
	('EXPORT', '_iob0'),
	('DATA', '_iob0', code2, 6, 2),
	('BSS', 'cons_ibuf', code3, 80, 1),
	('IMPORT', 'console_readline'),
	('IMPORT', 'console_waitkey') ]
module(code=code, name='../gigatron/libc/_stdin.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', '_iov1', code0, 8, 2)
def code0():
	align(2);
	label('_iov1');
	words('console_writall');
	words(0);
	space(4);
# ======== ('DATA', '_iob1', code1, 6, 2)
def code1():
	align(2);
	label('_iob1');
	bytes(194); # 194
	bytes(0); # 0
	words('_iov1');
	words(1);
# ======== ('DATA', '_iob2', code2, 6, 2)
def code2():
	align(2);
	label('_iob2');
	bytes(130); # 130
	bytes(0); # 0
	words('_iov1');
	words(2);
# ======== (epilog)
code=[
	('DATA', '_iov1', code0, 8, 2),
	('EXPORT', '_iob1'),
	('DATA', '_iob1', code1, 6, 2),
	('EXPORT', '_iob2'),
	('DATA', '_iob2', code2, 6, 2),
	('IMPORT', 'console_writall') ]
module(code=code, name='../gigatron/libc/_stdout.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'abort', code0)
def code0():
	label('abort');
	_PROLOGUE(8,6,0x0); # save=None
	LDI(0);STW(R8);
	LDWI('.4');STW(R9);
	CALLI('_raisem');
	label('.3');
	_EPILOGUE(8,6,0x0);
# ======== ('DATA', '.4', code1, 0, 1)
def code1():
	label('.4');
	bytes(65,98,111,114,116,0);
# ======== (epilog)
code=[
	('EXPORT', 'abort'),
	('CODE', 'abort', code0),
	('IMPORT', '_raisem'),
	('DATA', '.4', code1, 0, 1) ]
module(code=code, name='../gigatron/libc/abort.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', 'P', code0, 30, 1)
def code0():
	label('P');
	bytes(121,11,92,216,95); # 0.00425301
	bytes(128,154,26,9,154); # -0.60196
	bytes(131,46,58,88,188); # 5.44462
	bytes(133,130,25,142,241); # -16.2625
	bytes(133,28,128,62,212); # 19.5626
	bytes(132,131,43,96,54); # -8.19809
# ======== ('DATA', 'Q', code1, 25, 1)
def code1():
	label('Q');
	bytes(132,235,218,200,91); # -14.7409
	bytes(135,12,254,1,48); # 70.4961
	bytes(136,147,45,219,106); # -147.179
	bytes(136,11,130,180,40); # 139.511
	bytes(134,196,193,16,82); # -49.1885
# ======== ('CODE', 'k_asin', code2)
def code2():
	label('k_asin');
	_PROLOGUE(32,12,0xfc); # save=R2-7
	_MOVF(F8,F5);
	_MOVF(F5,FAC);LDI(F5);_FMUL();_MOVF(FAC,F2);
	_MOVF(F2,F8);
	LDWI('P');STW(R11);
	LDI(5);STW(R12);
	CALLI('_polevl');_MOVF(FAC,F21);
	STW(T0);_MOVF(F21,[SP,-5+32]);LDW(T0) #genspill
	_MOVF(F2,F8);
	LDWI('Q');STW(R11);
	LDI(5);STW(R12);
	CALLI('_p1evl');_MOVF(FAC,F18);
	_MOVF(F2,FAC);_SP(-5+32);_FMUL();LDI(F18);_FDIV();_MOVF(FAC,F2);
	_MOVF(F5,FAC);LDI(F2);_FMUL();LDI(F5);_FADD();
	label('.3');
	_EPILOGUE(32,12,0xfc);
# ======== ('CODE', 'k_acos', code3)
def code3():
	label('k_acos');
	_PROLOGUE(16,8,0xe0); # save=R5-7
	_MOVF(F8,F5);
	_MOVF(F5,FAC);LDWI('_fone');_FSUBR();_MOVF(FAC,F8);
	LDWI(-1);STW(R11);
	CALLI('ldexp');
	_MOVF(FAC,F8);
	CALLI('sqrt');
	_MOVF(FAC,F8);
	CALLI('k_asin');
	_MOVF(FAC,F8);
	LDI(1);STW(R11);
	CALLI('ldexp');
	
	label('.4');
	_EPILOGUE(16,8,0xe0);
# ======== ('CODE', 'asin', code4)
def code4():
	label('asin');
	_PROLOGUE(24,10,0xe0); # save=R5-7
	_MOVF(F8,F5);
	_MOVF('_fone',F8);
	_MOVF(F5,F11);
	CALLI('copysign');
	_MOVF(FAC,[SP,-5+24]);
	_MOVF(F5,F8);
	CALLI('fabs');
	_MOVF(FAC,F5);
	_MOVF(F5,FAC);LDWI('_fone');_FCMP();_BLE('.6');
	LDWI('errno');STW(R23);
	LDI(1);DOKE(R23);
	_MOVF('_fzero',F8);
	CALLI('_fexception');
	
	_BRA('.5');
	label('.6');
	_MOVF(F5,FAC);LDWI('_fhalf');_FCMP();_BLE('.8');
	_MOVF(F5,F8);
	CALLI('k_acos');
	LDWI('_pi_over_2');_FSUBR();_MOVF(FAC,F5);
	_BRA('.9');
	label('.8');
	_MOVF(F5,F8);
	CALLI('k_asin');
	_MOVF(FAC,F5);
	label('.9');
	_MOVF(F5,F8);
	_MOVF([SP,-5+24],F11);
	CALLI('copysign');
	
	label('.5');
	_EPILOGUE(24,10,0xe0);
# ======== ('CODE', 'acos', code5)
def code5():
	label('acos');
	_PROLOGUE(20,8,0xf0); # save=R4-7
	_MOVF(F8,F5);
	_MOVF(F5,FAC);LDWI('_fzero');_FCMP();_BGE('.12');
	LDI(1);STW(R4);
	_BRA('.13');
	label('.12');
	LDI(0);STW(R4);
	label('.13');
	_SP(-2+20);STW(R23);
	LDW(R4);DOKE(R23);
	_MOVF(F5,F8);
	CALLI('fabs');
	_MOVF(FAC,F5);
	_MOVF(F5,FAC);LDWI('_fone');_FCMP();_BLE('.14');
	LDWI('errno');STW(R23);
	LDI(1);DOKE(R23);
	_MOVF('_fzero',F8);
	CALLI('_fexception');
	
	_BRA('.10');
	label('.14');
	_MOVF(F5,FAC);LDWI('_fhalf');_FCMP();_BLE('.16');
	_MOVF(F5,F8);
	CALLI('k_acos');
	_MOVF(FAC,F5);
	_BRA('.17');
	label('.16');
	_MOVF(F5,F8);
	CALLI('k_asin');
	LDWI('_pi_over_2');_FSUBR();_MOVF(FAC,F5);
	label('.17');
	_SP(-2+20);DEEK();_BEQ('.18');
	_MOVF(F5,FAC);LDWI('_pi');_FSUBR();_MOVF(FAC,F5);
	label('.18');
	_MOVF(F5,FAC);
	label('.10');
	_EPILOGUE(20,8,0xf0);
# ======== (epilog)
code=[
	('DATA', 'P', code0, 30, 1),
	('DATA', 'Q', code1, 25, 1),
	('CODE', 'k_asin', code2),
	('CODE', 'k_acos', code3),
	('EXPORT', 'asin'),
	('CODE', 'asin', code4),
	('EXPORT', 'acos'),
	('CODE', 'acos', code5),
	('IMPORT', '_p1evl'),
	('IMPORT', '_polevl'),
	('IMPORT', '_fexception'),
	('IMPORT', '_fhalf'),
	('IMPORT', '_fone'),
	('IMPORT', '_fzero'),
	('IMPORT', 'errno'),
	('IMPORT', '_pi_over_2'),
	('IMPORT', '_pi'),
	('IMPORT', 'copysign'),
	('IMPORT', 'fabs'),
	('IMPORT', 'sqrt'),
	('IMPORT', 'ldexp') ]
module(code=code, name='../gigatron/libc/asin.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_assertfail', code0)
def code0():
	label('_assertfail');
	_PROLOGUE(8,4,0x80); # save=R7
	LDW(R8);STW(R7);
	LDI(0);STW(R8);
	LDW(R7);STW(R9);
	CALLI('_raisem');
	LDI(0);
	label('.3');
	_EPILOGUE(8,4,0x80,saveAC=True);
# ======== ('CODE', 'assert', code1)
def code1():
	label('assert');
	_PROLOGUE(8,4,0x80); # save=R7
	LDW(R8);STW(R7);
	_BNE('.5');
	LDI(0);STW(R8);
	CALLI('_assertfail');
	label('.5');
	label('.4');
	_EPILOGUE(8,4,0x80);
# ======== (epilog)
code=[
	('EXPORT', '_assertfail'),
	('CODE', '_assertfail', code0),
	('EXPORT', 'assert'),
	('CODE', 'assert', code1),
	('IMPORT', '_raisem') ]
module(code=code, name='../gigatron/libc/assert.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', 'P', code0, 25, 1)
def code0():
	label('P');
	bytes(128,224,3,253,16); # -0.875061
	bytes(133,129,66,162,219); # -16.1575
	bytes(135,150,4,97,180); # -75.0086
	bytes(135,245,197,249,104); # -122.887
	bytes(135,129,179,79,233); # -64.8502
# ======== ('DATA', 'Q', code1, 25, 1)
def code1():
	label('Q');
	bytes(133,70,222,34,217); # 24.8585
	bytes(136,37,6,234,30); # 165.027
	bytes(137,88,112,198,151); # 432.881
	bytes(137,114,177,248,158); # 485.39
	bytes(136,66,140,247,222); # 194.551
# ======== ('CODE', 'atan', code2)
def code2():
	label('atan');
	_PROLOGUE(40,10,0xfc); # save=R2-7
	_MOVF(F8,F5);
	_MOVF('_fone',F8);
	_MOVF(F5,F11);
	CALLI('copysign');
	_MOVF(FAC,[SP,-10+40]);
	_MOVF('.4',[SP,-5+40]);
	_MOVF(F5,F8);
	CALLI('fabs');
	_MOVF(FAC,F5);
	_MOVF(F5,FAC);LDWI('.7');_FCMP();_BLE('.5');
	_MOVF('_pi_over_2',[SP,-5+40]);
	LDWI('_fminus');_FDIVR();_MOVF(FAC,F5);
	_BRA('.6');
	label('.5');
	_MOVF(F5,FAC);LDWI('.10');_FCMP();_BLE('.8');
	_MOVF('_pi_over_4',[SP,-5+40]);
	_MOVF('_fone',F21);
	LDI(F21);_FADD();_MOVF(FAC,F18);
	_MOVF(F5,FAC);LDI(F21);_FSUB();LDI(F18);_FDIV();_MOVF(FAC,F5);
	label('.8');
	label('.6');
	_MOVF(F5,FAC);LDI(F5);_FMUL();_MOVF(FAC,F2);
	_MOVF(F2,F8);
	LDWI('P');STW(R11);
	LDI(4);STW(R12);
	CALLI('_polevl');_MOVF(FAC,F21);
	STW(T0);_MOVF(F21,[SP,-15+40]);LDW(T0) #genspill
	_MOVF(F2,F8);
	LDWI('Q');STW(R11);
	LDI(5);STW(R12);
	CALLI('_p1evl');_MOVF(FAC,F18);
	_MOVF(F2,FAC);_SP(-15+40);_FMUL();LDI(F18);_FDIV();_MOVF(FAC,F2);
	_MOVF(F5,FAC);LDI(F2);_FMUL();LDI(F5);_FADD();_MOVF(FAC,F5);
	_SP(-5+40);_FADD();_MOVF(FAC,F8);
	_MOVF([SP,-10+40],F11);
	CALLI('copysign');
	
	label('.3');
	_EPILOGUE(40,10,0xfc);
# ======== ('DATA', '.10', code3, 0, 1)
def code3():
	label('.10');
	bytes(128,25,153,153,154); # 0.6
# ======== ('DATA', '.7', code4, 0, 1)
def code4():
	label('.7');
	bytes(130,25,153,153,154); # 2.4
# ======== ('DATA', '.4', code5, 0, 1)
def code5():
	label('.4');
	bytes(0,0,0,0,0); # 0
# ======== (epilog)
code=[
	('DATA', 'P', code0, 25, 1),
	('DATA', 'Q', code1, 25, 1),
	('EXPORT', 'atan'),
	('CODE', 'atan', code2),
	('IMPORT', '_p1evl'),
	('IMPORT', '_polevl'),
	('IMPORT', '_fminus'),
	('IMPORT', '_fone'),
	('IMPORT', '_pi_over_4'),
	('IMPORT', '_pi_over_2'),
	('IMPORT', 'copysign'),
	('IMPORT', 'fabs'),
	('DATA', '.10', code3, 0, 1),
	('DATA', '.7', code4, 0, 1),
	('DATA', '.4', code5, 0, 1) ]
module(code=code, name='../gigatron/libc/atan.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'atan2', code0)
def code0():
	label('atan2');
	_PROLOGUE(36,12,0xfc); # save=R2-7
	_MOVF(F8,F5);
	_MOVF(F11,F2);
	_MOVF('_fone',F8);
	_MOVF(F2,F11);
	CALLI('copysign');
	_MOVF(FAC,[SP,-5+36]);
	_MOVF('_fone',F8);
	_MOVF(F5,F11);
	CALLI('copysign');
	_MOVF(FAC,[SP,-10+36]);
	_MOVF(F2,F8);
	CALLI('fabs');
	_MOVF(FAC,F2);
	_MOVF(F5,F8);
	CALLI('fabs');
	_MOVF(FAC,F5);
	_MOVF('.6',F21);
	_MOVF(F2,FAC);LDI(F21);_FCMP();_BNE('.4');
	_MOVF(F5,FAC);LDI(F21);_FCMP();_BNE('.4');
	_MOVF('.6',F2);
	_BRA('.5');
	label('.4');
	_MOVF(F5,FAC);LDI(F2);_FCMP();_BGT('.7');
	LDI(F2);_FDIV();_MOVF(FAC,F8);
	CALLI('atan');
	_MOVF(FAC,F2);
	_BRA('.8');
	label('.7');
	_MOVF(F2,FAC);LDI(F5);_FDIV();_MOVF(FAC,F8);
	CALLI('atan');
	LDWI('_pi_over_2');_FSUBR();_MOVF(FAC,F2);
	label('.8');
	label('.5');
	_MOVF('_fzero',FAC);_SP(-5+36);_FCMP();_BLE('.9');
	_MOVF(F2,FAC);LDWI('_pi');_FSUBR();_MOVF(FAC,F2);
	label('.9');
	_MOVF('_fzero',FAC);_SP(-10+36);_FCMP();_BLE('.11');
	_MOVF(F2,FAC);_FNEG();_MOVF(FAC,F2);
	label('.11');
	_MOVF(F2,FAC);
	label('.3');
	_EPILOGUE(36,12,0xfc);
# ======== ('DATA', '.6', code1, 0, 1)
def code1():
	label('.6');
	bytes(0,0,0,0,0); # 0
# ======== (epilog)
code=[
	('EXPORT', 'atan2'),
	('CODE', 'atan2', code0),
	('IMPORT', '_fone'),
	('IMPORT', '_fzero'),
	('IMPORT', '_pi_over_2'),
	('IMPORT', '_pi'),
	('IMPORT', 'copysign'),
	('IMPORT', 'fabs'),
	('IMPORT', 'atan'),
	('DATA', '.6', code1, 0, 1) ]
module(code=code, name='../gigatron/libc/atan2.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'atexit', code0)
def code0():
	label('atexit');
	PUSH();
	LDWI(0xbeef);STW(R23);
	LDWI('__glink_magic_fini');DEEK();XORW(R23);_BEQ('.4');
	LDI(0);STW(R19);
	_BRA('.9');
	label('.6');
	LDWI('atexit_chain');STW(R23);
	LDW(R19);_SHLI(2);ADDW(R23);DEEK();_BNE('.10');
	LDWI('atexit_chain');STW(R23);
	LDW(R19);_SHLI(2);ADDW(R23);STW(R23);
	LDW(R8);DOKE(R23);
	LDWI(v('atexit_chain')+2);STW(R23);
	LDW(R19);_SHLI(2);ADDW(R23);STW(R23);
	LDWI('__glink_magic_fini');DEEK();DOKE(R23);
	LDWI('__glink_magic_fini');STW(R23);
	LDWI('atexit_chain');STW(R22);
	LDW(R19);_SHLI(2);ADDW(R22);DOKE(R23);
	LDI(0);
	_BRA('.3');
	label('.10');
	label('.7');
	LDI(1);ADDW(R19);STW(R19);
	label('.9');
	LDW(R19);_CMPIU(4);_BLT('.6');
	label('.4');
	LDWI(-1);
	label('.3');
	tryhop(2);POP();RET()
# ======== ('BSS', 'atexit_chain', code1, 16, 2)
def code1():
	align(2);
	label('atexit_chain');
	space(16);
# ======== (epilog)
code=[
	('EXPORT', 'atexit'),
	('CODE', 'atexit', code0),
	('BSS', 'atexit_chain', code1, 16, 2),
	('IMPORT', '__glink_magic_fini') ]
module(code=code, name='../gigatron/libc/atexit.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'atoi', code0)
def code0():
	label('atoi');
	PUSH();
	LDI(0);STW(R19);
	STW(R18);
	LDW(R8);PEEK();STW(R17);
	_BRA('.5');
	label('.4');
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R17);
	label('.5');
	LDW(R17);XORI(32);_BEQ('.4');
	LDW(R17);SUBI(9);_BLT('.7');
	LDW(R17);SUBI(13);_BLE('.4');
	label('.7');
	LDW(R17);XORI(45);_BNE('.8');
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();
	STW(R17);
	STW(R18);
	_BRA('.13');
	label('.8');
	LDW(R17);XORI(43);_BNE('.13');
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R17);
	_BRA('.13');
	label('.12');
	LDW(R17);SUBI(48);STW(R17);
	LDW(R19);LSLW();LSLW();ADDW(R19);LSLW();ADDW(R17);STW(R19);
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R17);
	label('.13');
	LDW(R17);SUBI(48);_BLT('.15');
	LDW(R17);SUBI(57);_BLE('.12');
	label('.15');
	LDW(R18);_BEQ('.16');
	LDI(0);SUBW(R19);STW(R19);
	label('.16');
	LDW(R19);
	label('.3');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'atoi'),
	('CODE', 'atoi', code0) ]
module(code=code, name='../gigatron/libc/atoi.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'atol', code0)
def code0():
	label('atol');
	PUSH();
	_MOVL('.4',L18);
	LDI(0);STW(R17);
	LDW(R8);PEEK();STW(R16);
	_BRA('.6');
	label('.5');
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R16);
	label('.6');
	LDW(R16);XORI(32);_BEQ('.5');
	LDW(R16);SUBI(9);_BLT('.8');
	LDW(R16);SUBI(13);_BLE('.5');
	label('.8');
	LDW(R16);XORI(45);_BNE('.9');
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();
	STW(R16);
	STW(R17);
	_BRA('.14');
	label('.9');
	LDW(R16);XORI(43);_BNE('.14');
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R16);
	_BRA('.14');
	label('.13');
	LDW(R16);SUBI(48);STW(R16);
	_STLS(L22);
	_MOVL(L18,LAC);LDWI('.16');_LMUL();LDI(L22);_LADD();_MOVL(LAC,L18);
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();STW(R16);
	label('.14');
	LDW(R16);SUBI(48);_BLT('.17');
	LDW(R16);SUBI(57);_BLE('.13');
	label('.17');
	LDW(R17);_BEQ('.18');
	_MOVL(L18,LAC);_LNEG();_MOVL(LAC,L18);
	label('.18');
	_MOVL(L18,LAC);
	label('.3');
	tryhop(2);POP();RET()
# ======== ('DATA', '.16', code1, 0, 4)
def code1():
	align(4);
	label('.16');
	words(10,0); # 10
# ======== ('DATA', '.4', code2, 0, 4)
def code2():
	align(4);
	label('.4');
	words(0,0); # 0
# ======== (epilog)
code=[
	('EXPORT', 'atol'),
	('CODE', 'atol', code0),
	('DATA', '.16', code1, 0, 4),
	('DATA', '.4', code2, 0, 4) ]
module(code=code, name='../gigatron/libc/atol.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'bsearch', code0)
def code0():
	label('bsearch');
	_PROLOGUE(24,4,0xff); # save=R0-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R11);STW(R4);
	LDW(R12);STW(R3);
	_SP(-2+24);STW(R23);
	LDW(R6);DOKE(R23);
	LDW(R7);_BNE('.5');
	LDWI('.4');STW(R8);
	CALLI('_assertfail');
	label('.5');
	LDW(R6);_BNE('.7');
	LDW(R5);_BEQ('.7');
	LDWI('.6');STW(R8);
	CALLI('_assertfail');
	label('.7');
	LDW(R3);_BNE('.9');
	LDWI('.8');STW(R8);
	CALLI('_assertfail');
	label('.9');
	LDW(R5);STW(R2);
	_BRA('.13');
	label('.10');
	_SP(-2+24);DEEK();STW(R23);
	LDW(R2);_SHRIU(1);_MUL(R4);ADDW(R23);STW(R0);
	LDW(R7);STW(R8);
	LDW(R0);STW(R9);
	CALL(R3);
	STW(R1);
	_BNE('.14');
	LDW(R0);
	_BRA('.3');
	label('.14');
	LDW(R1);_BLE('.16');
	_SP(-2+24);STW(R23);
	LDW(R4);ADDW(R0);DOKE(R23);
	LDW(R2);SUBI(1);STW(R2);
	label('.16');
	label('.11');
	LDW(R2);_SHRIU(1);STW(R2);
	label('.13');
	LDW(R2);_BNE('.10');
	LDI(0);
	label('.3');
	_EPILOGUE(24,4,0xff,saveAC=True);
# ======== ('DATA', '.8', code1, 0, 1)
def code1():
	label('.8');
	bytes(46,46,47,103,105,103,97,116);
	bytes(114,111,110,47,108,105,98,99);
	bytes(47,98,115,101,97,114,99,104);
	bytes(46,99,58,54,50,58,32,65);
	bytes(115,115,101,114,116,105,111,110);
	bytes(32,99,111,109,112,97,114,32);
	bytes(33,61,32,78,85,76,76,32);
	bytes(102,97,105,108,101,100,46,0);
# ======== ('DATA', '.6', code2, 0, 1)
def code2():
	label('.6');
	bytes(46,46,47,103,105,103,97,116);
	bytes(114,111,110,47,108,105,98,99);
	bytes(47,98,115,101,97,114,99,104);
	bytes(46,99,58,54,49,58,32,65);
	bytes(115,115,101,114,116,105,111,110);
	bytes(32,98,97,115,101,48,32,33);
	bytes(61,32,78,85,76,76,32,124);
	bytes(124,32,110,109,101,109,98,32);
	bytes(61,61,32,48,32,102,97,105);
	bytes(108,101,100,46,0);
# ======== ('DATA', '.4', code3, 0, 1)
def code3():
	label('.4');
	bytes(46,46,47,103,105,103,97,116);
	bytes(114,111,110,47,108,105,98,99);
	bytes(47,98,115,101,97,114,99,104);
	bytes(46,99,58,54,48,58,32,65);
	bytes(115,115,101,114,116,105,111,110);
	bytes(32,107,101,121,32,33,61,32);
	bytes(78,85,76,76,32,102,97,105);
	bytes(108,101,100,46,0);
# ======== (epilog)
code=[
	('EXPORT', 'bsearch'),
	('CODE', 'bsearch', code0),
	('IMPORT', '_assertfail'),
	('DATA', '.8', code1, 0, 1),
	('DATA', '.6', code2, 0, 1),
	('DATA', '.4', code3, 0, 1) ]
module(code=code, name='../gigatron/libc/bsearch.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'calloc', code0)
def code0():
	label('calloc');
	_PROLOGUE(16,6,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);_MUL(R6);STW(R5);
	STW(R8);
	CALLI('malloc');
	STW(R4);
	_BEQ('.4');
	LDW(R4);STW(R8);
	LDI(0);STW(R9);
	LDW(R5);STW(R10);
	CALLI('memset');
	label('.4');
	LDW(R4);
	label('.3');
	_EPILOGUE(16,6,0xf0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'calloc'),
	('CODE', 'calloc', code0),
	('IMPORT', 'memset'),
	('IMPORT', 'malloc') ]
module(code=code, name='../gigatron/libc/calloc.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_console_ctrl', code0)
def code0():
	label('_console_ctrl');
	_PROLOGUE(8,4,0x80); # save=R7
	LDW(R8);STW(R7);
	_CMPIS(7);_BLT('.16');
	LDW(R7);_CMPIS(12);_BGT('.16');
	LDWI(v('.24')-14);ADDW(R7);ADDW(R7);DEEK();CALL(vAC);
	label('.18');
	LD(v('console_state')+3);ORI(3);ADDI(1);ST(v('console_state')+3);
	_BRA('.17');
	label('.21');
	LDI(4);STW(R8);
	CALLI('_console_bell');
	_BRA('.17');
	label('.22');
	CALLI('clrscr');
	_BRA('.17');
	label('.23');
	CALLI('clreol');
	_BRA('.17');
	label('.16');
	LDI(0);
	_BRA('.15');
	label('.17');
	LDI(1);
	label('.15');
	_EPILOGUE(8,4,0x80,saveAC=True);
# ======== ('DATA', '.24', code1, 0, 2)
def code1():
	align(2);
	label('.24');
	words('.21');
	words('.16');
	words('.18');
	words('.16');
	words('.23');
	words('.22');
# ======== (epilog)
code=[
	('EXPORT', '_console_ctrl'),
	('CODE', '_console_ctrl', code0),
	('DATA', '.24', code1, 0, 2),
	('IMPORT', 'clreol'),
	('IMPORT', 'clrscr'),
	('IMPORT', '_console_bell'),
	('IMPORT', 'console_state') ]
module(code=code, name='../gigatron/libc/cons_ctrl.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'console_clear_line', code0)
def code0():
	label('console_clear_line');
	_PROLOGUE(12,6,0x80); # save=R7
	LDW(R8);STW(R7);
	_BLT('.16');
	LDWI('console_info');DEEK();_CMPWS(R7);_BLE('.16');
	_SP(-2+12);STW(R23);
	LDWI('videoTable');STW(R22);
	LDWI(v('console_info')+4);ADDW(R7);PEEK();ADDW(R22);PEEK();DOKE(R23);
	ST(v(R8)+1);LDI(0);ST(R8);
	LDW('console_state');STW(R9);
	LDI(8);STW(R10);
	CALLI('_console_clear');
	label('.16');
	label('.15');
	_EPILOGUE(12,6,0x80);
# ======== ('CODE', 'console_scroll', code1)
def code1():
	label('console_scroll');
	_PROLOGUE(20,0,0x0); # save=None
	LDW(R9);SUBW(R8);STW(R16);
	SUBI(1);_BLE('.20');
	LDW(R8);STW(R19);
	_BRA('.25');
	label('.22');
	_SP(-15+20);ADDW(R19);STW(R23);
	LDWI('videoTable');STW(R22);
	LDWI(v('console_info')+4);ADDW(R19);PEEK();ADDW(R22);PEEK();POKE(R23);
	label('.23');
	LDI(1);ADDW(R19);STW(R19);
	label('.25');
	LDW(R19);XORW(R9);_BNE('.22');
	LDW(R8);STW(R19);
	_BRA('.30');
	label('.27');
	LDW(R19);ADDW(R10);STW(R18);
	_BRA('.32');
	label('.31');
	LDW(R18);ADDW(R16);STW(R18);
	label('.32');
	LDW(R18);_CMPWS(R8);_BLT('.31');
	_BRA('.35');
	label('.34');
	LDW(R18);SUBW(R16);STW(R18);
	label('.35');
	LDW(R18);_CMPWS(R9);_BGE('.34');
	_SP(-15+20);ADDW(R18);PEEK();STW(R18);
	LDWI('videoTable');STW(R23);
	LDWI(v('console_info')+4);ADDW(R19);PEEK();ADDW(R23);STW(R15);
	LDI(0);STW(R17);
	label('.38');
	LDW(R18);POKE(R15);
	label('.39');
	LDI(1);ADDW(R17);STW(R17);
	LDI(2);ADDW(R15);STW(R15);
	LDI(1);ADDW(R18);STW(R18);
	LDW(R17);XORI(8);_BNE('.38');
	label('.28');
	LDI(1);ADDW(R19);STW(R19);
	label('.30');
	LDW(R19);XORW(R9);_BNE('.27');
	label('.20');
	label('.19');
	_EPILOGUE(20,0,0x0);
# ======== (epilog)
code=[
	('EXPORT', 'console_clear_line'),
	('CODE', 'console_clear_line', code0),
	('EXPORT', 'console_scroll'),
	('CODE', 'console_scroll', code1),
	('IMPORT', 'videoTable'),
	('IMPORT', '_console_clear'),
	('IMPORT', 'console_state'),
	('IMPORT', 'console_info') ]
module(code=code, name='../gigatron/libc/cons_extra.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', 'console_info', code0, 20, 2)
def code0():
	align(2);
	label('console_info');
	words(15); # 15
	words(26); # 26
	bytes(0,16);
	bytes(32,48);
	bytes(64,80);
	bytes(96,112);
	bytes(128,144);
	bytes(160,176);
	bytes(192,208);
	bytes(224);
	space(1);
# ======== ('CODE', '_console_reset', code1)
def code1():
	label('_console_reset');
	_PROLOGUE(16,8,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	LDWI('videoTable');STW(R5);
	LDW(R7);_BLT('.16');
	LDWI('screenMemory');STW(R8);
	LDW(R7);STW(R9);
	LDI(120);STW(R10);
	CALLI('_console_clear');
	label('.16');
	LDI(8);STW(R6);
	label('.18');
	LDW(R5);STW(R23);
	ADDI(2);STW(R5);
	LDW(R6);DOKE(R23);
	label('.19');
	LDI(1);ADDW(R6);STW(R6);
	XORI(128);_BNE('.18');
	label('.15');
	_EPILOGUE(16,8,0xe0);
# ======== (epilog)
code=[
	('EXPORT', 'console_info'),
	('DATA', 'console_info', code0, 20, 2),
	('EXPORT', '_console_reset'),
	('CODE', '_console_reset', code1),
	('IMPORT', 'screenMemory'),
	('IMPORT', 'videoTable'),
	('IMPORT', '_console_clear') ]
module(code=code, name='../gigatron/libc/cons_geom.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'echo', code0)
def code0():
	label('echo');
	_PROLOGUE(12,6,0x80); # save=R7
	LDW(R8);STW(R7);
	_SP(-1+12);STW(R23);
	LDI(63);POKE(R23);
	LDW(R7);XORI(10);_BEQ('.18');
	LDW(R7);_CMPIS(32);_BLT('.16');
	LDI(131);SUBW(R7);_BLE('.16');
	label('.18');
	_SP(-1+12);STW(R23);
	LDW(R7);POKE(R23);
	label('.16');
	_SP(-1+12);STW(R8);
	LDI(1);STW(R9);
	CALLI('console_print');
	label('.15');
	_EPILOGUE(12,6,0x80);
# ======== ('CODE', 'console_readline', code1)
def code1():
	label('console_readline');
	_PROLOGUE(16,4,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);STW(R5);
	LDW(R6);ADDW(R7);SUBI(-v(-3));STW(R4);
	LDI(0);STW(R3);
	_BRA('.23');
	label('.20');
	CALLI('console_waitkey');
	STW(R3);
	XORI(8);_BEQ('.27');
	LDW(R3);XORI(253);_BEQ('.27');
	LDW(R3);XORI(127);_BNE('.24');
	label('.27');
	LDW(R5);_CMPWU(R7);_BLE('.25');
	LDWI('.30');STW(R8);
	LDI(1);STW(R9);
	CALLI('console_print');
	LDW(R5);SUBI(-v(-1));STW(R5);
	STW(R23);
	LDI(0);POKE(R23);
	_BRA('.21');
	label('.24');
	LDW(R5);_CMPWU(R4);_BLT('.33');
	LDW(R3);XORI(10);_BNE('.31');
	label('.33');
	LDW(R3);STW(R8);
	CALLI('echo');
	LDW(R5);STW(R23);
	ADDI(1);STW(R5);
	LDW(R3);POKE(R23);
	LDI(0);POKE(R5);
	label('.31');
	label('.25');
	label('.21');
	label('.23');
	LDW(R3);XORI(10);_BNE('.20');
	LDW(R5);SUBW(R7);
	label('.19');
	_EPILOGUE(16,4,0xf8,saveAC=True);
# ======== ('DATA', '.30', code2, 0, 1)
def code2():
	label('.30');
	bytes(8,0);
# ======== (epilog)
code=[
	('CODE', 'echo', code0),
	('EXPORT', 'console_readline'),
	('CODE', 'console_readline', code1),
	('IMPORT', 'console_waitkey'),
	('IMPORT', 'console_print'),
	('DATA', '.30', code2, 0, 1) ]
module(code=code, name='../gigatron/libc/cons_readline.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'console_exitm_msgfunc', code0)
def code0():
	label('console_exitm_msgfunc');
	_PROLOGUE(8,4,0x80); # save=R7
	LDW(R9);STW(R7);
	_BEQ('.16');
	LDI(3);STW('console_state');
	LDWI('console_info');DEEK();STW(v('console_state')+2);
	LDWI(257);STW(v('console_state')+4);
	LDW(R7);STW(R8);
	LDWI(v('console_info')+2);DEEK();STW(R9);
	CALLI('console_print');
	label('.16');
	label('.15');
	_EPILOGUE(8,4,0x80);
# ======== ('CODE', '_console_setup', code1)
def code1():
	label('_console_setup');
	_PROLOGUE(4,0,0x0); # save=None
	CALLI('console_clear_screen');
	LDWI('_exitm_msgfunc');STW(R23);
	LDWI('console_exitm_msgfunc');DOKE(R23);
	label('.21');
	_EPILOGUE(4,0,0x0);
# ======== (epilog)
code=[
	('CODE', 'console_exitm_msgfunc', code0),
	('EXPORT', '_console_setup'),
	('CODE', '_console_setup', code1),
	('IMPORT', '_exitm_msgfunc'),
	('IMPORT', 'console_clear_screen'),
	('IMPORT', 'console_print'),
	('IMPORT', 'console_state'),
	('IMPORT', 'console_info') ]
module(code=code, name='../gigatron/libc/cons_setup.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', 'console_state', code0, 6, 1)
def code0():
	label('console_state');
	words(16160); # 16160
	bytes(0); # 0
	bytes(0); # 0
	bytes(1); # 1
	bytes(1); # 1
# ======== ('DATA', '__glink_magic_init', code1, 4, 2)
def code1():
	align(2);
	label('__glink_magic_init');
	words('_console_setup');
	words(0);
# ======== (epilog)
code=[
	('EXPORT', 'console_state'),
	('DATA', 'console_state', code0, 6, 1),
	('PLACE', 'console_state', 0x0, 0xff),
	('DATA', '__glink_magic_init', code1, 4, 2),
	('IMPORT', '_console_setup') ]
module(code=code, name='../gigatron/libc/cons_state.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'dtoa', code0)
def code0():
	label('dtoa');
	_PROLOGUE(40,6,0xff); # save=R0-7
	_MOVF(F8,[SP,0+40]);
	LDW(R11);STW(R7);
	LDW(R12);STW(R6);
	LDW(R13);STW(R5);
	LDW(R7);STW(R1);
	_SP(1+40);STW(R0);
	PEEK();ANDI(128);_BEQ('.5');
	LDW(R0);PEEK();ANDI(127);POKE(R0);
	LDI(45);POKE(R1);
	LDI(1);ADDW(R1);STW(R1);
	label('.5');
	_SP(0+40);STW(R8);
	CALLI('_frexp10p');
	STW(R4);
	_SP(0+40);STW(R8);
	_SP(-1+40);STW(R9);
	CALLI('_ftoa');
	STW(R0);
	_SP(-1+40);SUBW(R0);STW(R3);
	LDI(1);STW(R2);
	LDW(R4);ADDW(R3);SUBW(R2);STW(R4);
	LDW(R6);XORI(103);_BNE('.9');
	LDW(R5);SUBI(1);_BLE('.9');
	LDW(R5);SUBI(1);STW(R5);
	label('.9');
	LDW(R6);XORI(102);_BEQ('.13');
	LDW(R6);XORI(101);_BEQ('.11');
	LDI(4);ADDW(R4);_BLT('.11');
	LDW(R4);SUBW(R5);_BGT('.11');
	label('.13');
	LDW(R2);ADDW(R4);STW(R2);
	LDI(0);STW(R4);
	LDW(R6);XORI(102);_BEQ('.14');
	LDI(1);SUBW(R2);ADDW(R5);STW(R5);
	label('.14');
	label('.11');
	LDW(R2);ADDW(R5);_BGE('.16');
	LDI(0);STW(R3);
	_BRA('.17');
	label('.16');
	LDW(R2);ADDW(R5);SUBW(R3);_BGE('.18');
	LDW(R2);ADDW(R5);STW(R3);
	label('.18');
	label('.17');
	LDW(R0);STW(R8);
	LDW(R3);ADDW(R0);STW(R9);
	CALLI('_rnda');
	_BEQ('.20');
	LDW(R0);SUBI(-v(-1));STW(R0);
	LDW(R6);XORI(101);_BEQ('.24');
	LDW(R6);XORI(102);_BEQ('.22');
	LDW(R4);_BEQ('.22');
	label('.24');
	LDW(R3);ADDW(R0);STW(R23);
	LDI(0);POKE(R23);
	LDI(1);ADDW(R4);STW(R4);
	_BRA('.21');
	label('.22');
	LDI(1);ADDW(R2);STW(R2);
	label('.20');
	label('.21');
	LDI(1);SUBW(R2);
	STW(R3);
	_BGE('.25');
	LDI(0);STW(R3);
	label('.25');
	LDW(R2);ADDW(R3);STW(R2);
	_BRA('.28');
	label('.27');
	LDW(R2);_BNE('.30');
	LDI(46);POKE(R1);
	LDI(1);ADDW(R1);STW(R1);
	label('.30');
	LDW(R2);SUBI(1);STW(R2);
	
	_BGE('.32');
	LDW(R5);SUBI(1);STW(R5);
	label('.32');
	LDW(R3);SUBI(1);STW(R3);
	
	_BGE('.34');
	LDW(R0);PEEK();_BEQ('.34');
	LDW(R0);PEEK();POKE(R1);
	LDI(1);ADDW(R0);STW(R0);
	_BRA('.35');
	label('.34');
	LDI(48);POKE(R1);
	label('.35');
	LDI(1);ADDW(R1);STW(R1);
	label('.28');
	LDW(R2);_BGT('.27');
	LDW(R5);_BGT('.27');
	LDW(R6);XORI(103);_BNE('.36');
	LDW(R2);_BGE('.36');
	label('.38');
	LDW(R1);SUBI(-v(-1));STW(R1);
	label('.39');
	LDW(R1);PEEK();XORI(48);_BEQ('.38');
	LDW(R1);PEEK();XORI(46);_BEQ('.41');
	LDI(1);ADDW(R1);STW(R1);
	label('.41');
	label('.36');
	LDW(R4);_BNE('.45');
	LDW(R6);XORI(101);_BNE('.43');
	label('.45');
	LDI(101);POKE(R1);
	LDI(1);ADDW(R1);STW(R1);
	LDW(R4);_BLT('.46');
	LDI(43);POKE(R1);
	_BRA('.47');
	label('.46');
	LDI(0);SUBW(R4);STW(R4);
	LDI(45);POKE(R1);
	label('.47');
	LDI(1);ADDW(R1);STW(R1);
	LDW(R4);STW(R8);
	CALLI('_utwoa');
	STW(R4);
	LD(v(R4)+1);POKE(R1);
	LDI(1);ADDW(R1);STW(R1);
	LDW(R4);POKE(R1);
	LDI(1);ADDW(R1);STW(R1);
	label('.43');
	LDI(0);POKE(R1);
	LDW(R7);
	label('.3');
	_EPILOGUE(40,6,0xff,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'dtoa'),
	('CODE', 'dtoa', code0),
	('IMPORT', '_rnda'),
	('IMPORT', '_ftoa'),
	('IMPORT', '_utwoa'),
	('IMPORT', '_frexp10p') ]
module(code=code, name='../gigatron/libc/dtoa.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', 'errno', code0, 2, 2)
def code0():
	align(2);
	label('errno');
	words(0); # 0
# ======== (epilog)
code=[
	('EXPORT', 'errno'),
	('DATA', 'errno', code0, 2, 2) ]
module(code=code, name='../gigatron/libc/errno.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', 'P', code0, 0, 1)
def code0():
	label('P');
	bytes(116,4,78,110,175); # 0.000126177
	bytes(123,120,54,136,102); # 0.0302994
	bytes(129,0,0,0,0); # 1
# ======== ('DATA', 'Q', code1, 0, 1)
def code1():
	label('Q');
	bytes(110,73,117,181,226); # 3.00199e-06
	bytes(120,37,113,205,168); # 0.00252448
	bytes(126,104,184,76,196); # 0.227266
	bytes(130,0,0,0,0); # 2
# ======== ('DATA', 'C1', code2, 5, 1)
def code2():
	label('C1');
	bytes(128,49,114,0,0); # 0.693146
# ======== ('DATA', 'C2', code3, 5, 1)
def code3():
	label('C2');
	bytes(109,63,190,142,124); # 1.42861e-06
# ======== ('DATA', 'LOG2E', code4, 5, 1)
def code4():
	label('LOG2E');
	bytes(129,56,170,59,41); # 1.4427
# ======== ('CODE', 'exp', code5)
def code5():
	label('exp');
	_PROLOGUE(32,12,0xf0); # save=R4-7
	_MOVF(F8,F5);
	_MOVF(F5,FAC);LDWI('LOG2E');_FMUL();LDWI('.4');_FADD();_MOVF(FAC,F8);
	CALLI('floor');
	_MOVF(FAC,[SP,-5+32]);
	_MOVF([SP,-5+32],FAC);_FTOI();LDW(LAC);STW(R4);
	_MOVF('.7',FAC);_SP(-5+32);_FCMP();_BGT('.5');
	_MOVF('.8',F8);
	CALLI('_foverflow');
	
	_BRA('.3');
	label('.5');
	_MOVF('.11',FAC);_SP(-5+32);_FCMP();_BLE('.9');
	_MOVF('.12',FAC);
	_BRA('.3');
	label('.9');
	_MOVF([SP,-5+32],F21);
	_MOVF(F21,FAC);LDWI('C1');_FMUL();LDI(F5);_FSUBR();_MOVF(FAC,F5);
	_MOVF(F21,FAC);LDWI('C2');_FMUL();LDI(F5);_FSUBR();_MOVF(FAC,F5);
	LDI(F5);_FMUL();_MOVF(FAC,[SP,-10+32]);
	_MOVF([SP,-10+32],F8);
	LDWI('P');STW(R11);
	LDI(2);STW(R12);
	CALLI('_polevl');_MOVF(FAC,F21);
	_MOVF(F5,FAC);LDI(F21);_FMUL();_MOVF(FAC,[SP,-5+32]);
	_MOVF([SP,-10+32],F8);
	LDWI('Q');STW(R11);
	LDI(3);STW(R12);
	CALLI('_polevl');
	_SP(-5+32);_FSUB();_SP(-5+32);_FDIVR();_MOVF(FAC,F5);
	LDWI('_ftwo');_FMUL();LDWI('_fone');_FADD();_MOVF(FAC,F8);
	LDW(R4);STW(R11);
	CALLI('ldexp');
	
	label('.3');
	_EPILOGUE(32,12,0xf0);
# ======== ('DATA', '.12', code6, 0, 1)
def code6():
	label('.12');
	bytes(0,0,0,0,0); # 0
# ======== ('DATA', '.11', code7, 0, 1)
def code7():
	label('.11');
	bytes(137,128,0,0,0); # -256
# ======== ('DATA', '.8', code8, 0, 1)
def code8():
	label('.8');
	bytes(255,127,255,255,255); # 1.70141e+38
# ======== ('DATA', '.7', code9, 0, 1)
def code9():
	label('.7');
	bytes(137,0,0,0,0); # 256
# ======== ('DATA', '.4', code10, 0, 1)
def code10():
	label('.4');
	bytes(128,0,0,0,0); # 0.5
# ======== (epilog)
code=[
	('DATA', 'P', code0, 0, 1),
	('DATA', 'Q', code1, 0, 1),
	('DATA', 'C1', code2, 5, 1),
	('DATA', 'C2', code3, 5, 1),
	('DATA', 'LOG2E', code4, 5, 1),
	('EXPORT', 'exp'),
	('CODE', 'exp', code5),
	('IMPORT', 'floor'),
	('IMPORT', 'ldexp'),
	('IMPORT', '_polevl'),
	('IMPORT', '_foverflow'),
	('IMPORT', '_ftwo'),
	('IMPORT', '_fone'),
	('DATA', '.12', code6, 0, 1),
	('DATA', '.11', code7, 0, 1),
	('DATA', '.8', code8, 0, 1),
	('DATA', '.7', code9, 0, 1),
	('DATA', '.4', code10, 0, 1) ]
module(code=code, name='../gigatron/libc/exp.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'fclose', code0)
def code0():
	label('fclose');
	_PROLOGUE(8,2,0xc0); # save=R6-7
	LDW(R8);STW(R7);
	PEEK();_BNE('.6');
	LDWI('errno');STW(R23);
	LDI(3);DOKE(R23);
	LDWI(-1);
	_BRA('.5');
	label('.6');
	LDW(R7);STW(R8);
	CALLI('_sclose');
	STW(R6);
	LDI(0);POKE(R7);
	LDW(R6);
	label('.5');
	_EPILOGUE(8,2,0xc0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'fclose'),
	('CODE', 'fclose', code0),
	('IMPORT', '_sclose'),
	('IMPORT', 'errno') ]
module(code=code, name='../gigatron/libc/fclose.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'ferror', code0)
def code0():
	label('ferror');
	PUSH();
	LDW(R8);PEEK();ANDI(4);
	label('.5');
	tryhop(2);POP();RET()
# ======== ('CODE', 'feof', code1)
def code1():
	label('feof');
	PUSH();
	LDW(R8);PEEK();ANDI(8);
	label('.6');
	tryhop(2);POP();RET()
# ======== ('CODE', 'clearerr', code2)
def code2():
	label('clearerr');
	PUSH();
	LDW(R8);PEEK();ANDI(243);POKE(R8);
	label('.7');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'ferror'),
	('CODE', 'ferror', code0),
	('EXPORT', 'feof'),
	('CODE', 'feof', code1),
	('EXPORT', 'clearerr'),
	('CODE', 'clearerr', code2) ]
module(code=code, name='../gigatron/libc/ferror.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_flush', code0)
def code0():
	label('_flush');
	_PROLOGUE(12,6,0xc0); # save=R6-7
	LDW(R8);STW(R7);
	_BEQ('.6');
	PEEK();_BEQ('.6');
	LDW(R7);PEEK();ANDI(239);POKE(R7);
	LDI(2);ADDW(R7);DEEK();ADDI(4);DEEK();
	STW(R6);
	_BEQ('.8');
	LDW(R7);STW(R8);
	LDI(0);STW(R9);
	CALL(R6);
	
	_BRA('.5');
	label('.8');
	label('.6');
	LDI(0);
	label('.5');
	_EPILOGUE(12,6,0xc0,saveAC=True);
# ======== ('CODE', 'fflush', code1)
def code1():
	label('fflush');
	_PROLOGUE(8,4,0x80); # save=R7
	LDW(R8);STW(R7);
	_BNE('.11');
	LDWI('_flush');STW(R8);
	CALLI('_swalk');
	LDI(0);
	_BRA('.10');
	label('.11');
	LDW(R7);PEEK();_BNE('.13');
	LDWI('errno');STW(R23);
	LDI(3);DOKE(R23);
	LDWI(-1);
	_BRA('.10');
	label('.13');
	LDW(R7);STW(R8);
	CALLI('_flush');
	
	label('.10');
	_EPILOGUE(8,4,0x80,saveAC=True);
# ======== (epilog)
code=[
	('CODE', '_flush', code0),
	('EXPORT', 'fflush'),
	('CODE', 'fflush', code1),
	('IMPORT', '_swalk'),
	('IMPORT', 'errno') ]
module(code=code, name='../gigatron/libc/fflush.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('BSS', '.6', code0, 1, 1)
def code0():
	label('.6');
	space(1);
# ======== ('CODE', 'fgetc', code1)
def code1():
	label('fgetc');
	_PROLOGUE(16,8,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	PEEK();STW(R6);
	LDW(R7);STW(R8);
	CALLI('_schkread');
	STW(R5);
	_BEQ('.7');
	LDW(R6);ANDI(16);_BEQ('.9');
	LDW(R6);XORI(16);POKE(R7);
	LDI(1);ADDW(R7);PEEK();
	_BRA('.5');
	label('.9');
	LDW(R7);STW(R8);
	LDWI('.6');STW(R9);
	LDI(1);STW(R10);
	CALL(R5);
	_BLE('.11');
	LDWI('.6');PEEK();
	_BRA('.5');
	label('.11');
	label('.7');
	LDWI(-1);
	label('.5');
	_EPILOGUE(16,8,0xe0,saveAC=True);
# ======== (epilog)
code=[
	('BSS', '.6', code0, 1, 1),
	('EXPORT', 'fgetc'),
	('CODE', 'fgetc', code1),
	('IMPORT', '_schkread') ]
module(code=code, name='../gigatron/libc/fgetc.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'fgets', code0)
def code0():
	label('fgets');
	_PROLOGUE(16,4,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R7);STW(R3);
	_BRA('.7');
	label('.6');
	LDW(R3);STW(R23);
	ADDI(1);STW(R3);
	LDW(R4);POKE(R23);
	XORI(10);_BNE('.9');
	_BRA('.8');
	label('.9');
	label('.7');
	LDW(R6);ADDW(R7);SUBI(-v(-1));_CMPWU(R3);_BLE('.11');
	LDW(R5);STW(R8);
	CALLI('fgetc');STW(R23);
	STW(R4);
	LDWI(-1);XORW(R23);_BNE('.6');
	label('.11');
	label('.8');
	LDI(0);POKE(R3);
	LDW(R5);PEEK();ANDI(4);_BEQ('.12');
	LDI(0);
	_BRA('.5');
	label('.12');
	LDW(R5);PEEK();ANDI(8);_BEQ('.14');
	LDW(R3);XORW(R7);_BNE('.14');
	LDI(0);
	_BRA('.5');
	label('.14');
	LDW(R7);
	label('.5');
	_EPILOGUE(16,4,0xf8,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'fgets'),
	('CODE', 'fgets', code0),
	('IMPORT', 'fgetc') ]
module(code=code, name='../gigatron/libc/fgets.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_sflags', code0)
def code0():
	label('_sflags');
	PUSH();
	LDW(R8);PEEK();STW(R17);
	XORI(114);_BEQ('.9');
	LDW(R17);_CMPIS(114);_BGT('.13');
	label('.12');
	LDW(R17);XORI(97);_BEQ('.11');
	_BRA('.6');
	label('.13');
	LDW(R17);XORI(119);_BEQ('.10');
	_BRA('.6');
	label('.9');
	LDI(1);STW(R18);
	_BRA('.15');
	label('.10');
	LDI(2);STW(R18);
	_BRA('.15');
	label('.11');
	LDI(10);STW(R18);
	_BRA('.15');
	label('.6');
	LDI(0);
	_BRA('.5');
	label('.14');
	LDW(R19);XORI(43);_BEQ('.19');
	LDW(R19);_CMPIS(43);_BLT('.17');
	label('.21');
	LDW(R19);XORI(98);_BEQ('.18');
	_BRA('.17');
	label('.19');
	LDI(3);STW(R18);
	_BRA('.18');
	label('.17');
	LDI(0);
	_BRA('.5');
	label('.18');
	label('.15');
	LDI(1);ADDW(R8);STW(R8);
	
	PEEK();
	STW(R19);
	_BNE('.14');
	LDW(R18);
	label('.5');
	tryhop(2);POP();RET()
# ======== ('CODE', 'freopen', code1)
def code1():
	label('freopen');
	_PROLOGUE(16,6,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R6);STW(R8);
	CALLI('_sflags');
	STW(R4);
	_BNE('.23');
	LDWI('errno');STW(R23);
	LDI(3);DOKE(R23);
	LDI(0);
	_BRA('.22');
	label('.23');
	LDW(R5);STW(R8);
	CALLI('_sclose');
	LDW(R4);POKE(R5);
	LDW(R5);STW(R8);
	LDW(R7);STW(R9);
	CALLI('_openf');
	_BLT('.25');
	LDW(R5);PEEK();ANDI(243);POKE(R5);
	LDW(R5);
	_BRA('.22');
	label('.25');
	LDI(0);POKE(R5);
	LDI(0);
	label('.22');
	_EPILOGUE(16,6,0xf0,saveAC=True);
# ======== ('CODE', 'fopen', code2)
def code2():
	label('fopen');
	_PROLOGUE(16,8,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	CALLI('_sfindiob');
	STW(R5);
	_BEQ('.28');
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	LDW(R5);STW(R10);
	CALLI('freopen');
	
	_BRA('.27');
	label('.28');
	LDWI('errno');STW(R23);
	LDI(6);DOKE(R23);
	LDI(0);
	label('.27');
	_EPILOGUE(16,8,0xe0,saveAC=True);
# ======== (epilog)
code=[
	('CODE', '_sflags', code0),
	('EXPORT', 'freopen'),
	('CODE', 'freopen', code1),
	('EXPORT', 'fopen'),
	('CODE', 'fopen', code2),
	('IMPORT', '_sfindiob'),
	('IMPORT', '_sclose'),
	('IMPORT', '_openf'),
	('IMPORT', 'errno') ]
module(code=code, name='../gigatron/libc/fopen.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'fputc', code0)
def code0():
	label('fputc');
	_PROLOGUE(12,6,0xc0); # save=R6-7
	_SP(0+12);STW(R23);
	LDW(R8);DOKE(R23);
	LDW(R9);STW(R7);
	STW(R8);
	CALLI('_schkwrite');
	STW(R6);
	_BEQ('.6');
	_SP(0+12);STW(R8);
	LDI(1);STW(R9);
	LDW(R7);STW(R10);
	CALL(R6);
	XORI(1);_BNE('.8');
	_SP(0+12);DEEK();
	_BRA('.5');
	label('.8');
	label('.6');
	LDWI(-1);
	label('.5');
	_EPILOGUE(12,6,0xc0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'fputc'),
	('CODE', 'fputc', code0),
	('IMPORT', '_schkwrite') ]
module(code=code, name='../gigatron/libc/fputc.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'fputs', code0)
def code0():
	label('fputs');
	_PROLOGUE(16,6,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);STW(R8);
	CALLI('strlen');
	STW(R4);
	LDW(R6);STW(R8);
	CALLI('_schkwrite');
	STW(R5);
	_BEQ('.6');
	LDW(R7);STW(R8);
	LDW(R4);STW(R9);
	LDW(R6);STW(R10);
	CALL(R5);
	XORW(R4);_BNE('.8');
	LDI(0);
	_BRA('.5');
	label('.8');
	label('.6');
	LDWI(-1);
	label('.5');
	_EPILOGUE(16,6,0xf0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'fputs'),
	('CODE', 'fputs', code0),
	('IMPORT', '_schkwrite'),
	('IMPORT', 'strlen') ]
module(code=code, name='../gigatron/libc/fputs.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_fread', code0)
def code0():
	label('_fread');
	_PROLOGUE(20,6,0xfc); # save=R2-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDI(0);STW(R3);
	LDW(R7);STW(R8);
	CALLI('_schkread');
	STW(R2);
	_BEQ('.6');
	LDW(R5);_BEQ('.6');
	LDW(R7);PEEK();
	STW(R4);
	ANDI(16);_BEQ('.11');
	LDW(R4);XORI(16);POKE(R7);
	LDI(1);ADDW(R7);PEEK();POKE(R6);
	LDI(1);ADDW(R3);STW(R3);
	_BRA('.11');
	label('.10');
	LDW(R3);ADDW(R4);STW(R3);
	label('.11');
	LDW(R3);_CMPWU(R5);_BGE('.13');
	LDW(R7);STW(R8);
	LDW(R3);ADDW(R6);STW(R9);
	LDW(R5);SUBW(R3);STW(R10);
	CALL(R2);
	STW(R4);
	_BGT('.10');
	label('.13');
	label('.6');
	LDW(R3);
	label('.5');
	_EPILOGUE(20,6,0xfc,saveAC=True);
# ======== ('CODE', 'fread', code1)
def code1():
	label('fread');
	_PROLOGUE(16,6,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R11);STW(R4);
	STW(R8);
	LDW(R7);STW(R9);
	LDW(R5);_MUL(R6);STW(R10);
	CALLI('_fread');
	_DIVU(R6);
	label('.14');
	_EPILOGUE(16,6,0xf0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', '_fread'),
	('CODE', '_fread', code0),
	('EXPORT', 'fread'),
	('CODE', 'fread', code1),
	('IMPORT', '_schkread') ]
module(code=code, name='../gigatron/libc/fread.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'fscanf', code0)
def code0():
	label('fscanf');
	_PROLOGUE(12,6,0xc0); # save=R6-7
	LDW(R8);STW(R7);
	_SP(2+12);STW(R23);
	LDW(R9);DOKE(R23);
	_SP(4+12);STW(R6);
	LDW(R7);STW(R8);
	_SP(2+12);DEEK();STW(R9);
	LDW(R6);STW(R10);
	CALLI('_doscan');
	
	label('.6');
	_EPILOGUE(12,6,0xc0,saveAC=True);
# ======== ('CODE', 'scanf', code1)
def code1():
	label('scanf');
	_PROLOGUE(12,8,0x80); # save=R7
	_SP(0+12);STW(R23);
	LDW(R8);DOKE(R23);
	_SP(2+12);STW(R7);
	LDWI('_iob0');STW(R8);
	_SP(0+12);DEEK();STW(R9);
	LDW(R7);STW(R10);
	CALLI('_doscan');
	
	label('.8');
	_EPILOGUE(12,8,0x80,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'fscanf'),
	('CODE', 'fscanf', code0),
	('EXPORT', 'scanf'),
	('CODE', 'scanf', code1),
	('IMPORT', '_doscan'),
	('IMPORT', '_iob0') ]
module(code=code, name='../gigatron/libc/fscanf.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_schkseek', code0)
def code0():
	label('_schkseek');
	PUSH();
	LDW(R8);PEEK();
	STW(R19);
	_BNE('.6');
	LDWI('errno');STW(R23);
	LDI(3);DOKE(R23);
	
	_BRA('.5');
	label('.6');
	LDI(2);ADDW(R8);DEEK();ADDI(6);DEEK();_BNE('.8');
	LDWI('errno');STW(R23);
	LDI(10);DOKE(R23);
	
	_BRA('.5');
	label('.8');
	LDI(0);
	label('.5');
	tryhop(2);POP();RET()
# ======== ('CODE', 'ftell', code1)
def code1():
	label('ftell');
	_PROLOGUE(16,12,0x80); # save=R7
	LDW(R8);STW(R7);
	STW(R8);
	CALLI('_schkseek');
	_BNE('.11');
	LDW(R7);STW(R8);
	_MOVL('.13',L9);
	LDI(1);STW(R11);
	LDI(2);ADDW(R7);DEEK();ADDI(6);DEEK();CALL(vAC);
	
	_BRA('.10');
	label('.11');
	_MOVL('.14',LAC);
	label('.10');
	_EPILOGUE(16,12,0x80);
# ======== ('CODE', 'fseek', code2)
def code2():
	label('fseek');
	_PROLOGUE(20,10,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	_MOVL(L9,L5);
	LDW(R11);STW(R4);
	LDW(R7);STW(R8);
	CALLI('_schkseek');
	_BNE('.18');
	LDW(R7);STW(R8);
	_MOVL(L5,L9);
	LDW(R4);STW(R11);
	LDI(2);ADDW(R7);DEEK();ADDI(6);DEEK();CALL(vAC);
	LDWI('.13');_LCMPS();_BGE('.16');
	label('.18');
	LDWI(-1);
	_BRA('.15');
	label('.16');
	LDW(R7);PEEK();ANDI(231);POKE(R7);
	LDI(0);
	label('.15');
	_EPILOGUE(20,10,0xf0,saveAC=True);
# ======== ('CODE', 'rewind', code3)
def code3():
	label('rewind');
	_PROLOGUE(16,12,0x80); # save=R7
	LDW(R8);STW(R7);
	STW(R8);
	_MOVL('.13',L9);
	LDI(0);STW(R11);
	CALLI('fseek');
	LDW(R7);PEEK();ANDI(243);POKE(R7);
	label('.19');
	_EPILOGUE(16,12,0x80);
# ======== ('DATA', '.14', code4, 0, 4)
def code4():
	align(4);
	label('.14');
	words(65535,65535); # -1
# ======== ('DATA', '.13', code5, 0, 4)
def code5():
	align(4);
	label('.13');
	words(0,0); # 0
# ======== (epilog)
code=[
	('CODE', '_schkseek', code0),
	('EXPORT', 'ftell'),
	('CODE', 'ftell', code1),
	('EXPORT', 'fseek'),
	('CODE', 'fseek', code2),
	('EXPORT', 'rewind'),
	('CODE', 'rewind', code3),
	('IMPORT', 'errno'),
	('DATA', '.14', code4, 0, 4),
	('DATA', '.13', code5, 0, 4) ]
module(code=code, name='../gigatron/libc/fseek.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'fgetpos', code0)
def code0():
	label('fgetpos');
	_PROLOGUE(8,2,0xc0); # save=R6-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);STW(R8);
	CALLI('ftell');
	LDW(R6);_MOVL(LAC,[vAC]);
	LDWI('.4');_LCMPS();_BLT('.2');
	LDI(0);
	_BRA('.1');
	label('.2');
	LDWI(-1);
	label('.1');
	_EPILOGUE(8,2,0xc0,saveAC=True);
# ======== ('CODE', 'fsetpos', code1)
def code1():
	label('fsetpos');
	_PROLOGUE(16,10,0xc0); # save=R6-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);STW(R8);
	LDW(R6);_MOVL([vAC],L9);
	LDI(0);STW(R11);
	CALLI('fseek');
	
	label('.5');
	_EPILOGUE(16,10,0xc0,saveAC=True);
# ======== ('DATA', '.4', code2, 0, 4)
def code2():
	align(4);
	label('.4');
	words(0,0); # 0
# ======== (epilog)
code=[
	('EXPORT', 'fgetpos'),
	('CODE', 'fgetpos', code0),
	('EXPORT', 'fsetpos'),
	('CODE', 'fsetpos', code1),
	('IMPORT', 'ftell'),
	('IMPORT', 'fseek'),
	('DATA', '.4', code2, 0, 4) ]
module(code=code, name='../gigatron/libc/fsetpos.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'fwrite', code0)
def code0():
	label('fwrite');
	_PROLOGUE(20,6,0xfc); # save=R2-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R11);STW(R4);
	STW(R8);
	CALLI('_schkwrite');
	STW(R3);
	_BEQ('.6');
	LDW(R6);_MUL(R5);STW(R2);
	LDW(R7);STW(R8);
	LDW(R2);STW(R9);
	LDW(R4);STW(R10);
	CALL(R3);
	XORW(R2);_BNE('.8');
	LDW(R5);
	_BRA('.5');
	label('.8');
	label('.6');
	LDI(0);
	label('.5');
	_EPILOGUE(20,6,0xfc,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'fwrite'),
	('CODE', 'fwrite', code0),
	('IMPORT', '_schkwrite') ]
module(code=code, name='../gigatron/libc/fwrite.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'getc', code0)
def code0():
	label('getc');
	_PROLOGUE(8,4,0x80); # save=R7
	LDW(R8);STW(R7);
	STW(R8);
	CALLI('fgetc');
	
	label('.5');
	_EPILOGUE(8,4,0x80,saveAC=True);
# ======== ('CODE', 'getchar', code1)
def code1():
	label('getchar');
	_PROLOGUE(4,2,0x0); # save=None
	LDWI('_iob0');STW(R8);
	CALLI('fgetc');
	
	label('.6');
	_EPILOGUE(4,2,0x0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'getc'),
	('CODE', 'getc', code0),
	('EXPORT', 'getchar'),
	('CODE', 'getchar', code1),
	('IMPORT', 'fgetc'),
	('IMPORT', '_iob0') ]
module(code=code, name='../gigatron/libc/getc.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'getenv', code0)
def code0():
	label('getenv');
	PUSH();
	LDI(0);
	label('.3');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'getenv'),
	('CODE', 'getenv', code0) ]
module(code=code, name='../gigatron/libc/getenv.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'gets', code0)
def code0():
	label('gets');
	_PROLOGUE(12,2,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	STW(R5);
	LDWI('_iob0');STW(R4);
	_BRA('.7');
	label('.6');
	LDW(R5);STW(R23);
	ADDI(1);STW(R5);
	LDW(R6);POKE(R23);
	label('.7');
	LDW(R4);STW(R8);
	CALLI('fgetc');STW(R23);
	STW(R6);
	LDWI(-1);XORW(R23);_BEQ('.9');
	LDW(R6);XORI(10);_BNE('.6');
	label('.9');
	LDI(0);POKE(R5);
	LDW(R4);PEEK();ANDI(4);_BEQ('.10');
	LDI(0);
	_BRA('.5');
	label('.10');
	LDW(R4);PEEK();ANDI(8);_BEQ('.12');
	LDW(R5);XORW(R7);_BNE('.12');
	LDI(0);
	_BRA('.5');
	label('.12');
	LDW(R7);
	label('.5');
	_EPILOGUE(12,2,0xf0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'gets'),
	('CODE', 'gets', code0),
	('IMPORT', 'fgetc'),
	('IMPORT', '_iob0') ]
module(code=code, name='../gigatron/libc/gets.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'isalpha', code0)
def code0():
	label('isalpha');
	PUSH();
	LDW(R8);ORI(32);STW(R23);
	SUBI(97);_BLT('.3');
	LDW(R23);SUBI(122);_BGT('.3');
	LDI(1);STW(R19);
	_BRA('.4');
	label('.3');
	LDI(0);STW(R19);
	label('.4');
	LDW(R19);
	label('.1');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'isalpha'),
	('CODE', 'isalpha', code0) ]
module(code=code, name='../gigatron/libc/isalpha.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'isascii', code0)
def code0():
	label('isascii');
	PUSH();
	LDWI(0xff80);ANDW(R8);_BNE('.3');
	LDI(1);STW(R19);
	_BRA('.4');
	label('.3');
	LDI(0);STW(R19);
	label('.4');
	LDW(R19);
	label('.1');
	tryhop(2);POP();RET()
# ======== ('CODE', 'isalnum', code1)
def code1():
	label('isalnum');
	PUSH();
	LDW(R8);SUBI(48);_BLT('.10');
	LDW(R8);SUBI(57);_BLE('.9');
	label('.10');
	LDW(R8);ORI(32);STW(R23);
	SUBI(97);_BLT('.7');
	LDW(R23);SUBI(122);_BGT('.7');
	label('.9');
	LDI(1);STW(R19);
	_BRA('.8');
	label('.7');
	LDI(0);STW(R19);
	label('.8');
	LDW(R19);
	label('.5');
	tryhop(2);POP();RET()
# ======== ('CODE', 'iscntrl', code2)
def code2():
	label('iscntrl');
	PUSH();
	LDW(R8);XORI(127);_BEQ('.15');
	LDW(R8);_BLT('.13');
	SUBI(32);_BGE('.13');
	label('.15');
	LDI(1);STW(R19);
	_BRA('.14');
	label('.13');
	LDI(0);STW(R19);
	label('.14');
	LDW(R19);
	label('.11');
	tryhop(2);POP();RET()
# ======== ('CODE', 'ispunct', code3)
def code3():
	label('ispunct');
	PUSH();
	LDW(R8);SUBI(32);_BLE('.18');
	LDW(R8);SUBI(127);_BGE('.18');
	LDW(R8);SUBI(48);_BLT('.20');
	LDW(R8);SUBI(57);_BLE('.18');
	label('.20');
	LDW(R8);ORI(32);STW(R23);
	SUBI(97);_BLT('.21');
	LDW(R23);SUBI(122);_BLE('.18');
	label('.21');
	LDI(1);STW(R19);
	_BRA('.19');
	label('.18');
	LDI(0);STW(R19);
	label('.19');
	LDW(R19);
	label('.16');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'isascii'),
	('CODE', 'isascii', code0),
	('EXPORT', 'isalnum'),
	('CODE', 'isalnum', code1),
	('EXPORT', 'iscntrl'),
	('CODE', 'iscntrl', code2),
	('EXPORT', 'ispunct'),
	('CODE', 'ispunct', code3) ]
module(code=code, name='../gigatron/libc/isascii.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'isdigit', code0)
def code0():
	label('isdigit');
	PUSH();
	LDW(R8);SUBI(48);_BLT('.3');
	LDW(R8);SUBI(57);_BGT('.3');
	LDI(1);STW(R19);
	_BRA('.4');
	label('.3');
	LDI(0);STW(R19);
	label('.4');
	LDW(R19);
	label('.1');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'isdigit'),
	('CODE', 'isdigit', code0) ]
module(code=code, name='../gigatron/libc/isdigit.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'islower', code0)
def code0():
	label('islower');
	PUSH();
	LDW(R8);SUBI(97);_BLT('.3');
	LDW(R8);SUBI(122);_BGT('.3');
	LDI(1);STW(R19);
	_BRA('.4');
	label('.3');
	LDI(0);STW(R19);
	label('.4');
	LDW(R19);
	label('.1');
	tryhop(2);POP();RET()
# ======== ('CODE', 'isupper', code1)
def code1():
	label('isupper');
	PUSH();
	LDW(R8);SUBI(65);_BLT('.7');
	LDW(R8);SUBI(90);_BGT('.7');
	LDI(1);STW(R19);
	_BRA('.8');
	label('.7');
	LDI(0);STW(R19);
	label('.8');
	LDW(R19);
	label('.5');
	tryhop(2);POP();RET()
# ======== ('CODE', 'toupper', code2)
def code2():
	label('toupper');
	PUSH();
	LDW(R8);SUBI(97);_BLT('.10');
	LDW(R8);SUBI(122);_BGT('.10');
	LDW(R8);XORI(32);STW(R8);
	label('.10');
	LDW(R8);
	label('.9');
	tryhop(2);POP();RET()
# ======== ('CODE', 'tolower', code3)
def code3():
	label('tolower');
	PUSH();
	LDW(R8);SUBI(65);_BLT('.13');
	LDW(R8);SUBI(90);_BGT('.13');
	LDW(R8);XORI(32);STW(R8);
	label('.13');
	LDW(R8);
	label('.12');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'islower'),
	('CODE', 'islower', code0),
	('EXPORT', 'isupper'),
	('CODE', 'isupper', code1),
	('EXPORT', 'toupper'),
	('CODE', 'toupper', code2),
	('EXPORT', 'tolower'),
	('CODE', 'tolower', code3) ]
module(code=code, name='../gigatron/libc/islower.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'isgraph', code0)
def code0():
	label('isgraph');
	PUSH();
	LDW(R8);SUBI(32);_BLE('.3');
	LDW(R8);SUBI(131);_BGT('.3');
	LDW(R8);XORI(127);_BEQ('.3');
	LDI(1);STW(R19);
	_BRA('.4');
	label('.3');
	LDI(0);STW(R19);
	label('.4');
	LDW(R19);
	label('.1');
	tryhop(2);POP();RET()
# ======== ('CODE', 'isprint', code1)
def code1():
	label('isprint');
	PUSH();
	LDW(R8);SUBI(32);_BLT('.7');
	LDW(R8);SUBI(131);_BGT('.7');
	LDW(R8);XORI(127);_BEQ('.7');
	LDI(1);STW(R19);
	_BRA('.8');
	label('.7');
	LDI(0);STW(R19);
	label('.8');
	LDW(R19);
	label('.5');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'isgraph'),
	('CODE', 'isgraph', code0),
	('EXPORT', 'isprint'),
	('CODE', 'isprint', code1) ]
module(code=code, name='../gigatron/libc/isprint.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'isspace', code0)
def code0():
	label('isspace');
	PUSH();
	LDW(R8);XORI(32);_BEQ('.5');
	LDW(R8);SUBI(9);_BLT('.3');
	LDW(R8);SUBI(13);_BGT('.3');
	label('.5');
	LDI(1);STW(R19);
	_BRA('.4');
	label('.3');
	LDI(0);STW(R19);
	label('.4');
	LDW(R19);
	label('.1');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'isspace'),
	('CODE', 'isspace', code0) ]
module(code=code, name='../gigatron/libc/isspace.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'isxdigit', code0)
def code0():
	label('isxdigit');
	PUSH();
	LDW(R8);SUBI(48);_BLT('.6');
	LDW(R8);SUBI(57);_BLE('.5');
	label('.6');
	LDW(R8);ORI(32);STW(R23);
	SUBI(97);_BLT('.3');
	LDW(R23);SUBI(122);_BGT('.3');
	label('.5');
	LDI(1);STW(R19);
	_BRA('.4');
	label('.3');
	LDI(0);STW(R19);
	label('.4');
	LDW(R19);
	label('.1');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'isxdigit'),
	('CODE', 'isxdigit', code0) ]
module(code=code, name='../gigatron/libc/isxdigit.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', 'R', code0, 15, 1)
def code0():
	label('R');
	bytes(128,202,33,238,227); # -0.78958
	bytes(133,3,23,227,152); # 16.3867
	bytes(135,128,72,48,137); # -64.141
# ======== ('DATA', 'S', code1, 15, 1)
def code1():
	label('S');
	bytes(134,142,176,106,31); # -35.6723
	bytes(137,28,12,0,137); # 312.094
	bytes(138,192,108,72,206); # -769.692
# ======== ('DATA', 'LOG2', code2, 5, 1)
def code2():
	label('LOG2');
	bytes(128,49,114,23,248); # 0.693147
# ======== ('DATA', 'SQRTH', code3, 5, 1)
def code3():
	label('SQRTH');
	bytes(128,53,4,243,52); # 0.707107
# ======== ('CODE', 'log', code4)
def code4():
	label('log');
	_PROLOGUE(32,10,0xfc); # save=R2-7
	_MOVF(F8,F5);
	_MOVF(F5,FAC);LDWI('.6');_FCMP();_BGT('.4');
	LDWI('errno');STW(R23);
	LDI(1);DOKE(R23);
	_MOVF('.7',F8);
	CALLI('_fexception');
	
	_BRA('.3');
	label('.4');
	_MOVF(F5,F8);
	_SP(-2+32);STW(R11);
	CALLI('frexp');
	_MOVF(FAC,F5);
	_MOVF(F5,FAC);LDWI('SQRTH');_FCMP();_BGE('.8');
	_MOVF(F5,F8);
	LDI(1);STW(R11);
	CALLI('ldexp');
	_MOVF(FAC,F5);
	_SP(-2+32);STW(R23);
	DEEK();SUBI(1);DOKE(R23);
	label('.8');
	_MOVF('_fhalf',F21);
	_MOVF(F5,FAC);LDI(F21);_FSUB();_MOVF(FAC,F2);
	_MOVF(F21,FAC);LDI(F5);_FMUL();LDI(F21);_FADD();_MOVF(FAC,F18);
	_MOVF(F2,FAC);LDI(F21);_FSUB();LDI(F18);_FDIV();_MOVF(FAC,F5);
	LDI(F5);_FMUL();_MOVF(FAC,F2);
	_MOVF(F2,F8);
	LDWI('R');STW(R11);
	LDI(2);STW(R12);
	CALLI('_polevl');_MOVF(FAC,F21);
	STW(T0);_MOVF(F21,[SP,-7+32]);LDW(T0) #genspill
	_MOVF(F2,F8);
	LDWI('S');STW(R11);
	LDI(3);STW(R12);
	CALLI('_p1evl');_MOVF(FAC,F18);
	_MOVF(F2,FAC);_SP(-7+32);_FMUL();LDI(F18);_FDIV();LDI(F5);_FMUL();_MOVF(FAC,F2);
	_SP(-2+32);DEEK();_STLS(LAC);_FCVI();LDWI('LOG2');_FMUL();_MOVF(FAC,F21);
	_MOVF(F5,FAC);LDI(F2);_FADD();LDI(F21);_FADD();
	label('.3');
	_EPILOGUE(32,10,0xfc);
# ======== ('DATA', '.7', code5, 0, 1)
def code5():
	label('.7');
	bytes(255,255,255,255,255); # -1.70141e+38
# ======== ('DATA', '.6', code6, 0, 1)
def code6():
	label('.6');
	bytes(0,0,0,0,0); # 0
# ======== (epilog)
code=[
	('DATA', 'R', code0, 15, 1),
	('DATA', 'S', code1, 15, 1),
	('DATA', 'LOG2', code2, 5, 1),
	('DATA', 'SQRTH', code3, 5, 1),
	('EXPORT', 'log'),
	('CODE', 'log', code4),
	('IMPORT', 'ldexp'),
	('IMPORT', 'frexp'),
	('IMPORT', 'errno'),
	('IMPORT', '_p1evl'),
	('IMPORT', '_polevl'),
	('IMPORT', '_fexception'),
	('IMPORT', '_fhalf'),
	('DATA', '.7', code5, 0, 1),
	('DATA', '.6', code6, 0, 1) ]
module(code=code, name='../gigatron/libc/log.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', 'one_over_ln10', code0, 5, 1)
def code0():
	label('one_over_ln10');
	bytes(127,94,91,216,169); # 0.434294
# ======== ('CODE', 'log10', code1)
def code1():
	label('log10');
	_PROLOGUE(16,8,0xe0); # save=R5-7
	_MOVF(F8,F5);
	_MOVF(F5,F8);
	CALLI('log');
	LDWI('one_over_ln10');_FMUL();
	label('.3');
	_EPILOGUE(16,8,0xe0);
# ======== (epilog)
code=[
	('DATA', 'one_over_ln10', code0, 5, 1),
	('EXPORT', 'log10'),
	('CODE', 'log10', code1),
	('IMPORT', 'log') ]
module(code=code, name='../gigatron/libc/log10.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', 'head', code0, 10, 2)
def code0():
	align(2);
	label('head');
	words(0); # 0
	words('head');
	words('head');
	words('head');
	words('head');
# ======== ('CODE', '__free_block', code1)
def code1():
	label('__free_block');
	PUSH();
	LDW(R8);DEEK();STW(R19);
	LDI(2);ADDW(R8);DEEK();STW(R18);
	_BRA('.5');
	label('.4');
	LDI(2);ADDW(R18);DEEK();STW(R18);
	label('.5');
	LDW(R18);DEEK();ANDI(1);_BNE('.4');
	LDI(8);ADDW(R18);DEEK();STW(R17);
	LDI(8);ADDW(R8);STW(R23);
	LDW(R17);DOKE(R23);
	LDI(6);ADDW(R17);STW(R23);
	LDW(R8);DOKE(R23);
	LDI(6);ADDW(R8);STW(R23);
	LDW(R18);DOKE(R23);
	LDI(8);ADDW(R18);STW(R23);
	LDW(R8);DOKE(R23);
	label('.3');
	tryhop(2);POP();RET()
# ======== ('CODE', '__list_block', code2)
def code2():
	label('__list_block');
	PUSH();
	LDI(4);ADDW(R9);DEEK();STW(R19);
	LDI(4);ADDW(R8);STW(R23);
	LDW(R19);DOKE(R23);
	LDI(2);ADDW(R8);STW(R23);
	LDW(R9);DOKE(R23);
	LDI(2);ADDW(R19);STW(R23);
	LDW(R8);DOKE(R23);
	LDI(4);ADDW(R9);STW(R23);
	LDW(R8);DOKE(R23);
	label('.7');
	tryhop(2);POP();RET()
# ======== ('CODE', '__assume_block_position', code3)
def code3():
	label('__assume_block_position');
	PUSH();
	LDW(R10);DOKE(R8);
	LDI(2);ADDW(R9);DEEK();STW(R19);
	LDI(2);ADDW(R8);STW(R23);
	LDW(R19);DOKE(R23);
	LDI(4);ADDW(R19);STW(R23);
	LDW(R8);DOKE(R23);
	LDI(4);ADDW(R8);DEEK();STW(R18);
	LDI(2);ADDW(R18);STW(R23);
	LDW(R8);DOKE(R23);
	LDI(6);ADDW(R9);DEEK();STW(R19);
	LDI(6);ADDW(R8);STW(R23);
	LDW(R19);DOKE(R23);
	LDI(8);ADDW(R19);STW(R23);
	LDW(R8);DOKE(R23);
	LDI(8);ADDW(R8);DEEK();STW(R18);
	LDI(6);ADDW(R18);STW(R23);
	LDW(R8);DOKE(R23);
	label('.8');
	tryhop(2);POP();RET()
# ======== ('CODE', 'try_merge_with_next', code4)
def code4():
	label('try_merge_with_next');
	_PROLOGUE(16,6,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDI(2);ADDW(R7);DEEK();STW(R6);
	LDW(R7);DEEK();
	STW(R5);
	ANDI(1);_BNE('.13');
	LDW(R6);DEEK();
	STW(R4);
	ANDI(1);_BNE('.13');
	LDW(R5);ADDW(R7);XORW(R6);_BEQ('.10');
	label('.13');
	LDI(0);
	_BRA('.9');
	label('.10');
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	LDW(R5);ADDW(R4);STW(R10);
	CALLI('__assume_block_position');
	LDI(1);
	label('.9');
	_EPILOGUE(16,6,0xf0,saveAC=True);
# ======== ('CODE', 'find_block', code5)
def code5():
	label('find_block');
	_PROLOGUE(20,8,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDWI('head');STW(R4);
	label('.15');
	LDI(6);ADDW(R4);DEEK();STW(R4);
	LDWI('head');XORW(R4);_BNE('.19');
	LDI(0);
	_BRA('.14');
	label('.19');
	LDW(R4);DEEK();
	STW(R5);
	SUBW(R7);
	STW(R6);
	_BLT('.15');
	label('.17');
	LDW(R6);SUBI(10);_BGE('.23');
	LDI(6);ADDW(R4);DEEK();ADDI(8);STW(R23);
	LDI(8);ADDW(R4);DEEK();DOKE(R23);
	LDI(8);ADDW(R4);DEEK();ADDI(6);STW(R23);
	LDI(6);ADDW(R4);DEEK();DOKE(R23);
	LDW(R5);ORI(1);DOKE(R4);
	_BRA('.24');
	label('.23');
	LDW(R7);ADDW(R4);STW(R3);
	LDI(4);ADDW(R3);STW(R23);
	LDI(4);ADDW(R4);DEEK();DOKE(R23);
	LDI(8);ADDW(R3);STW(R23);
	LDI(8);ADDW(R4);DEEK();DOKE(R23);
	LDW(R3);STW(R8);
	LDW(R4);STW(R9);
	LDW(R6);STW(R10);
	CALLI('__assume_block_position');
	LDW(R7);ORI(1);DOKE(R4);
	LDW(R4);STW(R8);
	LDW(R3);STW(R9);
	CALLI('__list_block');
	label('.24');
	LDW(R4);
	label('.14');
	_EPILOGUE(20,8,0xf8,saveAC=True);
# ======== ('CODE', '__chk_block_header', code6)
def code6():
	label('__chk_block_header');
	PUSH();
	LDW(R8);DEEK();ANDI(1);XORI(1);_BNE('.26');
	LDW(R8);STW(R23);
	LDI(2);ADDW(R8);DEEK();ADDI(4);DEEK();XORW(R23);_BNE('.26');
	LDI(4);ADDW(R8);DEEK();ADDI(2);DEEK();XORW(R23);_BNE('.26');
	LDW(R8);DEEK();ORI(1);XORI(1);
	_BRA('.25');
	label('.26');
	LDI(0);
	label('.25');
	tryhop(2);POP();RET()
# ======== ('CODE', 'free', code7)
def code7():
	label('free');
	_PROLOGUE(12,4,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	_BEQ('.29');
	SUBI(-v(-8));
	STW(R6);
	STW(R8);
	CALLI('__chk_block_header');
	STW(R5);
	DOKE(R6);
	_BNE('.31');
	LDI(10);STW(R8);
	LDWI('.33');STW(R9);
	CALLI('_exitm');
	label('.31');
	LDW(R6);STW(R8);
	CALLI('__free_block');
	LDW(R6);STW(R8);
	CALLI('try_merge_with_next');
	LDI(4);ADDW(R6);DEEK();STW(R8);
	CALLI('try_merge_with_next');
	label('.29');
	label('.28');
	_EPILOGUE(12,4,0xe0);
# ======== ('CODE', 'malloc', code8)
def code8():
	label('malloc');
	_PROLOGUE(8,2,0xc0); # save=R6-7
	LDW(R8);STW(R7);
	_CMPIU(4);_BGE('.35');
	LDI(4);STW(R7);
	label('.35');
	LDI(8);ADDW(R7);ADDI(3);ORI(3);XORI(3);STW(R7);
	STW(R23);
	LDWI(0x8000);_CMPWU(R23);_BLE('.37');
	LDW(R7);STW(R8);
	CALLI('find_block');
	STW(R6);
	_BEQ('.39');
	LDI(8);ADDW(R6);
	_BRA('.34');
	label('.39');
	label('.37');
	LDI(0);
	label('.34');
	_EPILOGUE(8,2,0xc0,saveAC=True);
# ======== ('DATA', '__glink_magic_heap', code9, 2, 2)
def code9():
	align(2);
	label('__glink_magic_heap');
	words(48879);
# ======== ('CODE', 'malloc_init', code10)
def code10():
	label('malloc_init');
	_PROLOGUE(12,6,0xc0); # save=R6-7
	LDWI('__glink_magic_heap');DEEK();STW(R7);
	LDWI('__glink_magic_heap');STW(R23);
	LDI(0);DOKE(R23);
	_BRA('.43');
	label('.42');
	LDI(2);ADDW(R7);DEEK();STW(R6);
	LDW(R7);STW(R8);
	LDWI(v('head')+2);DEEK();STW(R9);
	CALLI('__list_block');
	LDW(R7);STW(R8);
	CALLI('__free_block');
	LDW(R6);STW(R7);
	label('.43');
	LDW(R7);STW(R23);
	_BEQ('.46');
	LDWI(0xbeef);XORW(R23);_BNE('.42');
	label('.46');
	label('.41');
	_EPILOGUE(12,6,0xc0);
# ======== ('DATA', '__glink_magic_init', code11, 4, 2)
def code11():
	align(2);
	label('__glink_magic_init');
	words('malloc_init');
	words(0);
# ======== ('DATA', '.33', code12, 0, 1)
def code12():
	label('.33');
	bytes(102,114,101,101,58,32,99,111);
	bytes(114,114,117,112,116,101,100,32);
	bytes(104,101,97,112,33,0);
# ======== (epilog)
code=[
	('DATA', 'head', code0, 10, 2),
	('CODE', '__free_block', code1),
	('CODE', '__list_block', code2),
	('CODE', '__assume_block_position', code3),
	('CODE', 'try_merge_with_next', code4),
	('CODE', 'find_block', code5),
	('EXPORT', '__chk_block_header'),
	('CODE', '__chk_block_header', code6),
	('EXPORT', 'free'),
	('CODE', 'free', code7),
	('EXPORT', 'malloc'),
	('CODE', 'malloc', code8),
	('EXPORT', '__glink_magic_heap'),
	('DATA', '__glink_magic_heap', code9, 2, 2),
	('CODE', 'malloc_init', code10),
	('DATA', '__glink_magic_init', code11, 4, 2),
	('IMPORT', '_exitm'),
	('DATA', '.33', code12, 0, 1) ]
module(code=code, name='../gigatron/libc/malloc.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'ctow', code0)
def code0():
	label('ctow');
	PUSH();
	LDW(R8);ANDI(252);XORI(128);_BNE('.4');
	LDWI(8592);STW(R23);
	LDW(R8);ANDI(3);ADDW(R23);STW(R8);
	label('.4');
	LDW(R8);
	label('.3');
	tryhop(2);POP();RET()
# ======== ('CODE', 'wtoc', code1)
def code1():
	label('wtoc');
	PUSH();
	LDWI(8592);STW(R23);
	LDWI(0xfffc);ANDW(R8);XORW(R23);_BNE('.7');
	LDW(R8);ANDI(3);ORI(128);
	_BRA('.6');
	label('.7');
	LDWI(0xff00);ANDW(R8);_BNE('.11');
	LDW(R8);ANDI(252);XORI(128);_BNE('.9');
	label('.11');
	LDWI(-1);
	_BRA('.6');
	label('.9');
	LDW(R8);
	label('.6');
	tryhop(2);POP();RET()
# ======== ('CODE', 'mblen', code2)
def code2():
	label('mblen');
	PUSH();
	LDW(R8);_BEQ('.15');
	PEEK();_BNE('.13');
	label('.15');
	LDI(0);
	_BRA('.12');
	label('.13');
	LDW(R9);_BNE('.16');
	LDWI(-1);
	_BRA('.12');
	label('.16');
	LDI(1);
	label('.12');
	tryhop(2);POP();RET()
# ======== ('CODE', 'mbtowc', code3)
def code3():
	label('mbtowc');
	_PROLOGUE(12,4,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	_BNE('.19');
	LDWI(-1);
	_BRA('.18');
	label('.19');
	LDW(R6);_BEQ('.23');
	PEEK();_BNE('.21');
	label('.23');
	LDI(0);
	_BRA('.18');
	label('.21');
	LDW(R7);_BEQ('.24');
	LDW(R6);PEEK();STW(R8);
	CALLI('ctow');
	DOKE(R7);
	label('.24');
	LDI(1);
	label('.18');
	_EPILOGUE(12,4,0xe0,saveAC=True);
# ======== ('CODE', 'wctomb', code4)
def code4():
	label('wctomb');
	_PROLOGUE(12,4,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	STW(R8);
	CALLI('wtoc');
	STW(R5);
	LDW(R7);_BNE('.27');
	LDI(0);
	_BRA('.26');
	label('.27');
	LDW(R5);_BGE('.29');
	LDWI(-1);
	_BRA('.26');
	label('.29');
	LDW(R5);POKE(R7);
	LDI(1);
	label('.26');
	_EPILOGUE(12,4,0xe0,saveAC=True);
# ======== ('CODE', 'mbstowcs', code5)
def code5():
	label('mbstowcs');
	_PROLOGUE(12,2,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDI(0);STW(R4);
	LDW(R6);_BEQ('.32');
	_BRA('.35');
	label('.34');
	LDW(R7);_BEQ('.37');
	LDW(R6);PEEK();STW(R8);
	CALLI('ctow');
	DOKE(R7);
	LDI(2);ADDW(R7);STW(R7);
	label('.37');
	LDI(1);ADDW(R4);STW(R4);
	LDI(1);ADDW(R6);STW(R6);
	label('.35');
	LDW(R6);PEEK();_BEQ('.39');
	LDW(R4);_CMPWU(R5);_BLT('.34');
	label('.39');
	label('.32');
	LDW(R4);
	label('.31');
	_EPILOGUE(12,2,0xf0,saveAC=True);
# ======== ('CODE', 'wcstombs', code6)
def code6():
	label('wcstombs');
	_PROLOGUE(16,4,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDI(0);STW(R4);
	LDW(R6);_BEQ('.41');
	_BRA('.44');
	label('.43');
	LDW(R6);DEEK();STW(R8);
	CALLI('wtoc');
	STW(R3);
	_BGE('.46');
	LDWI(0xffff);
	_BRA('.40');
	label('.46');
	LDW(R7);_BEQ('.48');
	STW(R23);
	ADDI(1);STW(R7);
	LDW(R3);POKE(R23);
	label('.48');
	LDI(1);ADDW(R4);STW(R4);
	LDI(2);ADDW(R6);STW(R6);
	label('.44');
	LDW(R6);DEEK();_BEQ('.50');
	LDW(R4);_CMPWU(R5);_BLT('.43');
	label('.50');
	label('.41');
	LDW(R4);
	label('.40');
	_EPILOGUE(16,4,0xf8,saveAC=True);
# ======== (epilog)
code=[
	('CODE', 'ctow', code0),
	('CODE', 'wtoc', code1),
	('EXPORT', 'mblen'),
	('CODE', 'mblen', code2),
	('EXPORT', 'mbtowc'),
	('CODE', 'mbtowc', code3),
	('EXPORT', 'wctomb'),
	('CODE', 'wctomb', code4),
	('EXPORT', 'mbstowcs'),
	('CODE', 'mbstowcs', code5),
	('EXPORT', 'wcstombs'),
	('CODE', 'wcstombs', code6) ]
module(code=code, name='../gigatron/libc/mb.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'memcmp', code0)
def code0():
	label('memcmp');
	PUSH();
	_BRA('.3');
	label('.2');
	LDI(1);ADDW(R8);STW(R8);
	LDI(1);ADDW(R9);STW(R9);
	LDW(R10);SUBI(1);STW(R10);
	label('.3');
	LDW(R10);
	STW(R19);
	_BEQ('.5');
	LDW(R9);PEEK();STW(R23);
	LDW(R8);PEEK();SUBW(R23);
	STW(R19);
	_BEQ('.2');
	label('.5');
	LDW(R19);
	label('.1');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'memcmp'),
	('CODE', 'memcmp', code0) ]
module(code=code, name='../gigatron/libc/memcmp.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'memmove', code0)
def code0():
	label('memmove');
	_PROLOGUE(20,8,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	ADDW(R6);STW(R4);
	LDW(R5);ADDW(R7);STW(R3);
	LDW(R7);STW(R23);
	_CMPWU(R6);_BLT('.4');
	LDW(R23);_CMPWU(R4);_BLT('.6');
	label('.4');
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	LDW(R5);STW(R10);
	CALLI('memcpy');
	
	_BRA('.1');
	label('.5');
	LDWI(-1);ADDW(R3);STW(R3);
	LDWI(-1);ADDW(R4);STW(R4);
	PEEK();POKE(R3);
	label('.6');
	LDW(R4);XORW(R6);_BNE('.5');
	LDW(R7);
	label('.1');
	_EPILOGUE(20,8,0xf8,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'memmove'),
	('CODE', 'memmove', code0),
	('IMPORT', 'memcpy') ]
module(code=code, name='../gigatron/libc/memmove.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'midcprintf', code0)
def code0():
	label('midcprintf');
	_PROLOGUE(20,6,0xe0); # save=R5-7
	_SP(0+20);STW(R23);
	LDW(R8);DOKE(R23);
	LDW(R0);STW(R7);
	_SP(2+20);STW(R5);
	_SP(-2+20);STW(R23);
	LDWI('console_writall');DOKE(R23);
	_SP(0+20);DEEK();STW(R8);
	LDW(R5);STW(R9);
	CALLI('_doprint_simple');
	STW(R6);
	LDW(R7);STW(R0);
	LDW(R6);
	label('.11');
	_EPILOGUE(20,6,0xe0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'midcprintf'),
	('CODE', 'midcprintf', code0),
	('IMPORT', '_doprint_simple'),
	('IMPORT', 'console_writall') ]
module(code=code, name='../gigatron/libc/midcprintf.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'mincprintf', code0)
def code0():
	label('mincprintf');
	_PROLOGUE(24,6,0xf0); # save=R4-7
	_SP(0+24);STW(R23);
	LDW(R8);DOKE(R23);
	STW(R6);
	_SP(2+24);STW(R7);
	_BRA('.12');
	label('.11');
	LDW(R6);PEEK();XORI(37);_BEQ('.14');
	LDW(R6);STW(R5);
	_BRA('.17');
	label('.16');
	LDI(1);ADDW(R6);STW(R6);
	label('.17');
	LDW(R6);PEEK();
	_BEQ('.19');
	XORI(37);_BNE('.16');
	label('.19');
	LDW(R6);SUBW(R5);STW(R4);
	_BRA('.15');
	label('.14');
	LDI(1);ADDW(R6);STW(R6);
	PEEK();STW(R4);
	XORI(115);_BNE('.20');
	LDWI(0xfffe);STW(R23);
	LDI(3);ADDW(R7);ANDW(R23);STW(R7);
	
	SUBI(-v(-2));DEEK();STW(R5);
	LDWI(32767);STW(R4);
	_BRA('.21');
	label('.20');
	LDW(R4);XORI(100);_BNE('.12');
	LDWI(0xfffe);STW(R23);
	LDI(3);ADDW(R7);ANDW(R23);STW(R7);
	
	SUBI(-v(-2));DEEK();STW(R8);
	_SP(-1+24);STW(R9);
	LDI(10);STW(R10);
	CALLI('_itoa');
	STW(R5);
	LDI(8);STW(R4);
	label('.25');
	label('.21');
	LDI(1);ADDW(R6);STW(R6);
	label('.15');
	LDW(R5);STW(R8);
	LDW(R4);STW(R9);
	CALLI('console_print');
	label('.12');
	LDW(R6);PEEK();_BNE('.11');
	LDI(0);
	label('.9');
	_EPILOGUE(24,6,0xf0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'mincprintf'),
	('CODE', 'mincprintf', code0),
	('IMPORT', '_itoa'),
	('IMPORT', 'console_print') ]
module(code=code, name='../gigatron/libc/mincprintf.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'perror', code0)
def code0():
	label('perror');
	_PROLOGUE(12,6,0xc0); # save=R6-7
	LDW(R8);STW(R7);
	LDWI('_iob2');STW(R6);
	LDW(R7);_BEQ('.2');
	PEEK();_BEQ('.2');
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	CALLI('fputs');
	LDWI('.4');STW(R8);
	LDW(R6);STW(R9);
	CALLI('fputs');
	label('.2');
	LDWI('errno');DEEK();STW(R8);
	CALLI('strerror');
	STW(R8);
	LDW(R6);STW(R9);
	CALLI('fputs');
	LDI(10);STW(R8);
	LDW(R6);STW(R9);
	CALLI('fputc');
	label('.1');
	_EPILOGUE(12,6,0xc0);
# ======== ('DATA', '.4', code1, 0, 1)
def code1():
	label('.4');
	bytes(58,32,0);
# ======== (epilog)
code=[
	('EXPORT', 'perror'),
	('CODE', 'perror', code0),
	('IMPORT', 'errno'),
	('IMPORT', 'strerror'),
	('IMPORT', 'fputs'),
	('IMPORT', 'fputc'),
	('IMPORT', '_iob2'),
	('DATA', '.4', code1, 0, 1) ]
module(code=code, name='../gigatron/libc/perror.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_ipow', code0)
def code0():
	label('_ipow');
	PUSH();
	_MOVF(F11,FAC);_FTOI();_MOVL(LAC,L18);
	_MOVF('.4',F15);
	_BRA('.6');
	label('.5');
	_MOVL(L18,LAC);LDWI('.10');_LAND();LDWI('.11');_LCMPX();_BEQ('.8');
	_MOVF(F15,FAC);LDI(F8);_FMUL();_MOVF(FAC,F15);
	label('.8');
	_MOVF(F8,FAC);LDI(F8);_FMUL();_MOVF(FAC,F8);
	_MOVL(L18,LAC);LDI(1);_LSHRS();_MOVL(LAC,L18);
	label('.6');
	_MOVL(L18,LAC);LDWI('.11');_LCMPX();_BNE('.5');
	_MOVF(F15,FAC);
	label('.3');
	tryhop(2);POP();RET()
# ======== ('CODE', 'pow', code1)
def code1():
	label('pow');
	_PROLOGUE(40,10,0xfc); # save=R2-7
	_MOVF(F8,F5);
	_MOVF(F11,F2);
	_MOVF('.4',[SP,-10+40]);
	_MOVF(F2,FAC);LDWI('.16');_FCMP();_BEQ('.15');
	_MOVF(F5,FAC);LDWI('.4');_FCMP();_BNE('.13');
	label('.15');
	_MOVF('.4',FAC);
	_BRA('.12');
	label('.13');
	_MOVF(F2,FAC);LDWI('.16');_FCMP();_BGE('.17');
	_FNEG();_MOVF(FAC,F2);
	_MOVF(F5,FAC);LDWI('.4');_FDIVR();_MOVF(FAC,F5);
	label('.17');
	_MOVF(F2,F8);
	_SP(-5+40);STW(R11);
	CALLI('modf');
	_MOVF(FAC,[SP,-15+40]);
	_MOVF(F5,FAC);LDWI('.16');_FCMP();_BGT('.19');
	LDWI('.16');_FCMP();_BNE('.21');
	_MOVF('.16',FAC);
	_BRA('.12');
	label('.21');
	_MOVF('.16',FAC);_SP(-15+40);_FCMP();_BEQ('.23');
	LDWI('errno');STW(R23);
	LDI(1);DOKE(R23);
	_MOVF('.16',F8);
	CALLI('_fexception');
	
	_BRA('.12');
	label('.23');
	_MOVF([SP,-5+40],FAC);_FTOI();LDW(LAC);ANDI(1);_BEQ('.25');
	_MOVF('.27',[SP,-10+40]);
	label('.25');
	_MOVF(F5,FAC);_FNEG();_MOVF(FAC,F5);
	label('.19');
	_MOVF('.16',FAC);_SP(-15+40);_FCMP();_BNE('.28');
	_MOVF('.30',FAC);_SP(-5+40);_FCMP();_BLE('.28');
	_MOVF(F5,F8);
	_MOVF([SP,-5+40],F11);
	CALLI('_ipow');
	_SP(-10+40);_FMUL();
	_BRA('.12');
	label('.28');
	_MOVF(F5,F8);
	CALLI('log');_MOVF(FAC,F21);
	_MOVF(F2,FAC);LDI(F21);_FMUL();_MOVF(FAC,F8);
	CALLI('exp');
	_SP(-10+40);_FMUL();
	label('.12');
	_EPILOGUE(40,10,0xfc);
# ======== ('DATA', '.30', code2, 0, 1)
def code2():
	label('.30');
	bytes(138,122,0,0,0); # 1000
# ======== ('DATA', '.27', code3, 0, 1)
def code3():
	label('.27');
	bytes(129,128,0,0,0); # -1
# ======== ('DATA', '.16', code4, 0, 1)
def code4():
	label('.16');
	bytes(0,0,0,0,0); # 0
# ======== ('DATA', '.11', code5, 0, 4)
def code5():
	align(4);
	label('.11');
	words(0,0); # 0
# ======== ('DATA', '.10', code6, 0, 4)
def code6():
	align(4);
	label('.10');
	words(1,0); # 1
# ======== ('DATA', '.4', code7, 0, 1)
def code7():
	label('.4');
	bytes(129,0,0,0,0); # 1
# ======== (epilog)
code=[
	('CODE', '_ipow', code0),
	('EXPORT', 'pow'),
	('CODE', 'pow', code1),
	('IMPORT', 'modf'),
	('IMPORT', 'log'),
	('IMPORT', 'exp'),
	('IMPORT', 'errno'),
	('IMPORT', '_fexception'),
	('DATA', '.30', code2, 0, 1),
	('DATA', '.27', code3, 0, 1),
	('DATA', '.16', code4, 0, 1),
	('DATA', '.11', code5, 0, 4),
	('DATA', '.10', code6, 0, 4),
	('DATA', '.4', code7, 0, 1) ]
module(code=code, name='../gigatron/libc/pow.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'putc', code0)
def code0():
	label('putc');
	_PROLOGUE(12,6,0xc0); # save=R6-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	CALLI('fputc');
	
	label('.5');
	_EPILOGUE(12,6,0xc0,saveAC=True);
# ======== ('CODE', 'putchar', code1)
def code1():
	label('putchar');
	_PROLOGUE(8,4,0x80); # save=R7
	LDW(R8);STW(R7);
	STW(R8);
	LDWI('_iob1');STW(R9);
	CALLI('fputc');
	
	label('.6');
	_EPILOGUE(8,4,0x80,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'putc'),
	('CODE', 'putc', code0),
	('EXPORT', 'putchar'),
	('CODE', 'putchar', code1),
	('IMPORT', 'fputc'),
	('IMPORT', '_iob1') ]
module(code=code, name='../gigatron/libc/putc.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'puts', code0)
def code0():
	label('puts');
	_PROLOGUE(8,4,0x80); # save=R7
	LDW(R8);STW(R7);
	STW(R8);
	LDWI('_iob1');STW(R9);
	CALLI('fputs');
	LDI(10);STW(R8);
	LDWI('_iob1');STW(R9);
	CALLI('fputc');
	
	label('.5');
	_EPILOGUE(8,4,0x80,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'puts'),
	('CODE', 'puts', code0),
	('IMPORT', 'fputs'),
	('IMPORT', 'fputc'),
	('IMPORT', '_iob1') ]
module(code=code, name='../gigatron/libc/puts.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'med3', code0)
def code0():
	label('med3');
	_PROLOGUE(16,4,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R11);STW(R4);
	LDW(R7);STW(R3);
	STW(R8);
	LDW(R6);STW(R9);
	CALL(R4);
	_BGE('.4');
	LDW(R6);STW(R3);
	label('.4');
	LDW(R3);STW(R8);
	LDW(R5);STW(R9);
	CALL(R4);
	_BLT('.6');
	LDW(R7);XORW(R6);XORW(R3);STW(R3);
	STW(R8);
	LDW(R5);STW(R9);
	CALL(R4);
	_BGE('.8');
	LDW(R5);STW(R3);
	label('.8');
	label('.6');
	LDW(R3);
	label('.3');
	_EPILOGUE(16,4,0xf8,saveAC=True);
# ======== ('CODE', 'qsort', code1)
def code1():
	label('qsort');
	_PROLOGUE(44,8,0xff); # save=R0-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R11);STW(R4);
	label('.11');
	_SP(-2+44);STW(R23);
	LDI(0);DOKE(R23);
	LDW(R6);_CMPIU(7);_BGE('.12');
	_SP(-8+44);STW(R23);
	LDW(R5);ADDW(R7);DOKE(R23);
	_BRA('.17');
	label('.14');
	_SP(-8+44);DEEK();STW(R3);
	_BRA('.21');
	label('.18');
	LDW(R3);STW(R8);
	SUBW(R5);STW(R9);
	LDW(R5);STW(R10);
	CALLI('_memswp');
	label('.19');
	LDW(R3);SUBW(R5);STW(R3);
	label('.21');
	LDW(R3);_CMPWU(R7);_BLE('.22');
	LDW(R3);SUBW(R5);STW(R8);
	LDW(R3);STW(R9);
	CALL(R4);
	_BGT('.18');
	label('.22');
	label('.15');
	_SP(-8+44);STW(R23);
	DEEK();ADDW(R5);DOKE(R23);
	label('.17');
	LDW(R6);_MUL(R5);ADDW(R7);STW(R23);
	_SP(-8+44);DEEK();_CMPWU(R23);_BLT('.14');
	_BRA('.10');
	label('.12');
	_SP(-8+44);STW(R23);
	LDW(R6);_SHRIU(1);_MUL(R5);ADDW(R7);DOKE(R23);
	LDW(R6);_CMPIU(7);_BLE('.23');
	LDW(R7);STW(R3);
	_SP(-12+44);STW(R23);
	LDW(R6);SUBI(1);_MUL(R5);ADDW(R7);DOKE(R23);
	LDW(R6);_CMPIU(40);_BLE('.25');
	_SP(-14+44);STW(R23);
	LDW(R6);_SHRIU(3);_MUL(R5);DOKE(R23);
	LDW(R3);STW(R8);
	_SP(-14+44);DEEK();STW(R23);
	ADDW(R3);STW(R9);
	LDW(R23);LSLW();ADDW(R3);STW(R10);
	LDW(R4);STW(R11);
	CALLI('med3');
	STW(R3);
	_SP(-8+44);DEEK();STW(R23);
	_SP(-14+44);DEEK();STW(R22);
	LDW(R23);SUBW(R22);STW(R8);
	LDW(R23);STW(R9);
	LDW(R22);ADDW(R23);STW(R10);
	LDW(R4);STW(R11);
	CALLI('med3');STW(R23);
	_SP(-8+44);STW(R22);
	LDW(R23);DOKE(R22);
	_SP(-12+44);DEEK();STW(R23);
	_SP(-14+44);DEEK();STW(R22);
	LSLW();STW(R21);
	LDW(R23);SUBW(R21);STW(R8);
	LDW(R23);SUBW(R22);STW(R9);
	LDW(R23);STW(R10);
	LDW(R4);STW(R11);
	CALLI('med3');STW(R23);
	_SP(-12+44);STW(R22);
	LDW(R23);DOKE(R22);
	label('.25');
	LDW(R3);STW(R8);
	_SP(-8+44);DEEK();STW(R9);
	_SP(-12+44);DEEK();STW(R10);
	LDW(R4);STW(R11);
	CALLI('med3');STW(R23);
	_SP(-8+44);STW(R22);
	LDW(R23);DOKE(R22);
	label('.23');
	LDW(R7);STW(R8);
	_SP(-8+44);DEEK();STW(R9);
	LDW(R5);STW(R10);
	CALLI('_memswp');
	LDW(R5);ADDW(R7);STW(R23);
	STW(R2);
	_SP(-4+44);STW(R22);
	LDW(R23);DOKE(R22);
	LDW(R6);SUBI(1);_MUL(R5);ADDW(R7);STW(R23);
	_SP(-6+44);STW(R22);
	LDW(R23);DOKE(R22);
	STW(R1);
	_BRA('.32');
	label('.31');
	LDW(R0);_BNE('.34');
	_SP(-2+44);STW(R23);
	LDI(1);DOKE(R23);
	_SP(-4+44);DEEK();STW(R8);
	LDW(R2);STW(R9);
	LDW(R5);STW(R10);
	CALLI('_memswp');
	_SP(-4+44);STW(R23);
	DEEK();ADDW(R5);DOKE(R23);
	label('.34');
	LDW(R5);ADDW(R2);STW(R2);
	label('.32');
	LDW(R2);_CMPWU(R1);_BGT('.36');
	LDW(R2);STW(R8);
	LDW(R7);STW(R9);
	CALL(R4);
	STW(R0);
	_BLE('.31');
	label('.36');
	_BRA('.38');
	label('.37');
	LDW(R0);_BNE('.40');
	_SP(-2+44);STW(R23);
	LDI(1);DOKE(R23);
	LDW(R1);STW(R8);
	_SP(-6+44);DEEK();STW(R9);
	LDW(R5);STW(R10);
	CALLI('_memswp');
	_SP(-6+44);STW(R23);
	DEEK();SUBW(R5);DOKE(R23);
	label('.40');
	LDW(R1);SUBW(R5);STW(R1);
	label('.38');
	LDW(R2);_CMPWU(R1);_BGT('.42');
	LDW(R1);STW(R8);
	LDW(R7);STW(R9);
	CALL(R4);
	STW(R0);
	_BGE('.37');
	label('.42');
	LDW(R2);_CMPWU(R1);_BLE('.43');
	_BRA('.29');
	label('.43');
	LDW(R2);STW(R8);
	LDW(R1);STW(R9);
	LDW(R5);STW(R10);
	CALLI('_memswp');
	_SP(-2+44);STW(R23);
	LDI(1);DOKE(R23);
	LDW(R5);ADDW(R2);STW(R2);
	LDW(R1);SUBW(R5);STW(R1);
	_BRA('.32');
	label('.29');
	_SP(-2+44);DEEK();_BNE('.45');
	_SP(-8+44);STW(R23);
	LDW(R5);ADDW(R7);DOKE(R23);
	_BRA('.50');
	label('.47');
	_SP(-8+44);DEEK();STW(R3);
	_BRA('.54');
	label('.51');
	LDW(R3);STW(R8);
	SUBW(R5);STW(R9);
	LDW(R5);STW(R10);
	CALLI('_memswp');
	label('.52');
	LDW(R3);SUBW(R5);STW(R3);
	label('.54');
	LDW(R3);_CMPWU(R7);_BLE('.55');
	LDW(R3);SUBW(R5);STW(R8);
	LDW(R3);STW(R9);
	CALL(R4);
	_BGT('.51');
	label('.55');
	label('.48');
	_SP(-8+44);STW(R23);
	DEEK();ADDW(R5);DOKE(R23);
	label('.50');
	LDW(R6);_MUL(R5);ADDW(R7);STW(R23);
	_SP(-8+44);DEEK();_CMPWU(R23);_BLT('.47');
	_BRA('.10');
	label('.45');
	_SP(-12+44);STW(R23);
	LDW(R6);_MUL(R5);ADDW(R7);DOKE(R23);
	_SP(-4+44);DEEK();STW(R23);
	LDW(R2);SUBW(R23);STW(R22);
	LDW(R23);SUBW(R7);_CMPWS(R22);_BGE('.57');
	_SP(-16+44);STW(R23);
	_SP(-4+44);DEEK();SUBW(R7);DOKE(R23);
	_BRA('.58');
	label('.57');
	_SP(-16+44);STW(R23);
	_SP(-4+44);DEEK();STW(R22);
	LDW(R2);SUBW(R22);DOKE(R23);
	label('.58');
	_SP(-10+44);STW(R23);
	_SP(-16+44);DEEK();DOKE(R23);
	LDW(R7);STW(R8);
	_SP(-10+44);DEEK();STW(R23);
	LDW(R2);SUBW(R23);STW(R9);
	LDW(R23);STW(R10);
	CALLI('_memswp');
	_SP(-6+44);DEEK();STW(R23);
	_SP(-12+44);DEEK();SUBW(R23);SUBW(R5);STW(R22);
	LDW(R23);SUBW(R1);_CMPWS(R22);_BGE('.60');
	_SP(-18+44);STW(R23);
	_SP(-6+44);DEEK();SUBW(R1);DOKE(R23);
	_BRA('.61');
	label('.60');
	_SP(-18+44);STW(R23);
	_SP(-6+44);DEEK();STW(R22);
	_SP(-12+44);DEEK();SUBW(R22);SUBW(R5);DOKE(R23);
	label('.61');
	_SP(-10+44);STW(R23);
	_SP(-18+44);DEEK();DOKE(R23);
	LDW(R2);STW(R8);
	_SP(-10+44);DEEK();STW(R23);
	_SP(-12+44);DEEK();SUBW(R23);STW(R9);
	LDW(R23);STW(R10);
	CALLI('_memswp');
	_SP(-4+44);DEEK();STW(R23);
	LDW(R2);SUBW(R23);STW(R23);
	_SP(-10+44);STW(R22);
	LDW(R23);DOKE(R22);
	_CMPWU(R5);_BLE('.62');
	LDW(R7);STW(R8);
	_SP(-10+44);DEEK();_DIVU(R5);STW(R9);
	LDW(R5);STW(R10);
	LDW(R4);STW(R11);
	CALLI('qsort');
	label('.62');
	_SP(-6+44);DEEK();SUBW(R1);STW(R23);
	_SP(-10+44);STW(R22);
	LDW(R23);DOKE(R22);
	_CMPWU(R5);_BLE('.64');
	_SP(-10+44);DEEK();STW(R23);
	_SP(-12+44);DEEK();SUBW(R23);STW(R7);
	LDW(R23);_DIVU(R5);STW(R6);
	_BRA('.11');
	label('.64');
	label('.10');
	_EPILOGUE(44,8,0xff);
# ======== (epilog)
code=[
	('CODE', 'med3', code0),
	('EXPORT', 'qsort'),
	('CODE', 'qsort', code1),
	('IMPORT', '_memswp') ]
module(code=code, name='../gigatron/libc/qsort.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'srand', code0)
def code0():
	label('srand');
	_PROLOGUE(4,0,0x80); # save=R7
	LDW(R8);STW(R7);
	_BEQ('.10');
	LDWI('init');STW(R23);
	LDI(1);POKE(R23);
	LDW(R7);_STLU(LAC);_MOVL(LAC,'seed');
	CALLI('rand');
	CALLI('rand');
	_BRA('.11');
	label('.10');
	LDWI('init');STW(R23);
	LDI(0);POKE(R23);
	label('.11');
	label('.9');
	_EPILOGUE(4,0,0x80);
# ======== ('CODE', '_srand', code1)
def code1():
	label('_srand');
	_PROLOGUE(4,0,0x0); # save=None
	CALLI('SYS_Random');
	_STLU(LAC);_MOVL(LAC,'seed');
	label('.12');
	_EPILOGUE(4,0,0x0);
# ======== ('CODE', 'rand', code2)
def code2():
	label('rand');
	_PROLOGUE(4,0,0x0); # save=None
	LDWI('init');PEEK();_BNE('.14');
	CALLI('_srand');
	label('.14');
	_MOVL('.16',LAC);LDWI('seed');_LMUL();LDWI('.17');_LADD();_MOVL(LAC,'seed');
	LDWI(32767);STW(R23);
	LDWI(v('seed')+2);DEEK();ANDW(R23);
	label('.13');
	_EPILOGUE(4,0,0x0,saveAC=True);
# ======== ('BSS', 'seed', code3, 4, 4)
def code3():
	align(4);
	label('seed');
	space(4);
# ======== ('BSS', 'init', code4, 1, 1)
def code4():
	label('init');
	space(1);
# ======== ('DATA', '.17', code5, 0, 4)
def code5():
	align(4);
	label('.17');
	words(62303,15470); # 1013904223
# ======== ('DATA', '.16', code6, 0, 4)
def code6():
	align(4);
	label('.16');
	words(51557,41279); # 2705312101
# ======== (epilog)
code=[
	('EXPORT', 'srand'),
	('CODE', 'srand', code0),
	('EXPORT', '_srand'),
	('CODE', '_srand', code1),
	('EXPORT', 'rand'),
	('CODE', 'rand', code2),
	('BSS', 'seed', code3, 4, 4),
	('BSS', 'init', code4, 1, 1),
	('IMPORT', 'SYS_Random'),
	('DATA', '.17', code5, 0, 4),
	('DATA', '.16', code6, 0, 4) ]
module(code=code, name='../gigatron/libc/rand.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'realloc', code0)
def code0():
	label('realloc');
	_PROLOGUE(16,6,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDI(0);STW(R4);
	LDW(R7);_BEQ('.4');
	SUBI(-v(-8));STW(R8);
	CALLI('__chk_block_header');
	SUBI(8);
	STW(R4);
	_BGE('.4');
	LDI(0);
	_BRA('.3');
	label('.4');
	LDW(R6);STW(R8);
	CALLI('malloc');
	STW(R5);
	_BNE('.6');
	LDI(0);
	_BRA('.3');
	label('.6');
	LDW(R4);_CMPWU(R6);_BGE('.8');
	LDW(R4);STW(R6);
	label('.8');
	LDW(R6);_BEQ('.10');
	LDW(R5);STW(R8);
	LDW(R7);STW(R9);
	LDW(R6);STW(R10);
	CALLI('memcpy');
	label('.10');
	LDW(R7);STW(R8);
	CALLI('free');
	LDW(R5);
	label('.3');
	_EPILOGUE(16,6,0xf0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'realloc'),
	('CODE', 'realloc', code0),
	('IMPORT', '__chk_block_header'),
	('IMPORT', 'memcpy'),
	('IMPORT', 'malloc'),
	('IMPORT', 'free') ]
module(code=code, name='../gigatron/libc/realloc.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'remove', code0)
def code0():
	label('remove');
	PUSH();
	LDWI('errno');STW(R23);
	LDI(10);DOKE(R23);
	LDWI(-1);
	label('.5');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'remove'),
	('CODE', 'remove', code0),
	('IMPORT', 'errno') ]
module(code=code, name='../gigatron/libc/remove.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'rename', code0)
def code0():
	label('rename');
	PUSH();
	LDWI('errno');STW(R23);
	LDI(10);DOKE(R23);
	LDWI(-1);
	label('.5');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'rename'),
	('CODE', 'rename', code0),
	('IMPORT', 'errno') ]
module(code=code, name='../gigatron/libc/rename.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'setbuf', code0)
def code0():
	label('setbuf');
	_PROLOGUE(16,8,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	_BEQ('.7');
	LDI(64);STW(R5);
	_BRA('.8');
	label('.7');
	LDI(128);STW(R5);
	label('.8');
	LDW(R5);STW(R10);
	LDWI(512);STW(R11);
	CALLI('setvbuf');
	label('.5');
	_EPILOGUE(16,8,0xe0);
# ======== ('CODE', 'setvbuf', code1)
def code1():
	label('setvbuf');
	PUSH();
	LDW(R8);PEEK();ANDI(47);
	STW(R19);
	_BEQ('.10');
	LDW(R10);XORI(128);_BEQ('.13');
	LDW(R10);XORI(64);_BEQ('.13');
	LDW(R10);XORI(192);_BNE('.10');
	label('.13');
	LDW(R19);ORW(R10);POKE(R8);
	LDI(0);
	_BRA('.9');
	label('.10');
	LDWI('errno');STW(R23);
	LDI(3);DOKE(R23);
	LDWI(-1);
	label('.9');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'setbuf'),
	('CODE', 'setbuf', code0),
	('EXPORT', 'setvbuf'),
	('CODE', 'setvbuf', code1),
	('IMPORT', 'errno') ]
module(code=code, name='../gigatron/libc/setbuf.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'signal', code0)
def code0():
	label('signal');
	PUSH();
	LDWI(0xfff8);ANDW(R8);_BNE('.12');
	LDWI(0xffff);XORW(R9);_BNE('.10');
	label('.12');
	LDWI(0xffff);
	_BRA('.9');
	label('.10');
	LDWI('sigvec');ADDW(R8);ADDW(R8);STW(R23);
	DEEK();STW(R19);
	LDW(R9);DOKE(R23);
	LDWI('_raise_disposition');STW(R23);
	LDWI('_raise_emits_signal');DOKE(R23);
	LDW(R19);
	label('.9');
	tryhop(2);POP();RET()
# ======== ('CODE', '_sigcall', code1)
def code1():
	label('_sigcall');
	_PROLOGUE(16,4,0xf8); # save=R3-7
	LDW(R8);ST(R7);
	LDW(R9);ST(R6);
	LDW(R10);STW(R5);
	LDWI('sigvec');STW(R4);
	LD(R7);ANDI(7);ST(R7);
	LD(R7);LSLW();ADDW(R4);DEEK();STW(R3);
	XORI(1);_BNE('.14');
	LD(R7);ANDI(4);_BEQ('.14');
	LDI(0);
	_BRA('.13');
	label('.14');
	LDWI(0xfffe);ANDW(R3);_BEQ('.16');
	LD(R7);LSLW();ADDW(R4);STW(R23);
	LDI(0);DOKE(R23);
	LD(R7);ANDI(4);_BEQ('.18');
	LD(R7);STW(R8);
	LD(R6);STW(R9);
	CALL(R3);
	
	_BRA('.13');
	label('.18');
	LD(R7);STW(R8);
	LD(R6);STW(R9);
	CALL(R3);
	label('.16');
	LDI(20);STW(R8);
	LDW(R5);STW(R9);
	CALLI('_exitm');
	LDWI(-1);
	label('.13');
	_EPILOGUE(16,4,0xf8,saveAC=True);
# ======== ('BSS', 'sigvec', code2, 16, 2)
def code2():
	align(2);
	label('sigvec');
	space(16);
# ======== (epilog)
code=[
	('EXPORT', 'signal'),
	('CODE', 'signal', code0),
	('EXPORT', '_sigcall'),
	('CODE', '_sigcall', code1),
	('BSS', 'sigvec', code2, 16, 2),
	('IMPORT', '_raise_emits_signal'),
	('IMPORT', '_raise_disposition'),
	('IMPORT', '_exitm') ]
module(code=code, name='../gigatron/libc/signal.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', 'sincof', code0, 0, 1)
def code0():
	label('sincof');
	bytes(96,46,199,232,255); # 1.58962e-10
	bytes(103,215,47,45,73); # -2.50507e-08
	bytes(110,56,239,26,180); # 2.75573e-06
	bytes(116,208,13,0,206); # -0.000198413
	bytes(122,8,136,136,137); # 0.00833333
	bytes(126,170,170,170,171); # -0.166667
# ======== ('DATA', 'coscof', code1, 30, 1)
def code1():
	label('coscof');
	bytes(92,199,210,77,4); # -1.13585e-11
	bytes(100,15,116,235,218); # 2.08757e-09
	bytes(107,147,242,123,245); # -2.75573e-07
	bytes(113,80,13,0,206); # 2.48016e-05
	bytes(119,182,11,96,182); # -0.00138889
	bytes(124,42,170,170,171); # 0.0416667
# ======== ('CODE', 'k_sin_over_x', code2)
def code2():
	label('k_sin_over_x');
	_PROLOGUE(20,12,0xe0); # save=R5-7
	_MOVF(F8,F5);
	_MOVF(F5,FAC);LDI(F5);_FMUL();_MOVF(FAC,F5);
	_MOVF(F5,F8);
	LDWI('sincof');STW(R11);
	LDI(5);STW(R12);
	CALLI('_polevl');
	LDI(F5);_FMUL();LDWI('_fone');_FADD();
	label('.3');
	_EPILOGUE(20,12,0xe0);
# ======== ('CODE', 'k_cos', code3)
def code3():
	label('k_cos');
	_PROLOGUE(20,12,0xe0); # save=R5-7
	_MOVF(F8,F5);
	_MOVF(F5,FAC);LDI(F5);_FMUL();_MOVF(FAC,F5);
	_MOVF(F5,F8);
	LDWI('coscof');STW(R11);
	LDI(5);STW(R12);
	CALLI('_polevl');
	LDI(F5);_FMUL();LDI(F5);_FMUL();_MOVF(FAC,F21);
	_MOVF(F5,FAC);LDWI('_fhalf');_FMUL();LDWI('_fone');_FSUBR();LDI(F21);_FADD();
	label('.4');
	_EPILOGUE(20,12,0xe0);
# ======== ('CODE', 'sin_e', code4)
def code4():
	label('sin_e');
	_PROLOGUE(28,14,0xf8); # save=R3-7
	_MOVF(F8,F5);
	LDW(R11);STW(R4);
	_MOVF(F5,F8);
	_MOVF('_pi_over_4',F11);
	_SP(-2+28);STW(R14);
	CALLI('_fmodquo');
	_MOVF(FAC,F5);
	_MOVF(F5,FAC);LDWI('_fzero');_FCMP();_BGE('.6');
	_SP(-2+28);DEEK();STW(R23);
	LDW(R4);SUBW(R23);SUBI(1);STW(R3);
	LDWI('_pi_over_4');_FADD();_MOVF(FAC,F5);
	_BRA('.7');
	label('.6');
	_SP(-2+28);DEEK();ADDW(R4);STW(R3);
	label('.7');
	LDW(R3);ANDI(1);_BEQ('.8');
	_MOVF(F5,FAC);LDWI('_pi_over_4');_FSUBR();_MOVF(FAC,F5);
	label('.8');
	LDI(1);ADDW(R3);ANDI(2);_BEQ('.10');
	_MOVF(F5,F8);
	CALLI('k_cos');
	_MOVF(FAC,F5);
	_BRA('.11');
	label('.10');
	_MOVF(F5,F8);
	CALLI('k_sin_over_x');
	LDI(F5);_FMUL();_MOVF(FAC,F5);
	label('.11');
	LDW(R3);ANDI(4);_BEQ('.12');
	_MOVF(F5,FAC);_FNEG();_MOVF(FAC,F5);
	label('.12');
	_MOVF(F5,FAC);
	label('.5');
	_EPILOGUE(28,14,0xf8);
# ======== ('CODE', 'sin', code5)
def code5():
	label('sin');
	_PROLOGUE(16,8,0xe0); # save=R5-7
	_MOVF(F8,F5);
	_MOVF(F5,F8);
	LDI(0);STW(R11);
	CALLI('sin_e');
	
	label('.14');
	_EPILOGUE(16,8,0xe0);
# ======== ('CODE', 'cos', code6)
def code6():
	label('cos');
	_PROLOGUE(16,8,0xe0); # save=R5-7
	_MOVF(F8,F5);
	_MOVF(F5,F8);
	LDI(2);STW(R11);
	CALLI('sin_e');
	
	label('.15');
	_EPILOGUE(16,8,0xe0);
# ======== ('CODE', 'tan', code7)
def code7():
	label('tan');
	_PROLOGUE(20,6,0xe0); # save=R5-7
	_MOVF(F8,F5);
	_MOVF(F5,F8);
	CALLI('sin');_MOVF(FAC,F21);
	STW(T0);_MOVF(F21,[SP,-5+20]);LDW(T0) #genspill
	_MOVF(F5,F8);
	CALLI('cos');_MOVF(FAC,F18);
	_MOVF([SP,-5+20],FAC);LDI(F18);_FDIV();
	label('.16');
	_EPILOGUE(20,6,0xe0);
# ======== (epilog)
code=[
	('DATA', 'sincof', code0, 0, 1),
	('DATA', 'coscof', code1, 30, 1),
	('CODE', 'k_sin_over_x', code2),
	('CODE', 'k_cos', code3),
	('CODE', 'sin_e', code4),
	('EXPORT', 'sin'),
	('CODE', 'sin', code5),
	('EXPORT', 'cos'),
	('CODE', 'cos', code6),
	('EXPORT', 'tan'),
	('CODE', 'tan', code7),
	('IMPORT', '_polevl'),
	('IMPORT', '_fmodquo'),
	('IMPORT', '_fhalf'),
	('IMPORT', '_fone'),
	('IMPORT', '_fzero'),
	('IMPORT', '_pi_over_4') ]
module(code=code, name='../gigatron/libc/sin.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', 'ln2', code0, 5, 1)
def code0():
	label('ln2');
	bytes(128,49,114,23,248); # 0.693147
# ======== ('CODE', 'sinh', code1)
def code1():
	label('sinh');
	_PROLOGUE(24,10,0xe0); # save=R5-7
	_MOVF(F8,F5);
	_MOVF('_fone',F8);
	_MOVF(F5,F11);
	CALLI('copysign');
	_MOVF(FAC,[SP,-5+24]);
	_MOVF(F5,F8);
	CALLI('fabs');
	_MOVF(FAC,F5);
	_MOVF(F5,FAC);LDWI('.6');_FCMP();_BGE('.4');
	_MOVF(F5,F8);
	CALLI('exp');
	_MOVF(FAC,F5);
	_MOVF(F5,FAC);LDWI('_fone');_FDIVR();LDI(F5);_FSUBR();_MOVF(FAC,F8);
	LDWI(-1);STW(R11);
	CALLI('ldexp');
	_MOVF(FAC,F5);
	_BRA('.5');
	label('.4');
	_MOVF(F5,FAC);LDWI('ln2');_FSUB();_MOVF(FAC,F8);
	CALLI('exp');
	_MOVF(FAC,F5);
	label('.5');
	_MOVF(F5,F8);
	_MOVF([SP,-5+24],F11);
	CALLI('copysign');
	
	label('.3');
	_EPILOGUE(24,10,0xe0);
# ======== ('CODE', 'cosh', code2)
def code2():
	label('cosh');
	_PROLOGUE(16,8,0xe0); # save=R5-7
	_MOVF(F8,F5);
	_MOVF(F5,F8);
	CALLI('fabs');
	_MOVF(FAC,F5);
	_MOVF(F5,FAC);LDWI('.6');_FCMP();_BGE('.8');
	_MOVF(F5,F8);
	CALLI('exp');
	_MOVF(FAC,F5);
	_MOVF(F5,FAC);LDWI('_fone');_FDIVR();LDI(F5);_FADD();_MOVF(FAC,F8);
	LDWI(-1);STW(R11);
	CALLI('ldexp');
	_MOVF(FAC,F5);
	_BRA('.9');
	label('.8');
	_MOVF(F5,FAC);LDWI('ln2');_FSUB();_MOVF(FAC,F8);
	CALLI('exp');
	_MOVF(FAC,F5);
	label('.9');
	_MOVF(F5,FAC);
	label('.7');
	_EPILOGUE(16,8,0xe0);
# ======== ('CODE', 'tanh', code3)
def code3():
	label('tanh');
	_PROLOGUE(24,10,0xe0); # save=R5-7
	_MOVF(F8,F5);
	_MOVF('_fone',F8);
	_MOVF(F5,F11);
	CALLI('copysign');
	_MOVF(FAC,[SP,-5+24]);
	_MOVF(F5,F8);
	CALLI('fabs');
	_MOVF(FAC,F5);
	_MOVF(F5,FAC);LDWI('.6');_FCMP();_BGE('.11');
	_MOVF(F5,F8);
	LDI(1);STW(R11);
	CALLI('ldexp');
	_FNEG();_MOVF(FAC,F8);
	CALLI('exp');
	_MOVF(FAC,F5);
	_MOVF('_fone',F21);
	_MOVF(F21,FAC);LDI(F5);_FADD();_MOVF(FAC,F18);
	_MOVF(F21,FAC);LDI(F5);_FSUB();LDI(F18);_FDIV();_MOVF(FAC,F5);
	_BRA('.12');
	label('.11');
	_MOVF('_fone',F5);
	label('.12');
	_MOVF(F5,F8);
	_MOVF([SP,-5+24],F11);
	CALLI('copysign');
	
	label('.10');
	_EPILOGUE(24,10,0xe0);
# ======== ('DATA', '.6', code4, 0, 1)
def code4():
	label('.6');
	bytes(133,0,0,0,0); # 16
# ======== (epilog)
code=[
	('DATA', 'ln2', code0, 5, 1),
	('EXPORT', 'sinh'),
	('CODE', 'sinh', code1),
	('EXPORT', 'cosh'),
	('CODE', 'cosh', code2),
	('EXPORT', 'tanh'),
	('CODE', 'tanh', code3),
	('IMPORT', '_fone'),
	('IMPORT', 'copysign'),
	('IMPORT', 'fabs'),
	('IMPORT', 'ldexp'),
	('IMPORT', 'exp'),
	('DATA', '.6', code4, 0, 1) ]
module(code=code, name='../gigatron/libc/sinh.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'sqrt', code0)
def code0():
	label('sqrt');
	_PROLOGUE(28,10,0xfe); # save=R1-7
	_MOVF(F8,F5);
	_MOVF(F5,FAC);LDWI('_fzero');_FCMP();_BGT('.4');
	LDWI('_fzero');_FCMP();_BNE('.6');
	_MOVF('_fzero',FAC);
	_BRA('.3');
	label('.6');
	LDWI('errno');STW(R23);
	LDI(1);DOKE(R23);
	_MOVF('_fminus',F8);
	CALLI('_fexception');
	
	_BRA('.3');
	label('.4');
	_MOVF(F5,F8);
	_SP(-2+28);STW(R11);
	CALLI('frexp');
	_MOVF(FAC,F2);
	_MOVF(F2,FAC);LDWI('.8');_FMUL();LDWI('.9');_FADD();_MOVF(FAC,F2);
	_SP(-2+28);DEEK();ANDI(1);_BEQ('.10');
	LDWI('.12');_FMUL();_MOVF(FAC,F2);
	label('.10');
	_MOVF(F2,F8);
	_SP(-2+28);DEEK();_SHRIS(1);STW(R11);
	CALLI('ldexp');
	_MOVF(FAC,F2);
	LDI(3);STW(R1);
	label('.13');
	_MOVF(F5,FAC);LDI(F2);_FDIV();LDI(F2);_FADD();LDWI('_fhalf');_FMUL();_MOVF(FAC,F2);
	label('.14');
	LDW(R1);SUBI(1);STW(R1);
	_BNE('.13');
	_MOVF(F2,FAC);
	label('.3');
	_EPILOGUE(28,10,0xfe);
# ======== ('DATA', '.12', code1, 0, 1)
def code1():
	label('.12');
	bytes(129,53,4,243,52); # 1.41421
# ======== ('DATA', '.9', code2, 0, 1)
def code2():
	label('.9');
	bytes(127,85,169,87,122); # 0.417308
# ======== ('DATA', '.8', code3, 0, 1)
def code3():
	label('.8');
	bytes(128,23,20,220,121); # 0.590162
# ======== (epilog)
code=[
	('EXPORT', 'sqrt'),
	('CODE', 'sqrt', code0),
	('IMPORT', '_fexception'),
	('IMPORT', '_fminus'),
	('IMPORT', '_fhalf'),
	('IMPORT', '_fzero'),
	('IMPORT', 'errno'),
	('IMPORT', 'ldexp'),
	('IMPORT', 'frexp'),
	('DATA', '.12', code1, 0, 1),
	('DATA', '.9', code2, 0, 1),
	('DATA', '.8', code3, 0, 1) ]
module(code=code, name='../gigatron/libc/sqrt.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_sread', code0)
def code0():
	label('_sread');
	PUSH();
	LDI(4);ADDW(R8);STW(R18);
	DEEK();
	_BEQ('.9');
	PEEK();
	STW(R19);
	_BNE('.7');
	label('.9');
	LDI(0);
	_BRA('.6');
	label('.7');
	LDW(R19);POKE(R9);
	LDW(R18);DEEK();ADDI(1);DOKE(R18);
	LDI(1);
	label('.6');
	tryhop(2);POP();RET()
# ======== ('DATA', '_sscanf_iovec', code1, 8, 2)
def code1():
	align(2);
	label('_sscanf_iovec');
	words(0);
	words('_sread');
	space(4);
# ======== ('CODE', 'sscanf', code2)
def code2():
	label('sscanf');
	_PROLOGUE(20,6,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	_SP(2+20);STW(R23);
	LDW(R9);DOKE(R23);
	_SP(-6+20);STW(R6);
	LDI(129);POKE(R6);
	LDI(2);ADDW(R6);STW(R23);
	LDWI('_sscanf_iovec');DOKE(R23);
	LDI(4);ADDW(R6);STW(R23);
	LDW(R7);DOKE(R23);
	_SP(4+20);STW(R5);
	LDW(R6);STW(R8);
	_SP(2+20);DEEK();STW(R9);
	LDW(R5);STW(R10);
	CALLI('_doscan');
	
	label('.10');
	_EPILOGUE(20,6,0xe0,saveAC=True);
# ======== (epilog)
code=[
	('CODE', '_sread', code0),
	('DATA', '_sscanf_iovec', code1, 8, 2),
	('EXPORT', 'sscanf'),
	('CODE', 'sscanf', code2),
	('IMPORT', '_doscan') ]
module(code=code, name='../gigatron/libc/sscanf.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'strcat', code0)
def code0():
	label('strcat');
	_PROLOGUE(16,8,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);STW(R8);
	LDI(0);STW(R9);
	LDWI(0xffff);STW(R10);
	CALLI('__memchr2');
	STW(R5);
	STW(R8);
	LDW(R6);STW(R9);
	CALLI('strcpy');
	LDW(R7);
	label('.3');
	_EPILOGUE(16,8,0xe0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'strcat'),
	('CODE', 'strcat', code0),
	('IMPORT', '__memchr2'),
	('IMPORT', 'strcpy') ]
module(code=code, name='../gigatron/libc/strcat.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'strchr', code0)
def code0():
	label('strchr');
	_PROLOGUE(16,8,0xc0); # save=R6-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);STW(R8);
	LD(R6);STW(R9);
	LDWI(0xffff);STW(R10);
	CALLI('__memchr2');STW(R23);
	_SP(-2+16);STW(R22);
	LDW(R23);DOKE(R22);
	_BEQ('.4');
	_SP(-2+16);DEEK();PEEK();_BEQ('.4');
	_SP(-2+16);DEEK();
	_BRA('.3');
	label('.4');
	LDI(0);
	label('.3');
	_EPILOGUE(16,8,0xc0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'strchr'),
	('CODE', 'strchr', code0),
	('IMPORT', '__memchr2') ]
module(code=code, name='../gigatron/libc/strchr.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'strcmp', code0)
def code0():
	label('strcmp');
	PUSH();
	_BRA('.3');
	label('.2');
	LDI(1);ADDW(R8);STW(R8);
	LDI(1);ADDW(R9);STW(R9);
	label('.3');
	LDW(R9);PEEK();STW(R18);
	LDW(R8);PEEK();SUBW(R18);STW(R19);
	_BNE('.5');
	LDW(R18);_BNE('.2');
	label('.5');
	LDW(R19);
	label('.1');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'strcmp'),
	('CODE', 'strcmp', code0) ]
module(code=code, name='../gigatron/libc/strcmp.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'strcpy', code0)
def code0():
	label('strcpy');
	_PROLOGUE(16,8,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	STW(R8);
	LDI(0);STW(R9);
	LDWI(0xffff);STW(R10);
	CALLI('__memchr2');
	STW(R5);
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	LDW(R5);SUBW(R6);ADDI(1);STW(R10);
	CALLI('memcpy');
	LDW(R7);
	label('.3');
	_EPILOGUE(16,8,0xe0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'strcpy'),
	('CODE', 'strcpy', code0),
	('IMPORT', '__memchr2'),
	('IMPORT', 'memcpy') ]
module(code=code, name='../gigatron/libc/strcpy.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', 'sys_errlist', code0, 0, 2)
def code0():
	align(2);
	label('sys_errlist');
	words('.1');
	words('.2');
	words('.3');
	words('.4');
	words('.5');
	words('.6');
	words('.7');
	words('.8');
	words('.9');
	words('.10');
	words('.11');
# ======== ('DATA', 'sys_nerr', code1, 2, 2)
def code1():
	align(2);
	label('sys_nerr');
	words(11); # 11
# ======== ('CODE', 'strerror', code2)
def code2():
	label('strerror');
	PUSH();
	LDW(R8);_BLT('.13');
	_CMPIU(11);_BGE('.13');
	LDWI('sys_errlist');ADDW(R8);ADDW(R8);DEEK();
	_BRA('.12');
	label('.13');
	LDWI('sys_errlist');DEEK();
	label('.12');
	tryhop(2);POP();RET()
# ======== ('DATA', '.11', code3, 0, 1)
def code3():
	label('.11');
	bytes(78,111,116,32,115,117,112,112);
	bytes(111,114,116,101,100,0);
# ======== ('DATA', '.10', code4, 0, 1)
def code4():
	label('.10');
	bytes(80,101,114,109,105,115,115,105);
	bytes(111,110,32,100,101,110,105,101);
	bytes(100,0);
# ======== ('DATA', '.9', code5, 0, 1)
def code5():
	label('.9');
	bytes(73,110,112,117,116,47,111,117);
	bytes(116,112,117,116,32,101,114,114);
	bytes(111,114,0);
# ======== ('DATA', '.8', code6, 0, 1)
def code6():
	label('.8');
	bytes(78,111,116,32,101,110,111,117);
	bytes(103,104,32,109,101,109,111,114);
	bytes(121,0);
# ======== ('DATA', '.7', code7, 0, 1)
def code7():
	label('.7');
	bytes(84,111,111,32,109,97,110,121);
	bytes(32,111,112,101,110,32,102,105);
	bytes(108,101,115,0);
# ======== ('DATA', '.6', code8, 0, 1)
def code8():
	label('.6');
	bytes(78,111,116,32,97,32,100,105);
	bytes(114,101,99,116,111,114,121,0);
# ======== ('DATA', '.5', code9, 0, 1)
def code9():
	label('.5');
	bytes(78,111,32,115,117,99,104,32);
	bytes(102,105,108,101,32,111,114,32);
	bytes(100,105,114,101,99,116,111,114);
	bytes(121,0);
# ======== ('DATA', '.4', code10, 0, 1)
def code10():
	label('.4');
	bytes(73,110,118,97,108,105,100,32);
	bytes(97,114,103,117,109,101,110,116);
	bytes(0);
# ======== ('DATA', '.3', code11, 0, 1)
def code11():
	label('.3');
	bytes(82,101,115,117,108,116,32,116);
	bytes(111,111,32,108,97,114,103,101);
	bytes(0);
# ======== ('DATA', '.2', code12, 0, 1)
def code12():
	label('.2');
	bytes(68,111,109,97,105,110,32,101);
	bytes(114,114,111,114,0);
# ======== ('DATA', '.1', code13, 0, 1)
def code13():
	label('.1');
	bytes(85,110,107,110,111,119,110,32);
	bytes(101,114,114,111,114,0);
# ======== (epilog)
code=[
	('EXPORT', 'sys_errlist'),
	('DATA', 'sys_errlist', code0, 0, 2),
	('EXPORT', 'sys_nerr'),
	('DATA', 'sys_nerr', code1, 2, 2),
	('EXPORT', 'strerror'),
	('CODE', 'strerror', code2),
	('DATA', '.11', code3, 0, 1),
	('DATA', '.10', code4, 0, 1),
	('DATA', '.9', code5, 0, 1),
	('DATA', '.8', code6, 0, 1),
	('DATA', '.7', code7, 0, 1),
	('DATA', '.6', code8, 0, 1),
	('DATA', '.5', code9, 0, 1),
	('DATA', '.4', code10, 0, 1),
	('DATA', '.3', code11, 0, 1),
	('DATA', '.2', code12, 0, 1),
	('DATA', '.1', code13, 0, 1) ]
module(code=code, name='../gigatron/libc/strerror.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'strncat', code0)
def code0():
	label('strncat');
	_PROLOGUE(20,8,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R7);STW(R8);
	LDI(0);STW(R9);
	LDWI(0xffff);STW(R10);
	CALLI('__memchr2');
	STW(R4);
	LDW(R6);STW(R8);
	CALLI('strlen');
	STW(R3);
	_CMPWU(R5);_BLE('.4');
	LDW(R5);STW(R3);
	label('.4');
	LDW(R4);STW(R8);
	LDW(R6);STW(R9);
	LDW(R3);STW(R10);
	CALLI('memcpy');
	LDW(R3);ADDW(R4);STW(R23);
	LDI(0);POKE(R23);
	LDW(R7);
	label('.3');
	_EPILOGUE(20,8,0xf8,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'strncat'),
	('CODE', 'strncat', code0),
	('IMPORT', '__memchr2'),
	('IMPORT', 'strlen'),
	('IMPORT', 'memcpy') ]
module(code=code, name='../gigatron/libc/strncat.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'strncmp', code0)
def code0():
	label('strncmp');
	PUSH();
	_BRA('.3');
	label('.2');
	LDI(1);ADDW(R8);STW(R8);
	LDI(1);ADDW(R9);STW(R9);
	LDW(R10);SUBI(1);STW(R10);
	label('.3');
	LDW(R10);
	STW(R19);
	_BEQ('.6');
	LDW(R9);PEEK();STW(R18);
	LDW(R8);PEEK();SUBW(R18);STW(R19);
	_BNE('.6');
	LDW(R18);_BNE('.2');
	label('.6');
	LDW(R19);
	label('.1');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'strncmp'),
	('CODE', 'strncmp', code0) ]
module(code=code, name='../gigatron/libc/strncmp.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'strncpy', code0)
def code0():
	label('strncpy');
	_PROLOGUE(16,6,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R6);STW(R8);
	LDI(0);STW(R9);
	LDWI(0xffff);STW(R10);
	CALLI('__memchr2');
	SUBW(R6);STW(R4);
	_CMPWU(R5);_BLE('.4');
	LDW(R5);STW(R4);
	label('.4');
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	LDW(R4);STW(R10);
	CALLI('memcpy');
	LDW(R4);_CMPWU(R5);_BGE('.6');
	LDW(R4);ADDW(R7);STW(R8);
	LDI(0);STW(R9);
	LDW(R5);SUBW(R4);STW(R10);
	CALLI('memset');
	label('.6');
	LDW(R7);
	label('.3');
	_EPILOGUE(16,6,0xf0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'strncpy'),
	('CODE', 'strncpy', code0),
	('IMPORT', '__memchr2'),
	('IMPORT', 'memset'),
	('IMPORT', 'memcpy') ]
module(code=code, name='../gigatron/libc/strncpy.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'strpbrk', code0)
def code0():
	label('strpbrk');
	_PROLOGUE(12,6,0xc0); # save=R6-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	CALLI('strcspn');
	ADDW(R7);STW(R7);
	PEEK();_BEQ('.2');
	LDW(R7);
	_BRA('.1');
	label('.2');
	LDI(0);
	label('.1');
	_EPILOGUE(12,6,0xc0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'strpbrk'),
	('CODE', 'strpbrk', code0),
	('IMPORT', 'strcspn') ]
module(code=code, name='../gigatron/libc/strpbrk.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'strrchr', code0)
def code0():
	label('strrchr');
	_PROLOGUE(16,6,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDI(0);STW(R5);
	LDW(R7);STW(R4);
	_BRA('.5');
	label('.7');
	LDW(R4);STW(R5);
	ADDI(1);STW(R4);
	label('.8');
	LDW(R4);PEEK();
	_BEQ('.10');
	XORW(R6);_BEQ('.7');
	label('.10');
	label('.5');
	LDW(R4);PEEK();_BEQ('.11');
	LDW(R4);STW(R8);
	LD(R6);STW(R9);
	LDWI(0xffff);STW(R10);
	CALLI('__memchr2');
	STW(R4);
	_BNE('.8');
	label('.11');
	LDW(R5);
	label('.3');
	_EPILOGUE(16,6,0xf0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'strrchr'),
	('CODE', 'strrchr', code0),
	('IMPORT', '__memchr2') ]
module(code=code, name='../gigatron/libc/strrchr.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('DATA', '_mask', code0, 8, 1)
def code0():
	label('_mask');
	bytes(1,2);
	bytes(4,8);
	bytes(16,32);
	bytes(64,128);
# ======== ('CODE', '_spnset', code1)
def code1():
	label('_spnset');
	_PROLOGUE(12,4,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);STW(R8);
	LDI(32);STW(R9);
	CALLI('_bitset_clear');
	_BRA('.5');
	label('.4');
	LDW(R7);STW(R8);
	LDW(R5);STW(R9);
	CALLI('_bitset_set');
	LDI(1);ADDW(R6);STW(R6);
	label('.5');
	LDW(R6);PEEK();
	STW(R5);
	_BNE('.4');
	label('.3');
	_EPILOGUE(12,4,0xe0);
# ======== ('CODE', 'strspn', code2)
def code2():
	label('strspn');
	_PROLOGUE(48,6,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);STW(R4);
	_SP(-32+48);STW(R8);
	LDW(R6);STW(R9);
	CALLI('_spnset');
	_BRA('.9');
	label('.8');
	LDI(1);ADDW(R7);STW(R7);
	label('.9');
	LDW(R7);PEEK();
	STW(R5);
	_BEQ('.11');
	_SP(-32+48);STW(R8);
	LDW(R5);STW(R9);
	CALLI('_bitset_test');
	_BNE('.8');
	label('.11');
	LDW(R7);SUBW(R4);
	label('.7');
	_EPILOGUE(48,6,0xf0,saveAC=True);
# ======== ('CODE', 'strcspn', code3)
def code3():
	label('strcspn');
	_PROLOGUE(48,6,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);STW(R4);
	_SP(-32+48);STW(R8);
	LDW(R6);STW(R9);
	CALLI('_spnset');
	_BRA('.14');
	label('.13');
	LDI(1);ADDW(R7);STW(R7);
	label('.14');
	LDW(R7);PEEK();
	STW(R5);
	_BEQ('.16');
	_SP(-32+48);STW(R8);
	LDW(R5);STW(R9);
	CALLI('_bitset_test');
	_BEQ('.13');
	label('.16');
	LDW(R7);SUBW(R4);
	label('.12');
	_EPILOGUE(48,6,0xf0,saveAC=True);
# ======== (epilog)
code=[
	('DATA', '_mask', code0, 8, 1),
	('EXPORT', '_spnset'),
	('CODE', '_spnset', code1),
	('EXPORT', 'strspn'),
	('CODE', 'strspn', code2),
	('EXPORT', 'strcspn'),
	('CODE', 'strcspn', code3),
	('IMPORT', '_bitset_test'),
	('IMPORT', '_bitset_set'),
	('IMPORT', '_bitset_clear') ]
module(code=code, name='../gigatron/libc/strspn.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'strstr', code0)
def code0():
	label('strstr');
	_PROLOGUE(16,6,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	STW(R8);
	CALLI('strlen');
	STW(R5);
	LDW(R6);PEEK();STW(R4);
	_BNE('.7');
	LDW(R7);
	_BRA('.1');
	label('.4');
	LDW(R7);PEEK();XORW(R4);_BNE('.8');
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	LDW(R5);STW(R10);
	CALLI('strncmp');
	_BNE('.8');
	LDW(R7);
	_BRA('.1');
	label('.8');
	label('.5');
	LDI(1);ADDW(R7);STW(R7);
	label('.7');
	LDW(R7);PEEK();_BNE('.4');
	LDI(0);
	label('.1');
	_EPILOGUE(16,6,0xf0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'strstr'),
	('CODE', 'strstr', code0),
	('IMPORT', 'strlen'),
	('IMPORT', 'strncmp') ]
module(code=code, name='../gigatron/libc/strstr.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_strtod_push', code0)
def code0():
	label('_strtod_push');
	PUSH();
	LDW(R8);DEEK();STW(R19);
	_BNE('.6');
	LDI(1);STW(R19);
	LDW(R9);XORI(45);_BNE('.8');
	LDW(R19);ORI(64);STW(R19);
	_BRA('.10');
	label('.8');
	LDW(R9);XORI(43);_BNE('.11');
	_BRA('.10');
	label('.11');
	label('.6');
	LDW(R19);ANDI(3);XORI(1);_BNE('.13');
	LDW(R9);XORI(46);_BNE('.15');
	LDW(R19);ANDI(32);_BEQ('.17');
	_BRA('.19');
	label('.17');
	LDW(R19);ORI(32);STW(R19);
	_BRA('.10');
	label('.15');
	LDW(R9);SUBI(48);_BLT('.20');
	LDW(R9);SUBI(57);_BGT('.20');
	LDI(6);ADDW(R8);_MOVF([vAC],F16);
	LDW(R19);ORI(16);STW(R19);
	_MOVF(F16,FAC);LDWI('.24');_FCMP();_BGE('.22');
	LDW(R19);ANDI(32);_BEQ('.25');
	LDI(2);ADDW(R8);STW(R23);
	DEEK();SUBI(1);DOKE(R23);
	label('.25');
	LDW(R9);SUBI(48);_STLS(LAC);_FCVI();_MOVF(FAC,F21);
	_MOVF(F16,FAC);LDWI('_ften');_FMUL();LDI(F21);_FADD();LDI(6);ADDW(R8);_MOVF(FAC,[vAC]);
	_BRA('.10');
	label('.22');
	LDW(R19);ANDI(32);_BNE('.10');
	LDI(2);ADDW(R8);STW(R23);
	DEEK();ADDI(1);DOKE(R23);
	_BRA('.10');
	label('.20');
	LDW(R9);ORI(32);XORI(101);_BNE('.29');
	LDW(R19);XORI(3);STW(R19);
	LDW(R10);_BEQ('.10');
	LDI(1);ADDW(R10);PEEK();STW(R9);
	XORI(43);_BEQ('.35');
	LDW(R9);XORI(45);_BNE('.33');
	label('.35');
	LDI(2);ADDW(R10);PEEK();STW(R9);
	label('.33');
	LDW(R9);SUBI(48);_BLT('.38');
	LDW(R9);SUBI(57);_BLE('.10');
	label('.38');
	_BRA('.19');
	label('.29');
	label('.13');
	LDW(R19);ANDI(3);XORI(2);_BNE('.39');
	LDW(R19);XORI(1);STW(R19);
	LDW(R9);XORI(45);_BNE('.41');
	LDW(R19);ORI(8);STW(R19);
	_BRA('.10');
	label('.41');
	LDW(R9);XORI(43);_BNE('.43');
	_BRA('.10');
	label('.43');
	label('.39');
	LDW(R19);ANDI(3);XORI(3);_BNE('.45');
	LDW(R9);SUBI(48);_BLT('.47');
	LDW(R9);SUBI(57);_BGT('.47');
	LDI(4);ADDW(R8);DEEK();STW(R18);
	SUBI(250);_BGE('.10');
	LDI(4);ADDW(R8);STW(R23);
	LDW(R18);LSLW();LSLW();ADDW(R18);LSLW();ADDW(R9);SUBI(48);DOKE(R23);
	_BRA('.10');
	label('.47');
	label('.45');
	label('.19');
	LDI(0);
	_BRA('.5');
	label('.10');
	LDW(R19);DOKE(R8);
	
	label('.5');
	tryhop(2);POP();RET()
# ======== ('CODE', '_strtod_decode', code1)
def code1():
	label('_strtod_decode');
	_PROLOGUE(24,6,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	_SP(-5+24);STW(T2);LDI(6);ADDW(R7);_MOVF([vAC],[T2]);
	LDI(2);ADDW(R7);DEEK();STW(R5);
	LDW(R7);DEEK();STW(R4);
	_SP(-8+24);STW(R23);
	LDWI('_raise_disposition');DEEK();DOKE(R23);
	LDW(R4);ANDI(16);_BNE('.52');
	LDI(0);
	_BRA('.51');
	label('.52');
	LDW(R4);ANDI(8);_BEQ('.54');
	LDI(4);ADDW(R7);DEEK();STW(R23);
	LDW(R5);SUBW(R23);STW(R5);
	_BRA('.55');
	label('.54');
	LDI(4);ADDW(R7);DEEK();ADDW(R5);STW(R5);
	label('.55');
	LDWI('_raise_code');STW(R23);
	LDI(0);DOKE(R23);
	LDWI('_raise_disposition');STW(R23);
	LDWI('_raise_sets_code');DOKE(R23);
	_SP(-5+24);STW(R8);
	LDW(R5);STW(R9);
	CALLI('_ldexp10p');
	_MOVF(FAC,[SP,-5+24]);
	LDWI('_raise_code');DEEK();_BEQ('.56');
	_MOVF('.58',[SP,-5+24]);
	LDWI('errno');STW(R23);
	LDI(2);DOKE(R23);
	label('.56');
	LDWI('_raise_disposition');STW(R23);
	_SP(-8+24);DEEK();DOKE(R23);
	LDW(R4);ANDI(64);_BEQ('.59');
	_MOVF([SP,-5+24],FAC);_FNEG();_MOVF(FAC,[SP,-5+24]);
	label('.59');
	LDW(R6);_BEQ('.61');
	STW(T2);_MOVF([SP,-5+24],[T2]);
	label('.61');
	LDI(1);
	label('.51');
	_EPILOGUE(24,6,0xf0,saveAC=True);
# ======== ('CODE', 'strtod', code2)
def code2():
	label('strtod');
	_PROLOGUE(36,8,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	_MOVF('_fzero',[SP,-5+36]);
	_SP(-18+36);STW(R5);
	LDW(R7);STW(R4);
	LDW(R5);STW(R8);
	LDI(0);STW(R9);
	LDI(12);STW(R10);
	CALLI('memset');
	_BRA('.65');
	label('.64');
	LDI(1);ADDW(R4);STW(R4);
	label('.65');
	LDW(R4);PEEK();STW(R8);
	CALLI('isspace');
	_BNE('.64');
	_BRA('.68');
	label('.67');
	LDI(1);ADDW(R4);STW(R4);
	label('.68');
	LDW(R5);STW(R8);
	LDW(R4);PEEK();STW(R9);
	LDI(1);ADDW(R4);STW(R10);
	CALLI('_strtod_push');
	_BNE('.67');
	LDW(R5);STW(R8);
	_SP(-5+36);STW(R9);
	CALLI('_strtod_decode');
	_BNE('.70');
	LDW(R7);STW(R4);
	label('.70');
	LDW(R6);_BEQ('.72');
	LDW(R4);DOKE(R6);
	label('.72');
	_MOVF([SP,-5+36],FAC);
	label('.63');
	_EPILOGUE(36,8,0xf0);
# ======== ('CODE', 'atof', code3)
def code3():
	label('atof');
	_PROLOGUE(8,4,0x80); # save=R7
	LDW(R8);STW(R7);
	STW(R8);
	LDI(0);STW(R9);
	CALLI('strtod');
	
	label('.74');
	_EPILOGUE(8,4,0x80);
# ======== ('DATA', '.58', code4, 0, 1)
def code4():
	label('.58');
	bytes(255,127,255,255,255); # 1.70141e+38
# ======== ('DATA', '.24', code5, 0, 1)
def code5():
	label('.24');
	bytes(182,14,27,201,191); # 1e+16
# ======== (epilog)
code=[
	('EXPORT', '_strtod_push'),
	('CODE', '_strtod_push', code0),
	('EXPORT', '_strtod_decode'),
	('CODE', '_strtod_decode', code1),
	('EXPORT', 'strtod'),
	('CODE', 'strtod', code2),
	('EXPORT', 'atof'),
	('CODE', 'atof', code3),
	('IMPORT', '_ldexp10p'),
	('IMPORT', '_ften'),
	('IMPORT', '_fzero'),
	('IMPORT', '_raise_code'),
	('IMPORT', '_raise_sets_code'),
	('IMPORT', '_raise_disposition'),
	('IMPORT', 'memset'),
	('IMPORT', 'errno'),
	('IMPORT', 'isspace'),
	('DATA', '.58', code4, 0, 1),
	('DATA', '.24', code5, 0, 1) ]
module(code=code, name='../gigatron/libc/strtod.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_strtok', code0)
def code0():
	label('_strtok');
	_PROLOGUE(16,4,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R7);_BEQ('.2');
	DOKE(R5);
	label('.2');
	LDW(R5);DEEK();STW(R3);
	STW(R8);
	LDW(R6);STW(R9);
	CALLI('strspn');
	ADDW(R3);STW(R4);
	PEEK();_BNE('.4');
	LDI(0);
	_BRA('.1');
	label('.4');
	LDW(R4);STW(R8);
	LDW(R6);STW(R9);
	CALLI('strcspn');
	ADDW(R4);STW(R3);
	PEEK();_BEQ('.6');
	LDW(R3);STW(R23);
	ADDI(1);STW(R3);
	LDI(0);POKE(R23);
	label('.6');
	LDW(R3);DOKE(R5);
	LDW(R4);
	label('.1');
	_EPILOGUE(16,4,0xf8,saveAC=True);
# ======== ('DATA', '.9', code1, 2, 2)
def code1():
	align(2);
	label('.9');
	words(0);
# ======== ('CODE', 'strtok', code2)
def code2():
	label('strtok');
	_PROLOGUE(12,6,0xc0); # save=R6-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	LDWI('.9');STW(R10);
	CALLI('_strtok');
	
	label('.8');
	_EPILOGUE(12,6,0xc0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', '_strtok'),
	('CODE', '_strtok', code0),
	('DATA', '.9', code1, 2, 2),
	('EXPORT', 'strtok'),
	('CODE', 'strtok', code2),
	('IMPORT', 'strspn'),
	('IMPORT', 'strcspn') ]
module(code=code, name='../gigatron/libc/strtok.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_strtol_push', code0)
def code0():
	label('_strtol_push');
	PUSH();
	LDI(0);STW(R19);
	LDI(2);ADDW(R8);DEEK();STW(R18);
	LDW(R8);DEEK();STW(R17);
	_BNE('.6');
	LDW(R9);XORI(45);_BNE('.8');
	LDI(1);STW(R17);
	_BRA('.10');
	label('.8');
	LDW(R9);XORI(43);_BNE('.11');
	LDI(2);STW(R17);
	_BRA('.10');
	label('.11');
	label('.6');
	LDW(R18);_BNE('.13');
	LDW(R17);ANDI(4);_BEQ('.15');
	LDW(R9);ORI(32);XORI(120);_BNE('.17');
	LDI(2);ADDW(R8);STW(R23);
	LDI(16);DOKE(R23);
	STW(R18);
	_BRA('.10');
	label('.17');
	LDW(R17);ORI(8);STW(R17);
	LDI(2);ADDW(R8);STW(R23);
	LDI(8);DOKE(R23);
	STW(R18);
	_BRA('.16');
	label('.15');
	LDW(R9);XORI(48);_BNE('.19');
	LDW(R17);ORI(4);STW(R17);
	_BRA('.10');
	label('.19');
	LDI(2);ADDW(R8);STW(R23);
	LDI(10);DOKE(R23);
	STW(R18);
	label('.16');
	label('.13');
	LDW(R9);SUBI(48);
	STW(R19);
	_CMPIS(9);_BLE('.21');
	LDW(R9);ORI(32);SUBI(97);
	STW(R19);
	_BLT('.23');
	LDI(10);ADDW(R19);STW(R19);
	label('.23');
	label('.21');
	LDW(R19);_BLT('.27');
	SUBW(R18);_BLT('.25');
	label('.27');
	LDI(0);
	_BRA('.5');
	label('.25');
	LDW(R17);ORI(8);STW(R17);
	LDI(4);ADDW(R8);STW(R16);
	LDI(3);ADDW(R16);STW(R15);
	PEEK();STW(R14);
	LDI(0);POKE(R15);
	LDW(R19);_STLU(L22);
	LDW(R18);_STLU(LAC);LDW(R16);_LMUL();LDI(L22);_LADD();LDW(R16);_MOVL(LAC,[vAC]);
	LDW(R15);PEEK();STW(R23);
	LDW(R14);_MUL(R18);ADDW(R23);STW(R14);
	POKE(R15);
	LD(R14);XORW(R14);_BEQ('.28');
	LDW(R17);ORI(128);STW(R17);
	LDW(R16);STW(T2);_MOVL('.30',[T2]);
	label('.28');
	label('.10');
	LDW(R17);DOKE(R8);
	
	label('.5');
	tryhop(2);POP();RET()
# ======== ('CODE', '_strtol_decode_u', code1)
def code1():
	label('_strtol_decode_u');
	PUSH();
	LDW(R8);DEEK();ANDI(8);_BNE('.32');
	LDI(0);
	_BRA('.31');
	label('.32');
	LDW(R8);DEEK();ANDI(128);_BEQ('.34');
	LDWI('errno');STW(R23);
	LDI(2);DOKE(R23);
	_BRA('.35');
	label('.34');
	LDW(R8);DEEK();ANDI(1);_BEQ('.36');
	LDI(4);ADDW(R8);STW(R23);
	_MOVL([vAC],LAC);_LNEG();LDW(R23);_MOVL(LAC,[vAC]);
	label('.36');
	label('.35');
	LDW(R9);_BEQ('.38');
	STW(T2);LDI(4);ADDW(R8);_MOVL([vAC],[T2]);
	label('.38');
	LDI(1);
	label('.31');
	tryhop(2);POP();RET()
# ======== ('DATA', '.41', code2, 4, 4)
def code2():
	align(4);
	label('.41');
	words(0,32768); # 2147483648
# ======== ('DATA', '.42', code3, 4, 4)
def code3():
	align(4);
	label('.42');
	words(65535,32767); # 2147483647
# ======== ('CODE', '_strtol_decode_s', code4)
def code4():
	label('_strtol_decode_s');
	PUSH();
	LDWI('.42');STW(R19);
	LDI(4);ADDW(R8);STW(R18);
	LDW(R8);DEEK();ANDI(8);_BNE('.43');
	LDI(0);
	_BRA('.40');
	label('.43');
	LDW(R8);DEEK();ANDI(1);_BEQ('.45');
	LDWI('.41');STW(R19);
	label('.45');
	LDW(R8);DEEK();ANDI(128);_BNE('.49');
	LDW(R18);_MOVL([vAC],LAC);LDW(R19);_LCMPU();_BLE('.47');
	label('.49');
	LDWI('errno');STW(R23);
	LDI(2);DOKE(R23);
	LDW(R18);STW(T2);LDW(R19);_MOVL([vAC],[T2]);
	_BRA('.48');
	label('.47');
	LDW(R8);DEEK();ANDI(1);_BEQ('.50');
	LDW(R18);_MOVL([vAC],LAC);_LNEG();LDW(R18);_MOVL(LAC,[vAC]);
	label('.50');
	label('.48');
	LDW(R9);_BEQ('.52');
	LDW(R18);_MOVL([vAC],LAC);LDW(R9);_MOVL(LAC,[vAC]);
	label('.52');
	LDI(1);
	label('.40');
	tryhop(2);POP();RET()
# ======== ('CODE', 'worker', code5)
def code5():
	label('worker');
	_PROLOGUE(12,4,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	_MOVL('_lzero',LAC);LDI(4);ADDW(R7);_MOVL(LAC,[vAC]);
	LDI(0);DOKE(R7);
	LDI(2);ADDW(R7);STW(R23);
	LDW(R5);DOKE(R23);
	_BRA('.56');
	label('.55');
	LDI(1);ADDW(R6);STW(R6);
	label('.56');
	LDW(R6);PEEK();STW(R8);
	CALLI('isspace');
	_BNE('.55');
	_BRA('.59');
	label('.58');
	LDI(1);ADDW(R6);STW(R6);
	label('.59');
	LDW(R7);STW(R8);
	LDW(R6);PEEK();STW(R9);
	CALLI('_strtol_push');
	_BNE('.58');
	LDW(R6);
	label('.54');
	_EPILOGUE(12,4,0xe0,saveAC=True);
# ======== ('CODE', 'strtoul', code6)
def code6():
	label('strtoul');
	_PROLOGUE(32,8,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	_SP(-12+32);STW(R4);
	STW(R8);
	LDW(R7);STW(R9);
	LDW(R5);STW(R10);
	CALLI('worker');
	STW(R3);
	_MOVL('_lzero',LAC);_MOVL(LAC,[SP,-4+32]);
	LDW(R4);STW(R8);
	_SP(-4+32);STW(R9);
	CALLI('_strtol_decode_u');
	_BNE('.62');
	LDW(R7);STW(R3);
	label('.62');
	LDW(R6);_BEQ('.64');
	LDW(R3);DOKE(R6);
	label('.64');
	_MOVL([SP,-4+32],LAC);
	label('.61');
	_EPILOGUE(32,8,0xf8);
# ======== ('CODE', 'strtol', code7)
def code7():
	label('strtol');
	_PROLOGUE(32,8,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	_SP(-12+32);STW(R4);
	STW(R8);
	LDW(R7);STW(R9);
	LDW(R5);STW(R10);
	CALLI('worker');
	STW(R3);
	_MOVL('.67',[SP,-4+32]);
	LDW(R4);STW(R8);
	_SP(-4+32);STW(R9);
	CALLI('_strtol_decode_s');
	_BNE('.68');
	LDW(R7);STW(R3);
	label('.68');
	LDW(R6);_BEQ('.70');
	LDW(R3);DOKE(R6);
	label('.70');
	_SP(-4+32);_MOVL([vAC],LAC);
	label('.66');
	_EPILOGUE(32,8,0xf8);
# ======== ('DATA', '.67', code8, 0, 4)
def code8():
	align(4);
	label('.67');
	words(0,0); # 0
# ======== ('DATA', '.30', code9, 0, 4)
def code9():
	align(4);
	label('.30');
	words(65535,65535); # 4294967295
# ======== (epilog)
code=[
	('EXPORT', '_strtol_push'),
	('CODE', '_strtol_push', code0),
	('EXPORT', '_strtol_decode_u'),
	('CODE', '_strtol_decode_u', code1),
	('DATA', '.41', code2, 4, 4),
	('DATA', '.42', code3, 4, 4),
	('EXPORT', '_strtol_decode_s'),
	('CODE', '_strtol_decode_s', code4),
	('CODE', 'worker', code5),
	('EXPORT', 'strtoul'),
	('CODE', 'strtoul', code6),
	('EXPORT', 'strtol'),
	('CODE', 'strtol', code7),
	('IMPORT', '_lzero'),
	('IMPORT', 'errno'),
	('IMPORT', 'isspace'),
	('DATA', '.67', code8, 0, 4),
	('DATA', '.30', code9, 0, 4) ]
module(code=code, name='../gigatron/libc/strtol.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'system', code0)
def code0():
	label('system');
	PUSH();
	LDWI('errno');STW(R23);
	LDI(10);DOKE(R23);
	LDWI(-1);
	label('.3');
	tryhop(2);POP();RET()
# ======== ('COMMON', 'errno', code1, 2, 2)
def code1():
	align(2);
	label('errno');
	space(2);
# ======== (epilog)
code=[
	('EXPORT', 'system'),
	('CODE', 'system', code0),
	('COMMON', 'errno', code1, 2, 2) ]
module(code=code, name='../gigatron/libc/system.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'time', code0)
def code0():
	label('time');
	_PROLOGUE(8,0,0x0); # save=None
	_MOVL('.4',[SP,-4+8]);
	LDW(R8);_BEQ('.5');
	STW(T2);_MOVL([SP,-4+8],[T2]);
	label('.5');
	_SP(-4+8);_MOVL([vAC],LAC);
	label('.3');
	_EPILOGUE(8,0,0x0);
# ======== ('DATA', '.4', code1, 0, 4)
def code1():
	align(4);
	label('.4');
	words(0,0); # 0
# ======== (epilog)
code=[
	('EXPORT', 'time'),
	('CODE', 'time', code0),
	('DATA', '.4', code1, 0, 4) ]
module(code=code, name='../gigatron/libc/time.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'tmpfile', code0)
def code0():
	label('tmpfile');
	PUSH();
	LDWI('errno');STW(R23);
	LDI(10);DOKE(R23);
	LDI(0);
	label('.5');
	tryhop(2);POP();RET()
# ======== ('CODE', 'tmpnam', code1)
def code1():
	label('tmpnam');
	PUSH();
	LDWI('errno');STW(R23);
	LDI(10);DOKE(R23);
	LDI(0);
	label('.6');
	tryhop(2);POP();RET()
# ======== (epilog)
code=[
	('EXPORT', 'tmpfile'),
	('CODE', 'tmpfile', code0),
	('EXPORT', 'tmpnam'),
	('CODE', 'tmpnam', code1),
	('IMPORT', 'errno') ]
module(code=code, name='../gigatron/libc/tmpfile.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'ungetc', code0)
def code0():
	label('ungetc');
	_PROLOGUE(12,4,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	STW(R8);
	CALLI('_schkread');
	_BEQ('.6');
	LDW(R7);_BLT('.6');
	LDW(R6);PEEK();
	STW(R5);
	ANDI(16);_BNE('.8');
	LDW(R5);ORI(16);ANDI(247);POKE(R6);
	LDW(R7);ST(R23);
	LDI(1);ADDW(R6);STW(R22);
	LDW(R23);POKE(R22);
	LD(R23);
	_BRA('.5');
	label('.8');
	label('.6');
	LDWI(-1);
	label('.5');
	_EPILOGUE(12,4,0xe0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'ungetc'),
	('CODE', 'ungetc', code0),
	('IMPORT', '_schkread') ]
module(code=code, name='../gigatron/libc/ungetc.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'vcprintf', code0)
def code0():
	label('vcprintf');
	_PROLOGUE(20,4,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R0);STW(R5);
	_SP(-6+20);STW(R0);
	_SP(-2+20);STW(R23);
	LDWI('console_writall');DOKE(R23);
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	CALLI('_doprint');
	STW(R4);
	LDW(R5);STW(R0);
	LDW(R4);
	label('.11');
	_EPILOGUE(20,4,0xf0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'vcprintf'),
	('CODE', 'vcprintf', code0),
	('IMPORT', '_doprint'),
	('IMPORT', 'console_writall') ]
module(code=code, name='../gigatron/libc/vcprintf.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'vfprintf', code0)
def code0():
	label('vfprintf');
	_PROLOGUE(24,6,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R0);STW(R4);
	LDWI(-1);STW(R3);
	_SP(-6+24);STW(R0);
	_SP(-4+24);STW(R23);
	LDW(R7);DOKE(R23);
	STW(R8);
	CALLI('_schkwrite');STW(R23);
	_SP(-2+24);STW(R22);
	LDW(R23);DOKE(R22);
	_BEQ('.7');
	LDW(R6);STW(R8);
	LDW(R5);STW(R9);
	CALLI('_doprint');
	STW(R3);
	LDW(R7);PEEK();ANDI(4);_BEQ('.10');
	LDWI(-1);STW(R3);
	label('.10');
	label('.7');
	LDW(R4);STW(R0);
	LDW(R3);
	label('.5');
	_EPILOGUE(24,6,0xf8,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'vfprintf'),
	('CODE', 'vfprintf', code0),
	('IMPORT', '_doprint'),
	('IMPORT', '_schkwrite') ]
module(code=code, name='../gigatron/libc/vfprintf.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', 'vprintf', code0)
def code0():
	label('vprintf');
	_PROLOGUE(20,4,0xf0); # save=R4-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R0);STW(R5);
	LDWI(-1);STW(R4);
	_SP(-6+20);STW(R0);
	_SP(-4+20);STW(R23);
	LDWI('_iob1');DOKE(R23);
	STW(R8);
	CALLI('_schkwrite');STW(R23);
	_SP(-2+20);STW(R22);
	LDW(R23);DOKE(R22);
	_BEQ('.7');
	LDW(R7);STW(R8);
	LDW(R6);STW(R9);
	CALLI('_doprint');
	STW(R4);
	label('.7');
	LDW(R5);STW(R0);
	LDW(R4);
	label('.5');
	_EPILOGUE(20,4,0xf0,saveAC=True);
# ======== (epilog)
code=[
	('EXPORT', 'vprintf'),
	('CODE', 'vprintf', code0),
	('IMPORT', '_doprint'),
	('IMPORT', '_schkwrite'),
	('IMPORT', '_iob1') ]
module(code=code, name='../gigatron/libc/vprintf.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_sprintf_writall', code0)
def code0():
	label('_sprintf_writall');
	_PROLOGUE(20,8,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDI(2);ADDW(R0);STW(R5);
	DEEK();
	STW(R4);
	_BEQ('.6');
	LDI(2);ADDW(R5);DEEK();SUBW(R4);STW(R3);
	_CMPWU(R6);_BLE('.8');
	LDW(R6);STW(R3);
	label('.8');
	LDW(R4);STW(R8);
	LDW(R7);STW(R9);
	LDW(R3);STW(R10);
	CALLI('memcpy');
	LDW(R5);DEEK();ADDW(R3);DOKE(R5);
	LDW(R5);DEEK();STW(R23);
	LDI(0);POKE(R23);
	label('.6');
	LDW(R6);
	label('.5');
	_EPILOGUE(20,8,0xf8,saveAC=True);
# ======== ('CODE', 'vsnprintf', code1)
def code1():
	label('vsnprintf');
	_PROLOGUE(28,6,0xfc); # save=R2-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R11);STW(R4);
	LDW(R0);STW(R3);
	_SP(-8+28);STW(R0);
	LDW(R6);_BNE('.11');
	LDI(0);STW(R7);
	label('.11');
	_SP(-4+28);STW(R23);
	LDWI('_sprintf_writall');DOKE(R23);
	_SP(-6+28);STW(R23);
	LDW(R7);DOKE(R23);
	_SP(-2+28);STW(R23);
	LDW(R6);ADDW(R7);SUBI(-v(-1));DOKE(R23);
	LDW(R5);STW(R8);
	LDW(R4);STW(R9);
	CALLI('_doprint');
	STW(R2);
	LDW(R3);STW(R0);
	LDW(R2);
	label('.10');
	_EPILOGUE(28,6,0xfc,saveAC=True);
# ======== (epilog)
code=[
	('CODE', '_sprintf_writall', code0),
	('EXPORT', 'vsnprintf'),
	('CODE', 'vsnprintf', code1),
	('IMPORT', '_doprint'),
	('IMPORT', 'memcpy') ]
module(code=code, name='../gigatron/libc/vsnprintf.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
#VCPUv5

# ======== ('CODE', '_sprintf_writall', code0)
def code0():
	label('_sprintf_writall');
	_PROLOGUE(16,8,0xe0); # save=R5-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDI(2);ADDW(R0);STW(R5);
	DEEK();_BEQ('.6');
	LDW(R5);DEEK();STW(R8);
	LDW(R7);STW(R9);
	LDW(R6);STW(R10);
	CALLI('memcpy');
	LDW(R5);DEEK();ADDW(R6);DOKE(R5);
	LDW(R5);DEEK();STW(R23);
	LDI(0);POKE(R23);
	label('.6');
	LDW(R6);
	label('.5');
	_EPILOGUE(16,8,0xe0,saveAC=True);
# ======== ('CODE', 'vsprintf', code1)
def code1():
	label('vsprintf');
	_PROLOGUE(24,6,0xf8); # save=R3-7
	LDW(R8);STW(R7);
	LDW(R9);STW(R6);
	LDW(R10);STW(R5);
	LDW(R0);STW(R4);
	_SP(-6+24);STW(R0);
	_SP(-2+24);STW(R23);
	LDWI('_sprintf_writall');DOKE(R23);
	_SP(-4+24);STW(R23);
	LDW(R7);DOKE(R23);
	LDW(R6);STW(R8);
	LDW(R5);STW(R9);
	CALLI('_doprint');
	STW(R3);
	LDW(R4);STW(R0);
	LDW(R3);
	label('.8');
	_EPILOGUE(24,6,0xf8,saveAC=True);
# ======== (epilog)
code=[
	('CODE', '_sprintf_writall', code0),
	('EXPORT', 'vsprintf'),
	('CODE', 'vsprintf', code1),
	('IMPORT', '_doprint'),
	('IMPORT', 'memcpy') ]
module(code=code, name='../gigatron/libc/vsprintf.c', cpu=5);

# Local Variables:
# mode: python
# indent-tabs-mode: t
# End:
def scope():

    # The tree rebalancing function is frameless
    # but contains a lot of redundant code that
    # can be compressed in low level calls.
    # Compiling this right would require
    # interprocedural register allocation,
    # something well outside LCC's capabilities.
    #
    # struct avlnode_s {
    #   int height;
    #	avlnode_t *left, *right; }
    #
    #
    # void _avl_rebal(register avlnode_t ***sp)           R8
    # {
    # 	register avlnode_t **pelt, *elt, **r, *rtmp;      R9 R10 R11 R12
    # 	register int lh, rh, tmp;                         R13 R14 R15

    #     #define GETH do { \
    # 		lh = rh = 0;\
    # 		if (elt->left)\
    # 			lh = elt->left->height;\
    # 		if (elt->right)\
    # 			rh = elt->right->height;\
    # 	} while(0)

    def code_geth():
        label('.geth')
        PUSH()
        LDI(0);STW(R13);STW(R14)
        LDI(2);ADDW(R10);DEEK();_BEQ('.geth1')
        DEEK();STW(R13)
        label('.geth1')
        LDI(4);ADDW(R10);DEEK();_BEQ('.geth2')
        DEEK();STW(R14)
        label('.geth2')
        tryhop(2);POP();RET()

    # #define CALC do {\
    # 		GETH;\
    # 		tmp = 0;\
    # 		if (lh > tmp)\
    # 			tmp = lh;\
    # 		if (rh > tmp)\
    # 			tmp = rh;\
    # 		elt->height = tmp + 1;\
    # 	} while(0)

    def code_calc():
        label('.calc')
        PUSH()
        _MOVIW(0,R15);
        _CALLJ('.geth')
        LDW(R13);SUBW(R15);_BLE('.calc1')
        _MOVW(R13,R15)
        label('.calc1')
        LDW(R14);SUBW(R15);_BLE('.calc2')
        _MOVW(R14,R15)
        label('.calc2')
        LDI(1);ADDW(R15);DOKE(R10)
        tryhop(2);POP();RET()

    # #define LROT do {\
    # 		rtmp = (*r)->right;\
    # 		(*r)->right = rtmp->left;\
    # 		rtmp->left = (*r);\
    # 		elt = *r; CALC; \
    # 		elt = rtmp; CALC; \
    # 		*r = rtmp;\
    # 	} while(0)
    # #define RROT do {\
    # 		rtmp = (*r)->left;\
    # 		(*r)->left = rtmp->right;\
    # 		rtmp->right = (*r);\
    # 		elt = *r; CALC; \
    # 		elt = rtmp; CALC; \
    # 		*r = rtmp;\
    # 	} while(0)

    def code_rotate():
        label('.lrot')    # r = pelt; LROT
        PUSH()
        LDW(R9)
        label('.l1')
        STW(R11);DEEK();ADDI(4);STW(R22)
        DEEK();STW(R12);LDI(2)
        _BRA('.end')
        label('.lrotl')   # r = &(*pelt)->left; LROT
        PUSH()
        LDW(R9);DEEK();ADDI(2);_BRA('.l1')
        label('.rrotr')   # r = (*pelt)->right; RROT
        PUSH()
        LDW(R9);DEEK();ADDI(4);_BRA('.r1')
        label('.rrot')    # r = pelt; RROT
        PUSH()
        LDW(R9)
        label('.r1')
        STW(R11);DEEK();ADDI(2);STW(R22)
        DEEK();STW(R12);LDI(4)
        label('.end')
        ADDW(R12);STW(R21);DEEK();DOKE(R22)
        LDW(R11);DEEK();DOKE(R21)
        STW(R10);_CALLJ('.calc')
        _MOVW(R12,R10);_CALLJ('.calc')
        LDW(R12);DOKE(R11)
        tryhop(2);POP();RET()

    def code_rebal():
        label('__avl_rebal')
        PUSH()
        label('.loop')
        # while (pelt = *sp++) {
        # 	if (! (elt = *pelt))
        # 		continue;
        LDW(R8);DEEK();STW(R9)
        LDI(2);ADDW(R8);STW(R8)
        LDW(R9);_BNE('.rebal0')
        tryhop(2);POP();RET()
        label('.rebal0')
        DEEK();STW(R10)
        _BEQ('.loop')
        #	CALC;
        #	if (rh - lh == -2) {
        _CALLJ('.calc')
        LDW(R14);SUBW(R13)
        ADDI(2);_BNE('.rebal2')
        # 		elt = elt->left;
        # 		GETH;
        # 		if (rh - lh > 0)
        # 			{ r = &((*pelt)->left); LROT; }
        # 		r = pelt; RROT;
        LDI(2);ADDW(R10);DEEK();STW(R10)
        _CALLJ('.geth')
        LDW(R14);SUBW(R13);_BLE('.rebal1')
        _CALLJ('.lrotl')
        label('.rebal1')
        _CALLJ('.rrot')
        _BRA('.loop')
        label('.rebal2')
        #	} else if (rh - lh == +2) {
        XORI(4);_BNE('.loop')
        # 		elt = elt->right;
        # 		GETH;
        # 		if (rh - lh < 0)
        # 			{ r = &((*pelt)->right); RROT; }
        # 		r = pelt; LROT;
        LDI(4);ADDW(R10);DEEK();STW(R10)
        _CALLJ('.geth')
        LDW(R14);SUBW(R13);_BGE('.rebal3')
        _CALLJ('.rrotr')
        label('.rebal3')
        _CALLJ('.lrot')
        _BRA('.loop')

    module(name='_avl_bal.s',
           code=[('EXPORT', '__avl_rebal'),
                 ('CODE', '.geth', code_geth),
                 ('CODE', '.calc', code_calc),
                 ('CODE', '.rotate', code_rotate),
                 ('CODE', '__avl_rebal', code_rebal) ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
def scope():

    # -----------------------------------------------
    # Long constants

    def code_lzero():
        label('_lzero')
        bytes(0,0,0,0) # 0L

    module(name='_lzero.s',
           code=[ ('EXPORT', '_lzero'),
                  ('DATA', '_lzero', code_lzero, 4, 2) ] )

    def code_lone():
        label('_lone')
        bytes(1,0,0,0) # 1L

    module(name='_lone.s',
           code=[ ('EXPORT', '_lone'),
                  ('DATA', '_lone', code_lone, 4, 2) ] )

    def code_ltwo():
        label('_ltwo')
        bytes(2,0,0,0) # 2.0F

    module(name='_ltwo.s',
           code=[ ('EXPORT', '_ltwo'),
                  ('DATA', '_ltwo', code_ltwo, 4, 2) ] )

    def code_lminus():
        label('_lminus')
        bytes(255,255,255,255) # -1L

    module(name='_lminus.s',
           code=[ ('EXPORT', '_lminus'),
                  ('DATA', '_lminus', code_lminus, 4, 2) ] )

    # -----------------------------------------------
    # Floating point constants

    def code_fzero():
        label('_fzero')
        bytes(0,0,0,0,0) # 0.0F

    module(name='_fzero.s',
           code=[ ('EXPORT', '_fzero'),
                  ('DATA', '_fzero', code_fzero, 5, 1) ] )

    def code_fone():
        label('_fone')
        bytes(129,0,0,0,0) # 1.0F

    module(name='_fone.s',
           code=[ ('EXPORT', '_fone'),
                  ('DATA', '_fone', code_fone, 5, 1) ] )

    def code_fhalf():
        label('_fhalf')
        bytes(128,0,0,0,0) # 0.5F

    module(name='_fhalf.s',
           code=[ ('EXPORT', '_fhalf'),
                  ('DATA', '_fhalf', code_fhalf, 5, 1) ] )

    def code_ftwo():
        label('_ftwo')
        bytes(130,0,0,0,0) # 2.0F

    module(name='_ftwo.s',
           code=[ ('EXPORT', '_ftwo'),
                  ('DATA', '_ftwo', code_ftwo, 5, 1) ] )

    def code_ften():
        label('_ften')
        bytes(132,32,0,0,0) # 10.0F

    module(name='_ften.s',
           code=[ ('EXPORT', '_ften'),
                  ('DATA', '_ften', code_ften, 5, 1) ] )

    def code_fminus():
        label('_fminus')
        bytes(129,128,0,0,0) # -1.0F

    module(name='_fminus.s',
           code=[ ('EXPORT', '_fminus'),
                  ('DATA', '_fminus', code_fminus, 5, 1) ] )

    def code_fpi():
        label('_pi')
        bytes(130,73,15,218,162); # 0.785398 * 4

    module(name='_fpi.s',
           code=[ ('EXPORT', '_pi'),
                  ('DATA', '_pi', code_fpi, 5, 1) ] )

    def code_fpi2():
        label('_pi_over_2')
        bytes(129,73,15,218,162); # 0.785398 * 2

    module(name='_fpi2.s',
           code=[ ('EXPORT', '_pi_over_2'),
                  ('DATA', '_pi_over_2', code_fpi2, 5, 1) ] )

    def code_fpi4():
        label('_pi_over_4')
        bytes(128,73,15,218,162); # 0.785398
        
    module(name='_fpi4.s',
           code=[ ('EXPORT', '_pi_over_4'),
                  ('DATA', '_pi_over_4', code_fpi4, 5, 1) ] )

    
scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():

    # -- int _doprint(const char*, __va_list);
    # aliased to either _doprint_c89 or _doprint_simple

    doprint_default = '_doprint_c89'
    if 'PRINTF_C89' in args.opts:
        doprint_default = '_doprint_c89'
    elif 'PRINTF_SIMPLE' in args.opts:
        doprint_default = '_doprint_simple'

    def code_doprint():
        label('_doprint', doprint_default)

    module(name='doprint.s',
           code=[('EXPORT','_doprint'),
                 ('IMPORT', doprint_default),
                 ('CODE','_doprint',code_doprint) ] )


    # - void _doprint_puts(const char *s, size_t len)
    def code_doprint_puts():
        nohop()
        label('_doprint_puts')
        PUSH();_ALLOC(-6)
        _DEEKV(R0);ADDW(R9);DOKE(R0)
        if args.cpu >= 6:
            LDI(2);ADDW(R0);DEEKA(R10);ADDI(2);DEEK()
        else:
            LDI(2);ADDW(R0);DEEK();STW(R10);LDI(4);ADDW(R0);DEEK()
        CALL(vAC)
        _ALLOC(6);POP();RET()

    module(name='doprint_puts.s',
           code=[('EXPORT', '_doprint_puts'),
                 ('CODE', '_doprint_puts', code_doprint_puts) ] )


    # - void _doprint_putc(int c, size_t cnt)
    def code_doprint_putc():
        label('_doprint_putc')
        _PROLOGUE(12,6,0xc0)
        _SP(12);STW(R6);LD(R8);DOKE(R6)
        _DEEKV(R0);ADDW(R9);DOKE(R0)
        if args.cpu >= 6:
            LDW(R9);STW(R7);_BEQ('.done')
            label('.loop')
        else:
            LDW(R9);_BRA(".tst")
            label('.loop')
            SUBI(1);STW(R7)
        _MOVW(R6,R8)
        _MOVIW(1,R9)
        if args.cpu >= 6:
            LDI(2);ADDW(R0);DEEKA(R10);ADDI(2);DEEK()
        else:
            LDI(2);ADDW(R0);DEEK();STW(R10);LDI(4);ADDW(R0);DEEK()
        CALL(vAC)
        if args.cpu >= 6:
            DBNE(R7,'.loop')
            label('.done')
        else:
            LDW(R7)
            label('.tst')
            _BNE('.loop')
        _EPILOGUE(12,6,0xc0,saveAC=False)

    module(name='doprint_putc.s',
           code=[('EXPORT', '_doprint_putc'),
                 ('CODE', '_doprint_putc', code_doprint_putc) ] )

scope()


# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():

    def code_ldexp10p():
        label('_ldexp10p')
        # -- double _ldexp10p(double *x, int exp)
        # Function _ldexp10 is assumed
        # to keep the scratch registers intact.
        PUSH()
        LDW(R9);_BLT('.neg')
        SUBI(128);_BGE('.ovf')
        label('.pos0')
        LDW(R8);_MOVF([vAC],FAC)
        LDW(R9);_CALLI('_@_fscald')
        _BRA('.ret')
        label('.ovf')
        LDWI(1000);_BRA('.ret')
        label('.und')
        LDWI(-1000);_BRA('.ret')
        label('.neg')
        ADDI(128);_BLT('.und')
        _MOVF('_fone',FAC)
        LDI(0);SUBW(R9);_CALLI('_@_fscald');STW(R9)
        LDW(R8);_FDIVR();LDI(0);SUBW(R9)
        label('.ret')
        _FSCALB()
        tryhop(2);POP();RET()

    module(name='_ldexp10p',
           code=[ ('EXPORT', '_ldexp10p'),
                  ('IMPORT', '_@_fscald'),
                  ('IMPORT', '_@_fscalb'),
                  ('IMPORT', '_@_clrfac'),
                  ('IMPORT', '_fone'),
                  ('CODE', '_ldexp10p', code_ldexp10p) ] )


    def code_frexp10p():
        # -- int _frexp10p(double *x)
        label('_frexp10p')
        PUSH()
        LDW(R8);STW(R18);PEEK();_BEQ('.r0')
        SUBI(157);STW(R17);LSLW();ADDW(R17);_DIVIS(10);STW(R17)
        LDI(0);SUBW(R17);STW(R9);_CALLJ('_ldexp10p')
        label('.r3')
        LD(FAE);SUBI(157);_BGT('.r1');_BLT('.r2')
        LD(LAC+3);ORI(0x80);SUBI(0xcc);_BGE('.r1')
        label('.r2')
        LDI(1);_CALLI('_@_fscald');_FSCALB();
        LDW(R17);SUBI(1);STW(R17)
        _BRA('.r3')
        label('.r1')
        LDW(R18);_MOVF(FAC,[vAC]);LDW(R17);
        label('.r0')
        tryhop(2);POP();RET();

    module(name='_frexp10p',
           code=[ ('EXPORT', '_frexp10p'),
                  ('IMPORT', '_ldexp10p'),
                  ('IMPORT', '_@_fscald'),
                  ('CODE', '_frexp10p', code_frexp10p) ] )


scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():

    code = []

    if 'has_SYS_ScanMemoryExt' in rominfo:
        info = rominfo['has_SYS_ScanMemoryExt']
        addr = int(str(info['addr']),0)
        cycs = int(str(info['cycs']),0)
        def m_prepScanMemoryExt():
            _MOVIW(addr,'sysFn')
            LD(R8);ST(R17+1) # R17 = R8 << 8
        def m_ScanMemoryExt():
            # scan memory without page crossings
            # takes data ptr in sysArgs0/1
            # takes two byte targets in sysArgs2/3
            # takes length in vACL (0 means 256)
            # returns pointer to target or 0
            ST(R17);LDW(R17);SYS(cycs)
    else:
        def m_prepScanMemoryExt():
            LDWI(0x1f8);PEEK();STW(R16);_BNE('.ok')        # R16: copy of 1f8
            LDI(0);tryhop(2);POP();RET();label('.ok')
            LDW(R8);ORI(0x3c);ANDI(0xfc);STW(R17)          # R17: target ctrl word
            _LDI('SYS_ExpanderControl_v4_40');STW('sysFn')
        def m_ScanMemoryExt():
            STW('sysArgs4');_CALLJ('_memscan0ext')
        def code0():
            # scan memory without page crossings
            # takes data ptr in sysArgs0/1
            # takes two byte targets in sysArgs2/3
            # takes length in sysArgs4 (not vACL)
            # returns pointer to target or 0
            nohop()
            label('_memscan0ext')
            LDW(R17);SYS(40)
            LDI(0);SUBW('sysArgs4');STW('sysArgs4')
            label('.scanloop')
            LDW('sysArgs0');PEEK()
            ST(vACH);XORW('sysArgs2');STW(T3)
            LD(T3);_BEQ('.scanok')
            LD(T3+1);_BEQ('.scanok')
            INC('sysArgs0');INC('sysArgs4')
            LD('sysArgs4');_BNE('.scanloop')
            LDW(R16);SYS(40)
            LDI(0);RET()
            label('.scanok')
            LDW(R16);SYS(40)
            LDW('sysArgs0');RET()

        code.append(('CODE', '_memscan0ext', code0))
        code.append(('PLACE', '_memscan0ext', 0x0200, 0x7fff))


    # void *__memchr2ext(char bank, const void *s, int c0c1, size_t len)
    # - scans at most n bytes from s until finding one equal to c0 or c1
    # - return pointer to the byte if found, 0 if not found.

    def code1():
        label('__memchr2ext');   # R8=bank R9=d, R10=c0c1, R11=len
        PUSH();
        LD(R10);STW('sysArgs2')
        LDW(R9);STW('sysArgs0');ADDW(R11);STW(R12)
        m_prepScanMemoryExt()
        label('.loop')
        LDW(R12);XORW('sysArgs0');_BEQ('.done')
        LD(vACH);_BNE('.s1')
        LDW(R12);SUBW('sysArgs0');_BLT('.s1')
        m_ScanMemoryExt()
        tryhop(2);POP();RET()
        label('.s1')
        LDI(0);SUBW('sysArgs0')
        m_ScanMemoryExt()
        INC('sysArgs1');_BEQ('.loop')
        label('.done')
        tryhop(2);POP();RET()

    code.append(('EXPORT', '__memchr2ext'))
    code.append(('CODE', '__memchr2ext', code1))

    module(name='memchr2ext.s', code=code)

    # void *_memchr2ext(char bank, const void *s, char c0, char c1, size_t len)
    # - scans at most n bytes from s until finding one equal to c0 or c1
    # - return pointer to the byte if found, 0 if not found.
    def code2():
        nohop(9)
        label('_memchr2ext');   # R8=bank R9=d, R10=c0, R11=c1, R12=len
        LD(R11);ST(R10+1);LDW(R12);STW(R11)
        if args.cpu >= 6:
            JNE('__memchr2ext')
        else:
            PUSH();_CALLJ('__memchr2ext');POP()
        RET()

    module(name='_memchr2ext.s',
           code=[('EXPORT', '_memchr2ext'),
                 ('IMPORT', '__memchr2ext'),
                 ('CODE', '_memchr2ext', code2) ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():
    # creates a local variable scope

    code = [ ('EXPORT', '_memcpyext') ]

    if 'has_SYS_CopyMemoryExt' in rominfo:
        
        info = rominfo['has_SYS_CopyMemoryExt']
        addr = int(str(info['addr']),0)
        cycs = int(str(info['cycs']),0)
        def m_prepCopyMemoryExt():
            _MOVIW(addr,'sysFn');
            LDWI(0x1f8);PEEK();_BNE('.ok')
            LDI(0);tryhop(2);POP();RET();label('.ok')
        def m_reduceCopyMemoryExt():
            pass
        def m_CopyMemoryExt():
            # copy without page crossings
            # takes destination ptr in sysArgs0/1
            # takes source ptr in sysArgs2/3
            # takes length in vACL (0 means 256)
            # takes bank in vACH
            SYS(cycs)

    else:

        def m_prepCopyMemoryExt():
            LDWI(0x1f8);PEEK();STW(R16);_BNE('.ok')        # R16: copy of 1f8
            LDI(0);tryhop(2);POP();RET();label('.ok')
            LDW(R8);ORI(0x3c);ANDI(0xfc);STW(R17)          # R17: destination ctrl word
            LDW(R8);LSLW();LSLW();ORI(0x3c);STW(R18)       # R18: source ctrl word
            LDI(0);STW(R8)                                 # R8 = zero
            _LDI('SYS_ExpanderControl_v4_40');STW('sysFn') # prep sys call
        def m_reduceCopyMemoryExt():
            LDI(0xe0);SUBW(R20);_BLE('.memcpy1b')
            LDI(0xe0);STW(R20);label('.memcpy1b')
        def m_CopyMemoryExt():
            STW('sysArgs4');STW('sysArgs5');_CALLJ('_memcpyext0')
        def code0():
            nohop()
            label('.memcpyextb')
            space(32)
            label('_memcpyext0')
            LDWI('.memcpyextb');STW(R19)
            LDW(R18);SYS(40)
            label('.loop1')
            LDW('sysArgs2');PEEK();POKE(R19)
            INC(R19);INC('sysArgs2')
            LD('sysArgs5');SUBI(1);ST('sysArgs5');_BNE('.loop1')
            LDW(R17);SYS(40)
            LDWI('.memcpyextb');STW(R19)
            label('.loop2')
            LDW(R19);PEEK();POKE('sysArgs0')
            INC(R19);INC('sysArgs0')
            LD('sysArgs4');SUBI(1);ST('sysArgs4');_BNE('.loop2')
            LDW(R16);SYS(40)
            RET()

        code.append(('CODE', '_memcpyext0', code0))
        code.append(('PLACE', '_memcpyext0', 0x0200, 0x7fff))


    # void *_memcpyext(int banks, void *dest, const void *src, size_t n);
    def code1():
        label('_memcpyext');                        # R8=banks, R9=d, R10=s, R11=l
        PUSH()
        m_prepCopyMemoryExt()
        LD(R8);ANDI(0xf0);_SHLI(8);STW(R8)
        LDW(R9);STW(R21);STW('sysArgs0')
        LDW(R10);STW('sysArgs2')
        label('.loop')
        LD(R9);STW(R20)
        LD(R10);SUBW(R20);_BLE('.memcpy1')
        LD(R10);STW(R20)
        label('.memcpy1')
        m_reduceCopyMemoryExt()        
        LDI(255);ST(R20+1)                          # R20 is minus count to page boundary
        LDW(R11);_BGT('.memcpy2')
        _BEQ('.done')                               # a) len is zero
        ADDW(R20);_BRA('.memcpy4')                  # b) len is larger than 0x8000
        label('.memcpy2')
        ADDW(R20);_BLE('.memcpy5')                  # c) len is smaller than -R20
        label('.memcpy4')
        STW(R11)                                    # d) len is larger than -R20
        LDI(0);SUBW(R20);STW(R20);ORW(R8);m_CopyMemoryExt()
        LDW(R9);ADDW(R20);STW(R9);STW('sysArgs0')
        LDW(R10);ADDW(R20);STW(R10);STW('sysArgs2')
        _BRA('.loop')
        label('.memcpy5')
        LDW(R11);ORW(R8);m_CopyMemoryExt()
        label('.done')
        LDW(R21)
        tryhop(2);POP();RET();
        
    code.append(('CODE', '_memcpyext', code1))

            
    return code

module(code=scope(), name='memcpy.s');

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():
    
    def code0():
        '''void _memswp(char *R8, char *R9, size_t R10)'''
        nohop()
        label('_memswp')
        _MOVW(R8,T2)
        _MOVW(R9,T3)
        LDW(R10);_BEQ('.ret')
        label('.loop')
        if args.cpu >= 7:
            SUBI(4);_BLT('.loop1');STW(R10)
            LD(T2);SUBI(0xfc);_BGT('.loop1')
            LD(T3);SUBI(0xfc);_BGT('.loop1')
            LDW(T2);LDLAC();LDW(T3);COPYN(4);STLAC()
            LDW(R10);_BNE('.loop')
            RET()
        else:
            SUBI(2);_BLT('.loop1');STW(R10)
            LD(T2);SUBI(0xfe);_BGT('.loop1')
            LD(T3);SUBI(0xfe);_BGT('.loop1')
            _DEEKV(T2);STW(R11);_DEEKV(T3);DOKE(T2);LDW(R11);DOKE(T3)
            LDI(2);ADDW(T2);STW(T2)
            LDI(2);ADDW(T3);STW(T3)
            LDW(R10);_BNE('.loop')
            RET()
        label('.loop1')
        _PEEKV(T2);ST(R11);_PEEKV(T3);POKE(T2);LD(R11);POKE(T3)
        if args.cpu >= 6:
            INCV(T2);INCV(T3)
        else:
            LDI(1);ADDW(T3);STW(T3)
            LDI(1);ADDW(T2);STW(T2)
        LDW(R10);SUBI(1);STW(R10)
        _BNE('.loop')
        label('.ret')
        RET()

    module(name='_memswp.s',
           code=[('EXPORT', '_memswp'),
                 ('CODE', '_memswp', code0) ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():
    
    def code0():
        '''double _polevl(double x, double *coeff, char n)
           -- computes sum_{i=0}^{n} coeff[i]*x^{n-i}
           double _p1evl(double x, double *coeff, char n)
           -- same but coeff of x^n is 1.'''
        nohop()
        label('_p1evl')
        PUSH()
        _MOVF(F8,FAC);LDW(R11);_FADD()
        BRA('.polevl2')
        label('_polevl')
        PUSH()              # x is F8, *coeff is R11, n is R12
        LDW(R11);_MOVF([vAC],FAC)
        INC(R12);BRA('.polevl2')
        label('.polevl1')
        LDI(F8);_FMUL();LDW(R11);_FADD()
        label('.polevl2')
        if args.cpu >= 7:
            ADDSV(5,R11)
        else:
            LDW(R11);ADDI(5);STW(R11)
        if args.cpu >= 6:
            DBNE(R12,'.polevl1')
        else:
            LD(R12);SUBI(1);ST(R12);_BNE('.polevl1')
        tryhop(2);POP();RET()

    module(name='_polevl.s',
           code=[ ('EXPORT', '_polevl'),
                  ('EXPORT', '_p1evl'),
                  ('CODE', '_polevl', code0) ] )
    
scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
def scope():

    def code_printf():
        nohop()
        label('printf')
        _SP(2);STW(R9)
        if args.cpu >= 7:
            JNE('vprintf')
        else:
            PUSH();_CALLJ('vprintf')
            tryhop(2);POP();RET()

    module(name='printf.s',
           code=[('EXPORT', 'printf'),
                 ('IMPORT', 'vprintf'),
                 ('CODE', 'printf', code_printf) ] )


    def code_cprintf():
        nohop()
        label('cprintf')
        _SP(2);STW(R9)
        if args.cpu >= 7:
            JNE('vcprintf')
        else:
            PUSH();_CALLJ('vcprintf')
            tryhop(2);POP();RET()

    module(name='cprintf.s',
           code=[('EXPORT', 'cprintf'),
                 ('IMPORT', 'vcprintf'),
                 ('CODE', 'cprintf', code_cprintf) ] )


    def code_sprintf():
        nohop()
        label('sprintf')
        _SP(4);STW(R10)
        if args.cpu >= 7:
            JNE('vsprintf')
        else:
            PUSH();_CALLJ('vsprintf')
            tryhop(2);POP();RET()

    module(name='sprintf.s',
           code=[('EXPORT', 'sprintf'),
                 ('IMPORT', 'vsprintf'),
                 ('CODE', 'sprintf', code_sprintf) ] )

    def code_snprintf():
        nohop()
        label('snprintf')
        _SP(6);STW(R11)
        if args.cpu >= 7:
            JNE('vsnprintf')
        else:
            PUSH();_CALLJ('vsnprintf')
            tryhop(2);POP();RET()

    module(name='snprintf.s',
           code=[('EXPORT', 'snprintf'),
                 ('IMPORT', 'vnsprintf'),
                 ('CODE', 'snprintf', code_snprintf) ] )

    def code_fprintf():
        nohop()
        label('fprintf')
        _SP(4);STW(R10)
        if args.cpu >= 7:
            JNE('vfprintf')
        else:
            PUSH();_CALLJ('vfprintf')
            tryhop(2);POP();RET()

    module(name='fprintf.s',
           code=[('EXPORT', 'fprintf'),
                 ('IMPORT', 'vfprintf'),
                 ('CODE', 'fprintf', code_fprintf) ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
	

# Call signal subroutine.
# This is only imported when signal() is used.
# Registers R8-R22 must be saved to make sure the signal can return.
# Callee-saved registers R0-R7 need not be saved because
# the signal routine saves them as needed.

def code0():
    '''Redirected from _@_raise with vLR saved in [SP].
       Args: msg in T0, signo in T1, vSP%4 unknown.'''
    nohop()
    label('_raise_emits_signal')
    # align stack so that vSP%4==2, save SP, create stack frame
    LDW(SP);STW(T3);ORI(3);SUBI(5)
    if args.cpu < 6:
        STW(T4)
    else:
        DOKEA(T3)
    SUBI(38);STW(SP);ADDI(6);STW(T2)
    if args.cpu < 6:
        LDW(T3);DOKE(T4)
    LDW(T1);DOKE(SP)
    # create a stack frame and save R8-R23
    if args.cpu >= 6:
        _MOVIW(R8,T3);COPYN(32)
        # call _sigcall(signo,fpeinfo)
        LDW(SP);DEEK();ST(R8);LD(vACH);ST(R9)
        LDW(T0);STW(R10);CALLI('_sigcall');STW(T0)
        # restore R8-R22 and SP
        LDI(R8);STW(T2)
        _SP(6);STW(T3);ADDI(32);STW(SP)
        COPYN(32)
    else:
        LDI(R8);STW(T3);LDI(R8+32);STW(T1);_CALLJ('_@_wcopy')
        # call _sigcall(signo,fpeinfo)
        LDW(SP);DEEK();ST(R8);LD(vACH);ST(R9)
        LDW(T0);STW(R10);_CALLJ('_sigcall');STW(T0)
        # restore R8-R22 and SP
        LDI(R8);STW(T2)
        _SP(6);STW(T3);ADDI(32);STW(T1);STW(SP)
        _CALLJ('_@_wcopy')
    # restore SP
    _DEEKV(SP);STW(SP)
    # return to vLR saved by raise()
    tryhop(4);LDW(T0);POP();RET()

module(name='_sigcall.s',
       code=[ ('IMPORT', '_sigcall'),
              ('IMPORT', '_@_wcopy') if args.cpu < 6 else ('NOP',),
              ('EXPORT', '_raise_emits_signal'),
              ('CODE', '_raise_emits_signal', code0) ] )


# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
	

### The rom/ram checking code must work on all cpu

def code0():
    nohop()
    ### _start()
    label('_start');
    # ensure stack alignment with space for argc and argv
    LDI(3);ORW(SP);SUBI(7);STW(SP)
    # call onload functions
    for f in args.onload:
        _CALLJ(f)
    # initialize bss
    if not args.no_runtime_bss_initialization:
        _CALLJ('_init_bss')
    # call init chain
    _CALLJ('_callchain_init')
    # call main
    LDI(0); STW(R8); STW(R9); _CALLJ('main'); STW(R8)
    ### exit()
    label('exit')
    _MOVW(R8,R0)
    # call fini chain
    if args.cpu < 5:
        _CALLJ('_callchain_fini')
    else:
        LDWI('__glink_magic_fini'); CALLI('_callchain')
    _MOVW(R0,R8)
    ### _exit()
    label('_exit')
    _MOVIW(0,R9)
    label('_exitm');
    _MOVW(R8,R0)
    label('_exitm_msgfunc', pc()+1)
    LDWI(0);_BEQ('.halt')  # _exitm_msgfunc is LDWI's argument here
    CALL(vAC)              # arguments in R8 and R9 are already correct
    # If _exitm_msgfunc is zero or returns
    # we just Flash a pixel with a position indicative of the return code
    label('.halt')
    LDWI(0x100);DEEK();ST(R7+1)
    LD(vACH);ADDW(R0);ST(R7)
    label('.loop')
    POKE(R7);ADDW(0x80)
    BRA('.loop')

def code1():
    # subroutine to call a chain of init/fini functions
    nohop()
    if args.cpu < 5:
        label('_callchain_fini')
        LDWI('__glink_magic_fini'); _BRA('_callchain')
    label('_callchain_init')
    LDWI('__glink_magic_init')
    label('_callchain')
    DEEK(); STW(R7); _MOVW(vLR,R6)
    LDWI(0xBEEF);XORW(R7);_BEQ('.callchaindone')
    LDW(R7);_BRA('.callchaintst')
    label('.callchainloop')
    DEEK();CALL(vAC)
    LDI(2);ADDW(R7);DEEK();STW(R7)
    label('.callchaintst')
    _BNE('.callchainloop')
    label('.callchaindone')
    _MOVW(R6,vLR); RET()

def code2():
    align(2)
    label('__glink_magic_init')
    words(0xBEEF)

def code3():
    align(2)
    label('__glink_magic_fini')
    words(0xBEEF)

    
# ======== (epilog)
code=[
    ('EXPORT', '_start'),
    ('EXPORT', 'exit'),
    ('EXPORT', '_exit'),
    ('EXPORT', '_exitm'),
    ('EXPORT', '_exitm_msgfunc'),
    ('EXPORT', '__glink_magic_init'),
    ('EXPORT', '__glink_magic_fini'),
    ('CODE', '_start', code0),
    ('CODE', '.callchain', code1),
    ('DATA', '__glink_magic_init', code2, 2, 2),
    ('DATA', '__glink_magic_fini', code3, 2, 2),
    ('IMPORT', 'main') ]

if args.gt1exec != args.e:
    code.append(('IMPORT', args.gt1exec))        # causes map start stub to be included
for f in args.onload:
    code.append( ('IMPORT', f) )                 # causes onload funcs to be included
if not args.no_runtime_bss_initialization:
    code.append(('IMPORT', '_init_bss'))         # causes _init1.c to be included

module(code=code, name='_start.s');


# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
	

# this file contains a lot of stuff that has not clear place

def scope():

    # -----------------------------------------------
    # This is loaded to handle division by zero exceptions

    def code0():
        nohop()
        label('_@_raise_zdiv')
        if args.cpu >= 7:
            POP()
            label('_@_raise_zdiv_nopop')
        LDWI('.msg');STW(T0)
        LDWI(0x104)
        if args.cpu >= 7:
            JNE('__@raisem')
        elif args.cpu >= 6:
            POP();JNE('__@raisem')
        else:
            _CALLI('__@raisem');POP();RET()

    def code0m():
        label('.msg') # "Division by zero"
        bytes(68,105,118,105,115,105,111,110);
        bytes(32,98,121,32,122,101,114,111);
        bytes(0);

    module(name='raise_zdiv.s',
           code=[ ('IMPORT', '__@raisem'),
                  ('EXPORT', '_@_raise_zdiv'),
                  ('EXPORT', '_@_raise_zdiv_nopop') if args.cpu >= 7 else ('NOP',),
                  ('CODE', '_@_raise_zdiv', code0),
                  ('DATA', '.msg', code0m, 0, 1) ] )

    def code1():
        nohop()
        label('_fexception')
        PUSH();_MOVF(F8,FAC);
        label('_@_raise_ferr')
        LDWI('.msg');STW(T0)
        LDWI(0x304)
        if args.cpu >= 6:
            POP();JNE('__@raisem')
        else:
            _CALLI('__@raisem');POP();RET()

    def code1m():
        label('.msg') # "Floating point exception"
        bytes(70,108,111,97,116,105,110,103);
        bytes(32,112,111,105,110,116,32,101);
        bytes(120,99,101,112,116,105,111,110);
        bytes(0);

    module(name='_fexception.s',
           code=[ ('IMPORT', '__@raisem'),
                  ('EXPORT', '_fexception'),
                  ('EXPORT', '_@_raise_ferr'),
                  ('CODE', '_fexception', code1),
                  ('DATA', '.msg', code1m, 0, 1) ] )

    def code2():
        nohop()
        label('_foverflow')
        PUSH();_MOVF(F8,FAC);
        label('_@_raise_fovf')
        _MOVIW('errno',T2);LDI(2);POKE(T2);  # set errno=ERANGE on overflow.
        _MOVIW('.msg',T0)
        LDWI(0x204)
        if args.cpu >= 6:
            POP();JNE('__@raisem')
        else:
            _CALLI('__@raisem');POP();RET()

    def code2m():
        label('.msg') # "Floating point overflow"
        bytes(70,108,111,97,116,105,110,103);
        bytes(32,112,111,105,110,116,32,111);
        bytes(118,101,114,102,108,111,119,0);

    module(name='_foverflow.s',
           code=[ ('IMPORT', '__@raisem'),
                  ('IMPORT', 'errno'),
                  ('EXPORT', '_foverflow'),
                  ('EXPORT', '_@_raise_fovf'),
                  ('CODE', '_foverflow', code2),
                  ('DATA', '.msg', code2m, 0, 1) ] )


    # -----------------------------------------------
    # The following stubs define functions
    # _do{print|scan}_{long|float} that conditionally link and call
    # the actual implementation _do{print|scan}_{long|float}_imp if
    # the symbols '_@_using_fmov' or '_@_using_lmov' are defined,
    # indicating that floats or longs are actually used in the code.
    # This is useful because it prevents loading bulky long or float
    # code when it is not needed.
    #
    # This makes use of the weak symbol aliases '__glink_weak_xxx' and
    # the conditional import directive ('IMPORT', sym, 'IF', sym)
    # which are both implemented by glink.

    def code_doscan_double():
        nohop()
        label('_doscan_double')
        LDWI('__glink_weak__doscan_double_imp')
        if args.cpu >= 7:
            JNE('__glink_weak__doscan_double_imp')
        else:
            _BEQ('.ret')
            PUSH();CALL(vAC);POP()
        label('.ret')
        RET()

    module(name='_doscan_double.s',
           code=[ ('EXPORT', '_doscan_double'),
                  ('IMPORT', '_doscan_double_imp', 'IF', '_@_using_fmov'),
                  ('CODE', '_doscan_double', code_doscan_double) ] )

    def code_doprint_double():
        nohop()
        label('_doprint_double')
        LDWI('__glink_weak__doprint_double_imp')
        if args.cpu >= 7:
            JNE('__glink_weak__doprint_double_imp')
        else:
            _BEQ('.ret')
            PUSH();CALL(vAC);POP()
        label('.ret')
        RET()

    module(name='_doprint_double.s',
           code=[ ('EXPORT', '_doprint_double'),
                  ('IMPORT', '_doprint_double_imp', 'IF', '_@_using_fmov'),
                  ('CODE', '_doprint_double', code_doprint_double) ] )

    def code_doprint_long():
        nohop()
        label('_doprint_long')
        LDWI('__glink_weak__doprint_long_imp')
        if args.cpu >= 7:
            JNE('__glink_weak__doprint_long_imp')
        else:
            _BEQ('.ret')
            PUSH();CALL(vAC);POP()
        label('.ret')
        RET()

    module(name='_doprint_long.s',
           code=[ ('EXPORT', '_doprint_long'),
                  ('IMPORT', '_doprint_long_imp', 'IF', '_@_using_lmov'),
                  ('CODE', '_doprint_long', code_doprint_long) ] )

    # -----------------------------------------------
    # Define symbol "_egt1" which is an initialized pointer
    # that marks the end of the highest gt1 segment. This
    # is filled by the linker via __glink_magic_egt1.

    def code_egt1():
        align(2)
        label('_egt1')
        label('__glink_magic_egt1')
        words(0xBEEF)

    module(name='_egt1.s',
           code=[ ('EXPORT', '_egt1'),
                  ('EXPORT', '__glink_magic_egt1'),
                  ('DATA', '_egt1', code_egt1, 2, 2) ])


scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def code0():
    nohop()
    label('abs')
    LDW(R8)
    _BGE('.ret')
    if args.cpu >= 6:
        NEGV(vAC)
    else:
        LDI(0);SUBW(R8)
    label('.ret')
    RET()
    
code=[
    ('EXPORT', 'abs'),
    ('CODE', 'abs', code0) ]

module(code=code, name='abs.s');

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
	
def scope():

    def code0():
        '''zero page variables'''
        label('_vIrqCounter')
        words(0)

    def code1():
        nohop()
        label('_vIrqHandler')
        if args.cpu >= 7:
            # Cannot be used for cpu6 because PREFX2 instructions change sysArg7
            INCV('_vIrqCounter')
        else:
            LDI(1);ADDW('_vIrqCounter');STW('_vIrqCounter')
        label('_vIrqRelay', pc()+1)
        LDWI(0);_BEQ('.h1')
        PUSH();CALL(vAC);POP()
        label('.h1')
        LDWI(0x400);LUP(0)

    def code2():
        label('_vIrqInit')
        LDI(0);STW('_vIrqCounter');ST('frameCount')
        LDWI('_vIrqHandler');_BRA('.v1')
        label('_vIrqFini')
        LDI(0)
        label('.v1')
        STW(T3);LD('romType');ANDI(0xfc);SUBI(0x40);_BLT('.v2')
        LDWI('vIRQ_v5');STW(T2);LDW(T3);DOKE(T2)
        label('.v2')
        RET()

    def code3():
        label('__glink_magic_init')
        words('_vIrqInit', 0)

    def code4():
        label('__glink_magic_fini')
        words('_vIrqFini', 0)
        
    module(name='_virq.s',
           code=[ ('EXPORT', '_vIrqCounter'),
                  ('EXPORT', '_vIrqRelay'),
                  ('BSS', '_vIrqCounter', code0, 2, 1),
                  ('PLACE', '_vIrqCounter', 0x0000, 0x007f) ]
           +    ( [ ('CODE', '_vIrqHandler', code1),
                    ('CODE', '_vIrqInit', code2), 
                    ('PLACE', '_vIrqHandler', 0x200, 0x7fff),
                    ('DATA', '__glink_magic_init', code3, 4, 2),
                    ('DATA', '__glink_magic_fini', code4, 4, 2) ]
                  if 'has_vIRQ' in rominfo else [] ) )
    

    def code5():
        label('clock')
        label('_clock')
        if 'has_vIRQ' in rominfo:
            LD('frameCount');ST(LAC)
            LDW('_vIrqCounter');STW(LAC+1)
            LDI(0);ST(LAC+3)
            LDW(LAC);RET()
        else:
            warning('clock() cannot work without vIRQ (needs rom>=v5a)', dedup=True)
            LDI(0);STW(LAC);STW(LAC+2);RET()

    module(name='clock.s',
           code=[ ('EXPORT', 'clock'),
                  ('EXPORT', '_clock'),
                  ('IMPORT', '_vIrqCounter'),
                  ('CODE', 'clock', code5) ] )

    def code6():
        nohop()
        # Following at67: 179 is normally the start of vBlank, but if
        # a vBlank routine is executing there is a very good chance by
        # the time the vBlank routine is over giga_videoY will have
        # progressed past 179, (by how much is nondeterministic). So
        # instead we wait for the scanline before vBlank, i.e. when
        # videoY = 0xEE, (videoTablePtr = 0x01EE)
        label('.w1')
        LD('videoY');XORI(0xee);_BEQ('.w1')
        label('_wait')
        LD('videoY');XORI(0xee);_BNE('_wait')
        LDW(R8);SUBI(1);STW(R8);BGT('.w1')
        RET();

    module(name='_wait.s',
           code=[ ('EXPORT', '_wait'),
                  ('CODE', '_wait', code6) ] )
    
scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
	


def scope():


  # ------- OUTPUT ROUTINES -------

  # - putch(int c)
  def code_putch():
    nohop()
    label('putch')
    PUSH()
    if SP == vSP:
      ALLOC(-2) 
    LDW(R8);DOKE(SP)
    _MOVW(SP,R8)
    _MOVIW(1,R9)
    _CALLJ('console_print')
    _DEEKV(SP)
    if SP == vSP:
      ALLOC(2)
    tryhop(2);POP();RET()
    
  module(name='putch.s',
         code=[('EXPORT', 'putch'),
               ('IMPORT', 'console_print'),
               ('CODE', 'putch', code_putch) ] )


  # - cputs(const char *s)
  def code_cputs():
    nohop()
    label('cputs')
    LDWI(0x7fff);STW(R9)
    if args.cpu >= 6:
      JNE('console_print')
    else:
      PUSH();_CALLJ('console_print')
      tryhop(2);POP();RET()

  module(name='cputs.s',
         code=[('EXPORT', 'cputs'),
               ('IMPORT', 'console_print'),
               ('CODE', 'cputs', code_cputs) ] )


  # - int wherex()
  def code_wherex():
    nohop()
    label('wherex')
    LD(v('console_state')+3)
    ADDI(1);RET()

  module(name='wherex.s',
         code=[('EXPORT', 'wherex'),
               ('IMPORT', 'console_state'),
               ('CODE', 'wherex', code_wherex) ] )

  # - int wherey()
  def code_wherey():
    nohop()
    label('wherey')
    LD(v('console_state')+2)
    ADDI(1);RET()

  module(name='wherex.s',
         code=[('EXPORT', 'wherey'),
               ('IMPORT', 'console_state'),
               ('CODE', 'wherey', code_wherey) ] )


  # - void gotoxy(int x, int y)
  def code_gotoxy():
    nohop()
    label('gotoxy')
    LDW(R8);SUBI(1);ST(v('console_state')+3)
    LDW(R9);SUBI(1);ST(v('console_state')+2)
    RET()

  module(name='gotoxy.s',
         code=[('EXPORT', 'gotoxy'),
               ('IMPORT', 'console_state'),
               ('CODE', 'gotoxy', code_gotoxy) ] )


  # - void textcolor(int)
  def code_textcolor():
    nohop()
    label('textcolor')
    LD(R8);ST(v('console_state')+1)
    RET()

  module(name='textcolor.s',
         code=[('EXPORT', 'textcolor'),
               ('IMPORT', 'console_state'),
               ('CODE', 'textcolor', code_textcolor) ] )


  # - void textbackground(int)
  def code_textbackground():
    nohop()
    label('textbackground')
    LD(R8);ST(v('console_state'))
    RET()

  module(name='textbackground.s',
         code=[('EXPORT', 'textbackground'),
               ('IMPORT', 'console_state'),
               ('CODE', 'textbackground', code_textbackground) ] )


  # - void clrscr(void)
  def code_clrscr():
    nohop()
    label('clrscr')
    label('console_clear_screen')
    _MOVIW(0,v('console_state')+2)
    LDW(v('console_state')+0);STW(R8)
    if args.cpu >= 6:
      JGE('_console_reset')
    else:
      PUSH();_CALLJ('_console_reset')
      tryhop(2);POP();RET()

  module(name='clrscr.s',
         code=[('EXPORT', 'clrscr'),
               ('EXPORT', 'console_clear_screen'),
               ('IMPORT', '_console_reset'),
               ('IMPORT', 'console_state'),
               ('CODE', 'clrscr', code_clrscr) ] )


  # - void clreol(void)
  def code_clreol():
    nohop()
    label('clreol')
    label('console_clear_to_eol')
    PUSH()
    _CALLJ('_console_addr');STW(R8);_BEQ('.ret')
    LD(v('console_state')+0);STW(R9)
    _MOVIW(8,R10)
    _CALLJ('_console_clear')
    label('.ret')
    tryhop(2);POP();RET()

  module(name='clreol.s',
         code=[('EXPORT', 'clreol'),
               ('EXPORT', 'console_clear_to_eol'),
               ('IMPORT', '_console_addr'),
               ('IMPORT', '_console_clear'),
               ('IMPORT', 'console_state'),
               ('CODE', 'clreol', code_clreol) ] )


  # - void cputsxy(int x, int y, const char *s)
  def code_cputsxy():
    nohop()
    label('cputsxy')
    PUSH();ALLOC(-2)
    LDW(v('console_state')+2);STLW(0)
    _CALLJ('gotoxy')
    _MOVW(R10,R8)
    _CALLJ('cputs')
    LDLW(0);STW(v('console_state')+2)
    ALLOC(2);tryhop(2);POP();RET()

  module(name='cputsxy.s',
         code=[('EXPORT', 'cputsxy'),
               ('IMPORT', 'console_state'),
               ('IMPORT', 'gotoxy'),
               ('IMPORT', 'cputs'),
               ('CODE', 'cputsxy', code_cputsxy) ] )



  # ------- INPUT ROUTINES -------


  def code_getch_vars():
    label('getch.buf')
    bytes(0)

  module(name='getch_vars.s',
         code=[('EXPORT', 'getch.buf'),
               ('DATA', 'getch_vars', code_getch_vars, 1, 1) ] )


  # -- int kbhit(void)
  def code_kbhit():
    nohop()
    label('kbhit')
    PUSH()
    _CALLJ('kbget');_BGT('.hit')
    LDI(0)
    label('.hit')
    ST(R21)
    LDWI('getch.buf')
    if args.cpu >= 6:
      POKEA(R21);LD(R21)
    else:
      STW(R20);LD(R21);POKE(R20)
    tryhop(2);POP();RET()

  module(name='kbhit.s',
         code=[('EXPORT', 'kbhit'),
               ('IMPORT', 'getch.buf'),
               ('IMPORT', 'kbget'),
               ('CODE', 'kbhit', code_kbhit) ] )


  # -- int getch(void)
  def code_getch():
    nohop()
    label('getch')
    PUSH()
    LDWI('getch.buf');STW(R20);PEEK();ST(R21)
    LDI(0);POKE(R20);LD(R21);_BGT('.ret')
    label('.loop')
    _CALLJ('kbget');_BLT('.loop')
    label('.ret')
    tryhop(2);POP();RET()

  module(name='getch.s',
         code=[('EXPORT', 'getch'),
               ('IMPORT', 'getch.buf'),
               ('IMPORT', 'kbget'),
               ('CODE', 'getch', code_getch) ] )


  # -- void ungetch(int c)
  def code_ungetch():
    nohop()
    label('ungetch')
    LDWI('getch.buf');STW(R20)
    LD(R8+1);_BNE('.ret0')
    LD(R8);_BEQ('.ret0')
    XORI(255);_BEQ('.ret0')
    POKE(R20);RET()
    label('.ret0')
    LDI(0);POKE(R20);SUBI(1);RET()

  module(name='ungetch.s',
         code=[('EXPORT', 'ungetch'),
               ('IMPORT', 'getch.buf'),
               ('CODE', 'ungetch', code_ungetch) ] )


  # -- int getche(void)
  def code_getche():
    nohop()
    label('getche')
    PUSH();ALLOC(-4)
    LDWI('getch.buf');STW(R20);PEEK();ST(R21)
    LDI(0);POKE(R20);LD(R21);_BGT('.ret')
    label('.loop')
    _CALLJ('kbget');_BGE('.ret')
    _MOVIW(2,R9);_CALLJ('.pcursor')
    _BRA('.loop')
    label('.ret')
    STLW(2)
    _MOVIW(3,R9);_CALLJ('.pblank')
    LDLW(2);ALLOC(4)
    tryhop(2);POP();RET()
    label('.pcursor')
    LDWI(0x87f);STLW(0)
    LD('frameCount');ANDI(8);_BEQ('.p2')
    label('.pblank')
    LDWI(0x820);STLW(0)
    label('.p2')
    if args.cpu >= 7:
      LDW(vSP)
    else:
      LD(vSP)
    STW(R8);PUSH()
    _CALLJ('console_print')
    tryhop(2);POP();RET()

  module(name='getche.s',
         code=[('EXPORT', 'getche'),
               ('IMPORT', 'kbget'),
               ('IMPORT', 'getch.buf'),
               ('IMPORT', 'console_print'),
               ('CODE', 'getche', code_getche) ] )


  # -- int console_waitkey(void)
  def code_waitkey():
    nohop()
    label('console_waitkey')
    PUSH();ALLOC(-4)
    LDWI('getch.buf');STW(R20);PEEK();ST(R21)
    LDI(0);POKE(R20);LD(R21);_BGT('.ret')
    label('.loop')
    _CALLJ('kbget');_BGE('.ret')
    _MOVIW(2,R9);_CALLJ('.pcursor')
    _BRA('.loop')
    label('.ret')
    STLW(2)
    _MOVIW(2,R9);_CALLJ('.pblank')
    LDLW(2);ALLOC(4)
    tryhop(2);POP();RET()
    label('.pcursor')
    LDWI(0x87f);STLW(0)
    LD('frameCount');ANDI(8);_BEQ('.p2')
    label('.pblank')
    LDWI(0x820);STLW(0)
    label('.p2')
    if args.cpu >= 7:
      LDW(vSP)
    else:
      LD(vSP)
    STW(R8);PUSH()
    _CALLJ('console_print')
    tryhop(2);POP();RET()

  module(name='cons_waitkey.s',
         code=[('EXPORT', 'console_waitkey'),
               ('IMPORT', 'kbget'),
               ('IMPORT', 'getch.buf'),
               ('IMPORT', 'console_print'),
               ('CODE', 'console_waitkey', code_waitkey) ] )


  # -- char *cgets(char *buffer)
  def code_cgets():
    nohop()
    label('cgets')
    PUSH();ALLOC(-2)
    LDW(R8);PEEK();STW(R9)
    LDW(R8);STLW(0);ADDI(2);STW(R8)
    _CALLJ('console_readline');ST(R10)
    LDLW(0);ADDI(1);STW(R8)
    LD(R10);POKE(R8)
    LDW(R8);ADDI(1);
    ALLOC(2);tryhop(2);POP();RET()

  module(name='cgets.s',
         code=[('EXPORT','cgets'),
               ('IMPORT','console_readline'),
               ('CODE','cgets',code_cgets) ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:


def scope():


    # ------------------------------------------------------------
    # LOW LEVEL SCREEN ACCESS
    # ------------------------------------------------------------
    # These functions do not know about the console
    # state and simply access the screen at the provided address.
    # ------------------------------------------------------------



    # -- int _console_printchars(int fgbg, char *addr, const char *s, int len)

    # Draws up to `len` characters from string `s` at the screen
    # position given by address `addr`.  This assumes that the
    # horizontal offsets in the string table are all zero. All
    # characters are printed on a single line (no newline).  The
    # function returns when any of the following conditions is met:
    # (1) `len` characters have been printed,
    # (2) the next character would not fit horizontally on the screen, or
    # (3) an unprintable character, i.e. not in [0x20-0x83], has been met.

    def code_printchars(hires=False):
        label('_console_printchars')
        PUSH()
        _MOVIW('SYS_VDrawBits_134','sysFn')      # prep sysFn
        _MOVW(R8,'sysArgs0')                     # move fgbg, freeing R8
        _MOVIW(0,R12)                            # R12: character counter
        label('.loop')
        LDW(R10);PEEK();STW(R8)                  # R8: character code
        if args.cpu >= 6:
            INCV(R10)
        else:
            LDI(1);ADDW(R10);STW(R10)            # next char
        LDW(R9);STW('sysArgs4')                  # destination address
        ADDI(3 if hires else 6);STW(R9);         # next address
        LD(vACL);SUBI(0xA0);_BGT('.ret')         # beyond screen?
        _LDI('font32up');STW(R13)                # R13: font address
        LDW(R8);SUBI(32);_BLT('.ret'  )          # c<32
        STW(R8);SUBI(50);_BLT('.draw')           # 32 <= c < 82
        STW(R8);SUBI(50);_BGE('.ret')            # >= 132
        _LDI('font82up');STW(R13)
        label('.draw')
        _CALLJ('_printonechar')
        if args.cpu >= 6:
            INCV(R12);LDW(R12)
        else:
            LDI(1);ADDW(R12);STW(R12);           # increment counter
        XORW(R11);_BNE('.loop')                  # loop
        label('.ret')
        tryhop(4);LDW(R12);POP();RET()

    def code_printonechar():
        nohop()
        label('_printonechar')
        LDW(R8);LSLW();LSLW();ADDW(R8);ADDW(R13)
        STW(R13);LUP(0);ST('sysArgs2');SYS(134);INC('sysArgs4')
        LDW(R13);LUP(1);ST('sysArgs2');SYS(134);INC('sysArgs4')
        LDW(R13);LUP(2);ST('sysArgs2');SYS(134);INC('sysArgs4')
        LDW(R13);LUP(3);ST('sysArgs2');SYS(134);INC('sysArgs4')
        LDW(R13);LUP(4);ST('sysArgs2');SYS(134);INC('sysArgs4')
        LDI(0);ST('sysArgs2');SYS(134)
        RET()

    module(name='cons_printchar.s',
           code=[ ('EXPORT', '_console_printchars'),
                  ('CODE', '_console_printchars', code_printchars),
                  ('CODE', '_printonechar', code_printonechar) ] )


    # -- void _console_clear(char *addr, int clr, char nl)
    # Clears from addr to the end of line with color clr.
    # Repeats for nl successive lines.

    def code_clear():
        label('_console_clear')
        PUSH()
        if args.cpu >= 7:
            LDW(R8);STW(T2)
            LD(R9);ANDI(0x3f);STW(T3)
            LDI(160);SUBW(R8);ST(R11)
            LD(R10);ST(R11+1);LDW(R11)
            FILL()
        else:
            _MOVIW('SYS_SetMemory_v2_54','sysFn')
            LDI(160);SUBW(R8);ST(R11)
            LD(R9);ANDI(0x3f);ST('sysArgs1')
            label('.loop')
            LD(R11);ST('sysArgs0')
            _MOVW(R8,'sysArgs2')
            SYS(54)
            INC(R8+1)
            if args.cpu >= 6:
                DBNE(R10,'.loop')
            else:
                LDW(R10);SUBI(1);STW(R10)
                _BNE('.loop')
        tryhop(2);POP();RET()

    module(name='cons_clear.s',
           code=[ ('EXPORT', '_console_clear'),
                  ('CODE', '_console_clear', code_clear) ] )



    # ------------------------------------------------------------
    # HELPERS FOR CONSOLE_PRINT
    # ------------------------------------------------------------
    # These functions optimize the size of console_print.
    # They depend on the layout of console_state and console_info.
    # They assume console_state is in page zero
    # ------------------------------------------------------------


    # -- char *_console_scroll(void)

    def code_scroll(hires = False):
        nohop()
        label('_console_scroll')
        PUSH()
        # clear first line
        LDWI(v('console_info')+4)                # offset
        PEEK();INC(vACH);PEEK();ST(R8+1)
        LDI(0);ST(R8)
        LD('console_state');STW(R9)              # bg
        _MOVIW(8,R10)
        _CALLJ('_console_clear')
        # scroll videotable lines
        LDWI(v('console_info')+4);STW(R10)       # offset
        PEEK();INC(vACH);PEEK();STW(R9)
        LDWI(v('console_info')+0);DEEK()         # nlines
        SUBI(1);ST(v('console_state')+2) # cy
        label('.loop1')
        STW(R8)
        ADDW(R10);PEEK();INC(vACH);STW(R12)
        PEEK();ST(R13)
        if not hires: _MOVIW(8,R14)
        if hires: _MOVIW(4,R14)
        label('.loop2')
        LD(R9);POKE(R12)
        INC(R9)
        if hires: INC(R9)
        INC(R12);INC(R12)
        if args.cpu >= 6:
            DBNE(R14, '.loop2')
        else:
            LD(R14);SUBI(1);ST(R14);_BNE('.loop2')
        LD(R13);ST(R9)
        LD(R8);SUBI(1);_BGE('.loop1')
        tryhop(2);POP();RET()

    module(name='cons_scroll.s',
           code=[ ('EXPORT', '_console_scroll'),
                  ('IMPORT', '_console_clear'),
                  ('IMPORT', 'console_state'),
                  ('IMPORT', 'console_info'),
                  ('CODE', '_console_scroll', code_scroll) ] )


    # -- char *_console_addr(void)

    # Function _console_addr() returns the screen address of the cursor.
    # If the cursor is outside the screen it tries wrapping or scrolling.
    # Return zero if still outside the screen.
    # Warning: depends on the layout of console_state and console_info

    def code_addr(hires = False):
        nohop()
        label('_console_addr')
        PUSH()
        LD(v('console_state')+3);STW(R8)                # cx
        LDWI(v('console_info')+2);DEEK();               # ncolumns
        SUBW(R8);_BGT('.nw')
        LD(v('console_state')+5);_BEQ('.nw');           # wrapx
        INC(v('console_state')+2)                       # cy++
        LDI(0);ST(v('console_state')+3)                 # cx=0
        label('.nw')
        LD(v('console_state')+2);STW(R8)                # cy
        LDWI(v('console_info')+0);DEEK();               # nlines
        SUBW(R8);_BGT('.nh')
        LD(v('console_state')+4);_BEQ('.ret0');         # wrapy
        _CALLJ('_console_scroll')                       # spill!
        label('.nh')
        LDWI(v('console_info')+4);STW(R9)               # offset
        LD(v('console_state')+3);STW(R8)                # cx
        LDWI(v('console_info')+2);DEEK()                # ncolumns
        SUBW(R8);_BLE('.ret0')
        LDW(R8);LSLW();ADDW(R8)                         # times 6 for std
        if not hires: LSLW()                            # times 3 for hires
        STW(R10)
        LD(v('console_state')+2);ADDW(R9)               # cy + offset
        PEEK();INC(vACH);PEEK();ST(R10+1)               # page
        LDW(R10);tryhop(2);POP();RET()
        label('.ret0')
        LDI(0);tryhop(2);POP();RET()

    module(name='cons_addr.s',
           code=[ ('EXPORT', '_console_addr'),
                  ('IMPORT', '_console_scroll'),
                  ('IMPORT', 'console_state'),
                  ('IMPORT', 'console_info'),
                  ('CODE', '_console_addr', code_addr) ] )


    # -- int console_print(const char *s, unsigned int len)
    # -- int _console_writall(const char *s, unsigned int len, void *unused);
    # Function console_writall writes exactly len characters.
    # Function console_print stops on a zero char.

    def code_print():
        label('console_print')
        tryhop(16)
        LDI(0);STW(R10)
        label('console_writall')
        # Stack:
        # - 2 bytes for console_ctrl argument
        # - 10 bytes for R3-R7, 2 bytes pad, 2 bytes vLR
        _PROLOGUE(16,2,0xf8) # save R3-R7
        _MOVW(R9,R6)             # len
        LDW(R8);STW(R7);STW(R5)  # s, ssav
        _MOVW(R10,R4)            # zeroterm flag
        _BRA('.tst1')
        label('.loop')
        # Addr
        _CALLJ('_console_addr');STW(R3)
        # optional _console_ctrl
        _PEEKV(R7);STW(R8);DOKE(SP)
        LDWI('__glink_weak__console_ctrl');_BEQ('.ctrl')
        CALL(vAC);_BNE('.add')
        # build int handlers for CR LF BS
        label('.ctrl')
        _PEEKV(R7)
        XORI(8);_BEQ('.ctrl_bs')
        XORI(13 ^ 8);_BEQ('.ctrl_cr')
        XORI(10 ^ 13);_BNE('.print')
        label('.ctrl_lf')
        INC(v('console_state')+2)         # cy++
        label('.ctrl_cr')
        LDI(0);ST(v('console_state')+3)   # cx=0
        _BRA('.add1')
        label('.ctrl_bs')
        LD(v('console_state')+3);_BLE('.ctrl_bs1')
        SUBI(1);ST(v('console_state')+3); # cx--
        _BRA('.add1')
        label('.ctrl_bs1')
        LD(v('console_state')+2);_BLE('.add1')
        SUBI(1);ST(v('console_state')+2); # cy--
        LDWI(v('console_info')+2);DEEK()
        SUBI(1);ST(v('console_state')+3); # cx=ncolumns-1
        label('.add1')
        LDI(1);_BNE('.add')
        # Try printchars
        label('.print')
        LDW(R3);STW(R9);_BEQ('.add1')
        LDW(v('console_state')+0);STW(R8) # fgbg
        _MOVW(R7,R10)
        _MOVW(R6,R11)
        _CALLJ('_console_printchars');_BEQ('.add1')
        if args.cpu >= 7:
            ADDV(v('console_state')+3)    # won't carry into high byte!
        else:
            STW(R8);ADDW(v('console_state')+3)
            ST(v('console_state')+3);LDW(R8)
        label('.add')
        if args.cpu >= 7:
            ADDV(R7);SUBV(R6)
        else:
            STW(R8);ADDW(R7);STW(R7)
            LDW(R6);SUBW(R8);STW(R6)
        # Test for more
        label('.tst1')
        LDW(R6);_BEQ('.ret')
        LDW(R4);_BNE('.loop')
        _PEEKV(R7);_BNE('.loop')
        label('.ret')
        LDW(R7);SUBW(R5)
        _EPILOGUE(16,2,0xf8,saveAC=True);


    ctrl = []
    if 'CTRL_RICH' in args.opts:
        ctrl = [('IMPORT', '_console_ctrl')]
    elif not 'CTRL_SIMPLE'  in args.opts:
        ctrl = [('IMPORT', '_console_ctrl', 'IF', '_iob1')]

    module(name='cons_print.s',
           code=[ ('EXPORT', 'console_print'),
                  ('EXPORT', 'console_writall'),
                  ('IMPORT', 'console_state'),
                  ('IMPORT', 'console_info'),
                  ('IMPORT', '_console_addr'),
                  ('IMPORT', '_console_printchars'),
                  ('CODE', 'console_print', code_print) ] + ctrl )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:


def scope():

    # -- int _console_bell(int duration)
    # Sounds the bell for duration frames, honoring 'channelMask_v4'

    def code_bell():
        nohop()
        label('_console_bell')
        PUSH()
        LD('channelMask_v4');ANDI(3);LSLW();LSLW();STW(R17)
        LDWI('.cp1');SUBW(R17);STW(R17)
        _MOVIW(0x1fc,R16);LDWI(0x0752);CALL(R17)
        _MOVIW(0x1fa,R16);LDWI(0x100);CALL(R17)
        LD(R8);ST('soundTimer')
        POP();RET()
        DOKE(R16);INC(R16+1)
        DOKE(R16);INC(R16+1)
        DOKE(R16);INC(R16+1)
        label('.cp1')
        DOKE(R16);RET()

    module(name='cons_bell.s',
           code=[ ('EXPORT', '_console_bell'),
                  ('CODE', '_console_bell', code_bell) ] )
    
scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:


def scope():

  def _LDSB(v):
    if args.cpu >= 7:
      LDSB(v)
    else:
      LD(v);XORI(128);SUBI(128)

  def _POKEQ(i):
    if args.cpu >= 6:
      POKEQ(i)
    else:
      STW(T2);LDI(i);POKE(T2)


  # -- int kbget(void)
  # Aliased to one of kbget[abc]()

  kbget_default = 'kbgeta'
  if 'KBGET_AUTOREPEAT' in args.opts:
    kbget_default = 'kbgetc'
  elif 'KBGET_AUTOBTN' in args.opts:
    kbget_default = 'kbgetb'

  def code_kbget():
    label('kbget', kbget_default)
    label('console_getkey', kbget_default)

  module(name='kbget.s',
         code=[('EXPORT', 'kbget'),
               ('IMPORT', kbget_default),
               ('CODE', 'kbget', code_kbget) ])

  def code_getkey():
    label('console_getkey', kbget_default)

  module(name='console_getkey.s',
         code=[('EXPORT', 'console_getkey'),
               ('IMPORT', kbget_default),
               ('CODE', 'kbget', code_kbget) ])
  
  # -- int kbgeta(void)
  def code_kbgeta():
    nohop()
    label('kbgeta')
    _MOVIW('.last',R9)
    LD('serialRaw');ST(R8)
    label('.last', pc()+1) # next opcode arg
    XORI(0xff);_BEQ('.ret')
    LD(R8);POKE(R9);XORI(0xff);_BEQ('.ret')
    LD(R8);RET()
    label('.ret')
    SUBI(1);RET()

  module(name='kbgeta.s',
         code=[('EXPORT', 'kbgeta'),
               ('CODE', 'kbgeta', code_kbgeta) ] )



  # -- helper for kbgetb/kbgetc
  def code_kbgetx():
    nohop()
    label('kbget.sub')
    LD('buttonState');XORI(255);STW(R18)
    LD('serialRaw');STW(R19)
    LD('kbget.last');SUBI(0x7f);_BLT('.kbd')
    label('.btn')                # button?
    LDI(0xef);ANDW(R18);STW(R18)
    label('.btn1')
    LDI(0);SUBW(R18);ANDW(R18);ST(R18);_BEQ('.btn2')
    ANDI(0xef);ORW('buttonState');ST('buttonState')
    LD(R18);XORI(255);RET()
    label('.btn2')              # no!
    SUBI(1);RET()
    label('.kbd')               # keyboard?
    LD(R19);XORI(255);_BEQ('.btn2')
    LD('kbget.last');XORW(R19);_BEQ('.btn2')
    LD(R19);SUBI(0x7f);_BGE('.btn1')
    label('.kbd2')              # typeC?
    LDI(1);ADDW(R19);ANDW(R19);_BEQ('.btn1')
    LDWI(v('.kbd2')+1);_POKEQ(0)
    LDI(255);ST('buttonState')
    LD(R19);RET()

  def code_kbget_last():
    label('kbget.last')
    bytes(0)

  module(name='kbgetx.s',
         code=[('EXPORT', 'kbget.sub'),
               ('EXPORT', 'kbget.last'),
               ('CODE', 'kbget.sub', code_kbgetx),
               ('DATA', 'kbget.last', code_kbget_last),
               ('PLACE', 'kbget.last', 0x00, 0xff) ] )


  # -- int kbgetb(void)
  def code_kbgetb():
    nohop()
    label('kbgetb')
    PUSH()
    _CALLJ('kbget.sub');_BLT('.nok')
    ST('kbget.last')
    tryhop(2);POP();RET()       # normal return
    label('.nok')
    LD('serialRaw');XORI(255);_BNE('.ret0')
    ST('kbget.last')
    label('.ret0')              # nokey return
    _LDI(-1)
    tryhop(2);POP();RET()

  module(name='kbgetb',
         code=[('EXPORT', 'kbgetb'),
               ('IMPORT', 'kbget.sub'),
               ('IMPORT', 'kbget.last'),
               ('CODE', 'kbgetb', code_kbgetb) ] )


  # -- int kbgetc(void)
  def code_kbgetc():
    nohop()
    label('kbgetc')
    PUSH()
    _CALLJ('kbget.sub');_BLT('.nok')
    ST('kbget.last')
    LD('frameCount');ADDI(48);ST('kbget.fc')
    label('.ret1')
    LD('kbget.last')
    tryhop(2);POP();RET()       # normal return
    label('.nok')
    LD('serialRaw');XORI(255);_BNE('.rpt')
    ST('kbget.last')
    label('.ret0')
    _LDI(-1)
    tryhop(2);POP();RET()
    label('.rpt')
    LD('kbget.last');_BEQ('.ret0')
    LD('frameCount');SUBW('kbget.fc');ST(vACH);_BLT('.ret0')
    LDI(8);ADDW('kbget.fc');ST('kbget.fc');_BRA('.ret1')

  def code_kbget_fc():
    label('kbget.fc')
    bytes(0)

  module(name='kbgetc',
         code=[('EXPORT', 'kbgetc'),
               ('IMPORT', 'kbget.sub'),
               ('IMPORT', 'kbget.last'),
               ('CODE', 'kbgetc', code_kbgetc),
               ('DATA', 'kbget_fc', code_kbget_fc, 1, 1),
               ('PLACE', 'kbget_fc', 0x00, 0xff) ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

# double copysign(double, double);

def code0():
    nohop()
    label('copysign')
    PUSH()
    LD(F8+1);XORW(F11+1);ANDI(0x80);XORW(F8+1);ST(F8+1)
    _MOVF(F8,FAC)
    POP();RET()
    
code=[
    ('EXPORT', 'copysign'),
    ('CODE', 'copysign', code0) ]
	
module(code=code, name='copysign.s');

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def code0():
    # div_t *div(int a, int q)
    label('div')
    PUSH();
    LDW(R9);_MODS(R10)
    #  _@_mods returns remainder in vAC and quotient in T1
    STW(R21);
    if args.cpu >= 6:
        LDW(R8);DOKEA(T1)
        ADDI(2);DOKEA(R21)
    else:
        LDW(T1);DOKE(R8)
        LDI(2);ADDW(R8);STW(R8);LDW(R21);DOKE(R8)
    tryhop(2);POP();RET()
    
code=[
    ('EXPORT', 'div'),
    ('CODE', 'div', code0),
    ('IMPORT', '_@_mods') ]

module(code=code, name='div.s');

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
	

# double fabs(double);

def code0():
    nohop()
    label('fabs')
    PUSH()
    LD(F8+1);ANDI(127);ST(F8+1)
    _MOVF(F8, FAC)
    POP();RET()
    
code=[
    ('EXPORT', 'fabs'),
    ('CODE', 'fabs', code0) ]
	
module(code=code, name='fabs.s');

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():
    
    def code0():
        nohop()
        label('modf')
        PUSH()
        _MOVF(F8, FAC)
        _CALLJ('_@_frndz')
        LDW(R11)
        _MOVF(FAC, [vAC])
        _FNEG();LDI(F8);_FADD()
        POP();RET()

    module(name='modf.s',
           code=[ ('EXPORT', 'modf'),
                  ('IMPORT', '_@_frndz'),
                  ('CODE', 'modf', code0) ] )

    def code0():
        nohop()
        label('floor')
        PUSH()
        _MOVF(F8, FAC)
        _CALLJ('_@_frndz')
        LDI(F8);_FCMP();_BLE('.ret')
        LDWI('_fone');_FSUB()
        label('.ret')
        POP();RET()
    
    module(name='floor.s',
           code=[ ('EXPORT', 'floor'),
                  ('IMPORT', '_@_frndz'),
                  ('IMPORT', '_fone'),
                  ('CODE', 'floor', code0) ] )

    def code0():
        nohop()
        label('ceil')
        PUSH()
        _MOVF(F8, FAC)
        _CALLJ('_@_frndz')
        LDI(F8);_FCMP();_BGE('.ret')
        LDWI('_fone');_FADD()
        label('.ret')
        POP();RET()
    
    module(name='ceil.s',
           code=[ ('EXPORT', 'ceil'),
                  ('IMPORT', '_@_frndz'),
                  ('IMPORT', '_fone'),
                  ('CODE', 'ceil', code0) ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():
    
    def code0():
        nohop()
        label('fmod')
        nohop()
        if args.cpu >= 7:
            LDI(F8);LDFAC()
            LDI(F11);JNE('_@_fmod')
        else:
            PUSH()
            _MOVF(F8, FAC)
            LDI(F11);_CALLI('_@_fmod')
            POP();RET()

    module(name='fmod.s',
           code=[ ('EXPORT', 'fmod'),
                  ('IMPORT', '_@_fmod'),
                  ('CODE', 'fmod', code0) ] )

    def code1():
        label('_fmodquo')
        PUSH()
        _MOVF(F8, FAC)
        LDI(F11);_CALLI('_@_fmod')
        DOKE(R14) # low bits of quotient
        POP();RET()
        
    module(name='fmodquo.s',
           code=[ ('EXPORT', '_fmodquo'),
                  ('IMPORT', '_@_fmod'),
                  ('CODE', '_fmodquo', code1) ] )

    
scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():

    # ----------------------------------------
    # Channel access function

    def code_channel():
        nohop()
        label('channel')
        LD(R8);ST(vACH);ORI(0xff);XORI(5);RET()  # nine bytes

        module(name='channel.s',
           code=[('EXPORT', 'channel'),
                 ('CODE', 'channel', code_channel) ] )

    # ----------------------------------------
    # int SYS_Lup(unsigned int addr)
    # -- Not a sys call but a stub for the LUP opcode.
    def code0():
        nohop()
        label('SYS_Lup')
        LDW(R8);LUP(0);RET()

    module(name='sys_lup.s',
           code=[('EXPORT', 'SYS_Lup'),
                 ('CODE', 'SYS_Lup', code0) ])

    # ----------------------------------------
    # int SYS_Fill(unsigned int yyxx, char vv, unsigned int hhww)
    # -- Not a sys call but a stub for the FILL opcode.

    def code0():
        nohop()
        label('SYS_Fill')
        if args.cpu >= 7:
            MOVW(R8,T2)
            LD(R9);STW(T3)
            LDW(R10)
            FILL();
        RET()

    module(name='sys_fill.s',
           code=[('EXPORT', 'SYS_Fill'),
                 ('CODE', 'SYS_Fill', code0) ])


    # ----------------------------------------
    # int SYS_Blit(unsigned dydx, unsigned sysx, unsigned hhww);
    # -- Not a sys call but a stub for the BLIT opcode.
    
    def code0():
        nohop()
        label('SYS_Blit')
        if args.cpu >= 7:
            MOVW(R8,T2)
            MOVW(R9,T3)
            LDW(R10)
            BLIT();
        RET()

    module(name='sys_blit.s',
           code=[('EXPORT', 'SYS_Blit'),
                 ('CODE', 'SYS_Blit', code0) ])

    
    # ----------------------------------------
    # unsigned int SYS_Random(void);
    def code0():
        nohop()
        label('SYS_Random')
        _MOVIW('SYS_Random_34','sysFn')
        SYS(34);RET()

    module(name='sys_random.s',
           code=[('EXPORT', 'SYS_Random'),
                 ('CODE', 'SYS_Random', code0) ])

    # ----------------------------------------
    # void SYS_VDrawBits(int fgbg, char bits, char *addr);
    def code0():
        nohop()
        label('SYS_VDrawBits')
        _MOVIW('SYS_VDrawBits_134','sysFn')
        _MOVW(R8,'sysArgs0')
        LD(R9);ST('sysArgs2')
        _MOVW(R10,'sysArgs4')
        SYS(134);RET()

    module(name='sys_vdrawbits.s',
           code=[('EXPORT', 'SYS_VDrawBits'),
                 ('CODE', 'SYS_VDrawBits', code0) ])

    # ----------------------------------------
    # void SYS_Exec(void *romptr, void *vlr)
    def code0():
        nohop()
        label('SYS_Exec')
        _MOVIW('SYS_Exec_88','sysFn')
        _MOVW(R8,'sysArgs0')
        _LDI(-1);XORW(R9);_BEQ('.se1')
        _MOVW(R9,vLR)
        label('.se1')
        SYS(88);RET()

    module(name='sys_exec.s',
           code=[('EXPORT', 'SYS_Exec'),
                 ('CODE', 'SYS_Exec', code0) ])

    # ----------------------------------------
    # void SYS_SetMemory(int count, int val, void *addr);
    def code0():
        nohop()
        label('SYS_SetMemory')
        _MOVIW('SYS_SetMemory_v2_54','sysFn')
        LD(R8);ST('sysArgs0')
        LD(R9);ST('sysArgs1')
        _MOVW(R10,'sysArgs2')
        SYS(54);RET()

    module(name='sys_setmemory.s',
           code=[('EXPORT', 'SYS_SetMemory'),
                 ('CODE', 'SYS_SetMemory', code0) ])

    # ----------------------------------------
    # void SYS_SetMode(int)
    def code0():
        nohop();
        label('SYS_SetMode')
        _MOVIW('SYS_SetMode_v2_80','sysFn')
        LDW(R8);SYS(80);RET()

    module(name='sys_setmode.s',
           code=[('EXPORT', 'SYS_SetMode'),
                 ('CODE', 'SYS_SetMode', code0) ])

    # ----------------------------------------
    # void* SYS_ReadRomDir(void *romptr, char *buf8);
    def code0():
        nohop()
        label('SYS_ReadRomDir')
        PUSH()
        _MOVIW('SYS_ReadRomDir_v5_80','sysFn')
        LDW(R8);SYS(80);STW(R8)
        _MOVW(R9,T2)
        _MOVIW('sysArgs0',T3)
        if args.cpu >= 6:
            MOVQB(8,R10)
            label('.loop')
            PEEKV(T3);POKE(T2)
            INCV(T2);INCV(T3)
            DBNE(R10,'.loop')
        else:
            label('.loop')
            _PEEKV(T3);POKE(T2)
            LDI(1);ADDW(T2);STW(T2)
            LDI(1);ADDW(T3);STW(T3)
            XORI(v('sysArgs0')+8)
            _BNE('.loop')
        POP();LDW(R8);RET()

    module(name='sys_readromdir.s',
           code=[('EXPORT', 'SYS_ReadRomDir'),
                 ('CODE', 'SYS_ReadRomDir', code0) ])


    # ----------------------------------------
    # void SYS_ExpanderControl(unsigned int ctrl);
    def code0():
        nohop()
        label('SYS_ExpanderControl')
        _MOVIW('SYS_ExpanderControl_v4_40','sysFn')
        LDW(R8);SYS(40)
        label('.ret')
        RET()

    module(name='sys_expandercontrol.s',
           code=[('EXPORT', 'SYS_ExpanderControl'),
                 ('CODE', 'SYS_ExpanderControl', code0) ])


    # ----------------------------------------
    # void SYS_SpiExchangeBytes(void *dst, void *src, void *srcend);
    #    Notes: This exists in v4 but depends on 0x81 containing ctrlBits.
    #    Notes: only the high 8 bits of `dst` are used.
    #    Notes: only the low 8 bits of `srcend` are used.
    def code0():
        nohop()
        label('SYS_SpiExchangeBytes')
        _MOVIW('SYS_SpiExchangeBytes_v4_134','sysFn')
        # sysArgs[0]      Page index start, for both send/receive (in, changed)
        # sysArgs[1]      Memory page for send data (in)
        # sysArgs[2]      Page index stop (in)
        # sysArgs[3]      Memory page for receive data (in)
        _MOVW(R9,'sysArgs0')
        LD(R10);ST('sysArgs2')
        LD(R8+1);ST('sysArgs3')
        SYS(134)
        RET()
    
    module(name='sys_spiexchangebytes.s',
           code=[('EXPORT', 'SYS_SpiExchangeBytes'),
                 ('CODE', 'SYS_SpiExchangeBytes', code0) ])

    # ----------------------------------------
    # void* SYS_Sprite6(void *srcpix, void *dst);
    def code():
        nohop()
        label('SYS_Sprite6')
        _MOVIW('SYS_Sprite6_v3_64','sysFn')
        _MOVW(R8,'sysArgs0')
        LDW(R9);SYS(64)
        RET()

    module(name='sys_sprite6.s',
           code=[('EXPORT', 'SYS_Sprite6'),
                 ('CODE', 'SYS_Sprite6', code) ] )
    
    # ----------------------------------------
    # void* SYS_Sprite6x(void *srcpix, void *dst);
    def code():
        nohop()
        label('SYS_Sprite6x')
        _MOVIW('SYS_Sprite6x_v3_64','sysFn')
        _MOVW(R8,'sysArgs0')
        LDW(R9);SYS(64)
        RET()

    module(name='sys_sprite6x.s',
           code=[('EXPORT', 'SYS_Sprite6x'),
                 ('CODE', 'SYS_Sprite6x', code) ] )

    # ----------------------------------------
    # void* SYS_Sprite6y(void *srcpix, void *dst);
    def code():
        nohop()
        label('SYS_Sprite6y')
        _MOVIW('SYS_Sprite6y_v3_64','sysFn')
        _MOV(R8,'sysArgs0')
        LDW(R9);SYS(64)
        RET()

    module(name='sys_sprite6y.s',
           code=[('EXPORT', 'SYS_Sprite6y'),
                 ('CODE', 'SYS_Sprite6y', code) ] )

    # ----------------------------------------
    # void* SYS_Sprite6xy(void *srcpix, void *dst);
    def code():
        nohop()
        label('SYS_Sprite6xy')
        _MOVIW('SYS_Sprite6xy_v3_64','sysFn')
        _MOVW(R8,'sysArgs0')
        LDW(R9);SYS(64)
        RET()

    module(name='sys_sprite6xy.s',
           code=[('EXPORT', 'SYS_Sprite6xy'),
                 ('CODE', 'SYS_Sprite6xy', code) ] )

# execute    
scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:


def scope():

    def code_utwoa():
        '''Internal: _utwoa(int) converts a number in range 0..99 into two
           chars returned as the high and low part of vAC.'''
        nohop()
        label('_utwoa')
        _MOVIW(0x2f2f,R9)
        LDW(R8)
        label('.l1')
        INC(R9+1);SUBI(10);_BGE('.l1')
        ADDI(10)
        label('.l2')
        INC(R9);SUBI(1);_BGE('.l2')
        LDW(R9)
        RET()

    module(name='utwoa.s',
           code=[('EXPORT', '_utwoa'),
                 ('CODE', '_utwoa', code_utwoa)  ] )

    def code_asc():
        ''' T0:  (input) end of string
            T1:  (inout,preserved) start of string '''
        nohop()
        label('.d1')
        if args.cpu >= 7:
            ADDSV(-1,T0);PEEKV(T0)
        else:
            LDW(T0);SUBI(1);STW(T0);PEEK()
        ADDI(0x30);POKE(T0)
        SUBI(0x3a);_BLT('.d2')
        ADDI(0x61);POKE(T0)
        label('_itoa.asc')
        label('.d2')
        LDW(T0);XORW(T1);_BNE('.d1')
        LDW(T1)
        RET()

    def code_prep():
        nohop()
        label('_itoa.prep')
        if args.cpu >= 6:
            STW(R10);POKEQ(0);
            SUBI(1);STW(T1);POKEQ(0)
        else:
            STW(R10);SUBI(1);STW(T1)
            LDI(0);POKE(R10);POKE(T1)
        if args.cpu < 5:
            LDWI('_itoa.ddab');STW(R23)
        RET()

    def code_ddab1():
        ''' T0:   (input) end of string
            T1:   (inout) start of string (decremented)
            T4:   (input,preserved) base
            vAC:  (input) carry (0 or 1) '''
        nohop()
        label('_itoa.ddab1')
        ST(T5+1)
        label('.t0')
        LDW(T0);XORW(T1);_BEQ('.t1')
        LD(T5+1);STW(T5)
        LDW(T0);SUBI(1);STW(T0);PEEK()
        LSLW();ADDW(T5);POKE(T0)
        SUBW(T4);_BLT('.t0')
        POKE(T0);INC(T5+1);_BRA('.t0')
        label('.t1')
        LD(T5+1);_BEQ('.t2')
        LDW(T0);SUBI(1);STW(T1)
        LDI(1);POKE(T1)
        label('.t2')
        RET()

    def code_ddab_sys():
        ''' vAC: (input) binary number
            R10: (input,preserved) end of string
            T1:  (inout) start of string (decremented)
            T4:  (input,preserved) base
            R11/R12: (used)'''
        nohop()
        label('_itoa.ddab')
        info = rominfo['has_SYS_DoubleDabble']
        addr = int(str(info['addr']),0)
        cycs = int(str(info['cycs']),0)
        STW(R11)
        MOVQB(16,R12)
        MOVW(R10,T0)
        _MOVIW(addr,'sysFn')
        label('.s1')
        LDW(R11);ADDV(R11);SYS(cycs)
        DBNE(R12,'.s1')
        RET()

    def code_ddab_vcpu():
        ''' vAC: (input) binary number
            R10: (input,preserved) end of string
            T1:  (inout) start of string (decremented)
            T4:  (input,preserved) base
            R11/R12: (used)'''
        nohop()
        label('_itoa.ddab')
        PUSH()
        STW(R11)
        if args.cpu >= 6:
            MOVQB(16,R12)
        else:
            LDI(256-16);ST(R12)
        if args.cpu < 5:
            LDWI('_itoa.ddab1');STW(R22)
        label('.s1')
        _MOVW(R10,T0)
        LD(R11+1);ANDI(0x80);PEEK()
        if args.cpu < 5:
            CALL(R22)
        else:
            CALLI('_itoa.ddab1')
        if args.cpu >= 7:
            LDW(R11);ADDV(R11)
        else:
            LDW(R11);LSLW();STW(R11)
        if args.cpu >= 6:
            DBNE(R12, '.s1')
        else:
            INC(R12);LD(R12);_BNE('.s1')
        _MOVW(R10,T0)
        tryhop(2);POP();RET()

    if args.cpu >= 7 and 'has_SYS_DoubleDabble' in rominfo:
        module(name='itoa_subs.s',
               code=[('EXPORT', '_itoa.ddab'),
                     ('EXPORT', '_itoa.asc'),
                     ('EXPORT', '_itoa.prep'),
                     ('CODE', '_itoa.ddab', code_ddab_sys),
                     ('CODE', '_itoa.prep', code_prep),
                     ('CODE', '_itoa.asc', code_asc) ] )
    else:
        module(name='itoa_subs.s',
               code=[('EXPORT', '_itoa.ddab'),
                     ('EXPORT', '_itoa.asc'),
                     ('EXPORT', '_itoa.prep'),
                     ('CODE', '_itoa.ddab1', code_ddab1),
                     ('CODE', '_itoa.ddab', code_ddab_vcpu),
                     ('CODE', '_itoa.prep', code_prep),
                     ('CODE', '_itoa.asc', code_asc) ] )


    def code_utoa():
        '''char *utoa(unsigned int value, char *bufend, int radix)'''
        label('_utoa')
        PUSH()
        _MOVW(R10,T4)
        if args.cpu < 5:
            LDWI('_itoa.prep');STW(R23)
        LDW(R9)
        if args.cpu < 5:
            CALL(R23) # prep
            LDW(R8);CALL(R23) # ddab
        else:
            CALLI('_itoa.prep')
            LDW(R8);CALLI('_itoa.ddab')
        _CALLJ('_itoa.asc')
        tryhop(2);POP();RET()

    module(name='utoa.s',
           code=[('EXPORT', '_utoa'),
                 ('IMPORT', '_itoa.ddab'),
                 ('IMPORT', '_itoa.asc'),
                 ('IMPORT', '_itoa.prep'),
                 ('CODE', '_utoa', code_utoa)] )


    def code_ultoa():
        '''char *_ultoa(unsigned long value, char *bufend, int radix)'''
        nohop()
        label('_ultoa')
        PUSH()
        _MOVW(R11,T4)
        if args.cpu < 5:
            LDWI('_itoa.prep');STW(R23)
        LDW(R10)
        if args.cpu < 5:
            CALL(R23) # prep
            LDW(R9);CALL(R23)
            LDW(R8);CALL(R23)
        else:
            CALLI('_itoa.prep')
            LDW(R9);CALLI('_itoa.ddab')
            LDW(R8);CALLI('_itoa.ddab')
        _CALLJ('_itoa.asc')
        tryhop(2);POP();RET()

    module(name='ultoa.s',
           code=[('EXPORT', '_ultoa'),
                 ('IMPORT', '_itoa.ddab'),
                 ('IMPORT', '_itoa.asc'),
                 ('IMPORT', '_itoa.prep'),
                 ('CODE', '_ultoa', code_ultoa)] )


    def code_itoa():
        '''char *_itoa(int value, char *bufend, int radix)'''
        nohop()
        label('_itoa')
        if args.cpu >= 6:
            LDW(R8);JGE('_utoa')
            PUSH()
            NEGV(R8);CALLI('_utoa')
            SUBI(1);POKEQ(45)
            tryhop(2);POP();RET()
        else:
            PUSH();
            LDW(R8);_BLT('.neg')
            _CALLJ('_utoa')
            tryhop(2);POP();RET()
            label('.neg')
            LDI(0);SUBW(R8);STW(R8)
            _CALLJ('_utoa')
            SUBI(1);STW(R9)
            LDI(45);POKE(R9);LDW(R9)
            tryhop(2);POP();RET()

    module(name="itoa.s",
           code=[('EXPORT', '_itoa'),
                 ('IMPORT', '_utoa'),
                 ('CODE', '_itoa', code_itoa)] )


    def code_ltoa():
        '''char *_ltoa(long value, char buffer[16], int radix)'''
        nohop()
        label('_ltoa')
        if args.cpu >= 6:
            LDW(L8+2);JGE('_ultoa')
            PUSH()
            NEGVL(L8);CALLI('_ultoa')
            SUBI(1);POKEQ(45)
            tryhop(2);POP();RET()
        else:
            PUSH();
            LDW(L8+2);_BLT('.neg')
            _CALLJ('_ultoa')
            tryhop(2);POP();RET()
            label('.neg')
            LDI(0);SUBW(L8);STW(L8);_BEQ('.n1');LDWI(0xffff)
            label('.n1');SUBW(L8+2);STW(L8+2)
            _CALLJ('_ultoa')
            SUBI(1);STW(R9)
            LDI(45);POKE(R9);LDW(R9)
        tryhop(2);POP();RET()

    module(name="ltoa.s",
           code=[('EXPORT', '_ltoa'),
                 ('IMPORT', '_ultoa'),
                 ('CODE', '_ltoa', code_ltoa)] )


    def code_ftoa():
        ''' char *_ftoa(double *x, char *bufend)
            Return up to 10 digits representing the integer part of x.
            The final byte at address bufend will be either 0 or 0x80
            if the fractional part suggests rounding up. '''
        label('_ftoa')
        PUSH()
        LDW(R8);_MOVF([vAC],FAC)
        LDI(0);ST(FAS)
        _FTOU()
        # prep
        if args.cpu < 5:
            LDWI('_itoa.prep');STW(R23)
        _MOVIW(10,T4)
        LDW(R9)
        if args.cpu < 5:
            CALL(R23) # prep
            LDW(LAC+2);CALL(R23) # ddab
            LDW(LAC);CALL(R23) # ddab
        else:
            CALLI('_itoa.prep')
            LDW(LAC+2);CALLI('_itoa.ddab')
            LDW(LAC);CALLI('_itoa.ddab')
        LD(LAX);ANDI(0x80);POKE(R10)
        if args.cpu >= 6:
            POP();JGE('_itoa.asc')
        else:
            _CALLJ('_itoa.asc')
            tryhop(2);POP();RET()

    module(name='ftoa.s',
           code=[('EXPORT', '_ftoa'),
                 ('IMPORT', '_itoa.prep'),
                 ('IMPORT', '_itoa.ddab'),
                 ('IMPORT', '_itoa.asc'),
                 ('CODE', '_ftoa', code_ftoa) ] )

    def code_rnda():
        '''int _rnda(char *s, char *r);
           Truncate the string of digits <s> at position <r>.
           A zero termination will be written at position <r> and
           the string of digits will be rounded up if the prevous
           byte at position <r> was greater than or equal to '5'.
           Rounding may cause an extra digit to be preprended
           to the string, in which case the function returns 1.
           It returns zero otherwise. '''
        nohop()

        label('_rnda')
        _MOVIW(0x30,R11)
        _PEEKV(R9);SUBI(0x35);STW(R10);_BLT('.r0');INC(R11)
        label('.r0')
        LDI(0);POKE(R9)
        label('.r1')
        if args.cpu >= 7:
            LDW(R9);ADDSV(-1,R9)
        else:
            LDW(R9);SUBI(1);STW(R9);ADDI(1)
        XORW(R8);_BNE('.r2')
        LD(R11);POKE(R9);LDI(1);RET()
        label('.r2')
        LDW(R10);_BLT('.r3')
        LDW(R9);PEEK();ADDI(1);POKE(R9);SUBI(0x3a);_BLT('.r3')
        _MOVIW(0x31,R11)
        LDI(0x30);POKE(R9);_BRA('.r1')
        label('.r3')
        LDI(0);RET()

    module(name='rnda.s',
           code=[('EXPORT', '_rnda'),
                 ('CODE', '_rnda', code_rnda) ] )


scope()
# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def code0():
    nohop()
    label('labs')
    if args.cpu < 7:
        PUSH()
    _MOVL(L8,LAC)
    LDW(LAC+2);_BGE('.ret')
    _LNEG()
    label('.ret')
    if args.cpu < 7:
        tryhop(2);POP()
    RET()
    
code=[
    ('EXPORT', 'labs'),
    ('CODE', 'labs', code0) ]

module(code=code, name='abs.s');

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
	
def scope():

    def code0():
        nohop()
        label('ldexp')
        PUSH()
        _MOVF(F8, FAC)
        LDW(R11)
        _FSCALB()
        POP();RET()
        
    module(name='ldexp.s',
           code=[ ('EXPORT', 'ldexp'),
                  ('CODE', 'ldexp', code0) ] )

    def code0():
        nohop()
        label('frexp')
        PUSH()
        _MOVF(F8,FAC)
        _CALLJ('_@_frexp')
        DOKE(R11)
        POP();RET()

    module(name='frexp.s',
           code=[ ('EXPORT', 'frexp'),
                  ('IMPORT', '_@_frexp'),
                  ('CODE', 'frexp', code0) ] )
	
scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

# ldiv_t ldiv(long a, long q)

def code0():
    label('ldiv')
    PUSH();
    _MOVL(L9,LAC);LDI(L11);_LMODS()
    if args.cpu >= 6:
        LDW(R8);DOKEA(T0);ADDI(2);DOKEA(T1)
        ADDI(2);STLAC()
    else:
        # save quotient
        LDW(T0);DOKE(R8);
        LDI(2);ADDW(R8);STW(T3);LDW(T1);DOKE(T3);
        # save remainder
        LDI(4);ADDW(R8);STW(T3);LDW(LAC);DOKE(T3);
        LDI(6);ADDW(R8);STW(T3);LDW(LAC+2);DOKE(T3);
    # return
    tryhop(2);POP();RET()
    
# ======== (epilog)
code=[
    ('EXPORT', 'ldiv'),
    ('CODE', 'ldiv', code0),
    ('IMPORT', '_@_lmods') ]

module(code=code, name='ldiv.s');

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
	

def scope():

    # -- void *memchr(const void *s, int c0, size_t n)
    # -- void *__memchr2(const void *s, int c0c1, size_t n)
    # scan at most n bytes from s until finding one equal to c0 or c1
    # return pointer to the byte if found, 0 if not found.
    # known to leave R8/R9/R10 unchanged!!!
    def code1():
        nohop()
        label('memchr')
        LD(R9);ST(R9+1)
        label('__memchr2')                          # R8=d, R9=c0c1, R10=l
        LDW(R9);STW('sysArgs2')
        LDW(R8);STW('sysArgs0');ADDW(R10);STW(R12)
        if 'has_SYS_ScanMemory' in rominfo:
            info = rominfo['has_SYS_ScanMemory']
            addr = int(str(info['addr']),0)
            cycs = int(str(info['cycs']),0)
            _MOVIW(addr,'sysFn')
            label('.loop')
            LDW(R12);XORW('sysArgs0');_BEQ('.done')
            LD(vACH);_BNE('.s1')
            LDW(R12);SUBW('sysArgs0');_BLT('.s1')
            SYS(cycs);RET()
            label('.s1')
            LDI(0);SUBW('sysArgs0')
            SYS(cycs);INC('sysArgs1');_BEQ('.loop')
            label('.done')
            RET()
        else:
            LDW('sysArgs0')
            label('.loop')
            XORW(R12);_BEQ('.done')
            LDW('sysArgs0');PEEK();ST(vACH);XORW('sysArgs2');ST(R13)
            LD(vACH);_BEQ('.ok')
            LD(R13);_BEQ('.ok')
            LDI(1);ADDW('sysArgs0');STW('sysArgs0')
            _BRA('.loop')
            label('.ok')
            LDW('sysArgs0')
            label('.done')
            RET()

    module(name='memchr.s',
           code=[('EXPORT', 'memchr'),
                 ('EXPORT', '__memchr2'),
                 ('CODE', 'memchr', code1) ] )


    # -- void *_memchr2(const void *s, char c0, char c1, size_t n)
    def code2():
        nohop()
        label('_memchr2');
        LD(R10);ST(R9+1);_MOVW(R11,R10)
        if args.cpu >= 6:
            JNE('__memchr2')
        else:
            PUSH();_CALLJ('__memchr2');POP()
        RET()

    module(name='_memchr2.s',
           code=[('EXPORT', '_memchr2'),
                 ('IMPORT', '__memchr2'),
                 ('CODE', '_memchr2', code2) ] )

    
    # -- int strlen(const char *s)
    def code3():
        nohop()
        label('strlen')
        PUSH()
        LDI(0);STW(R9)
        SUBI(1);STW(R10)
        _CALLJ('__memchr2')  # preserve R8!
        SUBW(R8)
        tryhop(2);POP();RET();

    module(name='strlen.s',
           code=[('EXPORT', 'strlen'),
                 ('IMPORT', '__memchr2'),
                 ('CODE', 'strlen', code3) ] )

scope()


# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

# This variant uses only the COPY/COPYN opcodes. Requires cpu7.
# Peak rate is 10 bytes/scanline with little setup time.
def scope_copy_op():
    def code0():
        nohop()
        label('memcpy');                            # R8=d, R9=s, R10=l
        _MOVW(R8,T2)
        _MOVW(R9,T3)
        LDW(R10)
        label('memcpy1')
        COPY()
        label('memcpy2')
        JNE('memcpy1')
        RET()

    module(name='memcpy.s',
           code=[('EXPORT', 'memcpy'),
                 ('CODE', 'memcpy', code0) ])
    

# This longer but slightly faster variant uses SYS_CopyMemory.
# Peak rate is 12 bytes/scanline with substantial setup time.
def scope_syscopymemory():
    info = rominfo['has_SYS_CopyMemory']
    addr = int(str(info['addr']),0)
    cycs = int(str(info['cycs']),0)
    def code0():
        label('memcpy');                            # R8=d, R9=s, R10=l
        PUSH()
        LDWI(addr);STW('sysFn')
        LDW(R8);STW(R21);STW('sysArgs0')
        LDW(R9);STW('sysArgs2')
        label('.loop')
        LD(R21);STW(R20)
        LD(R9);SUBW(R20);_BLE('.memcpy1')
        LD(R9);STW(R20)
        label('.memcpy1')
        LDI(255);ST(R20+1)                          # R20 is minus count to page boundary
        LDW(R10);_BGT('.memcpy2')
        _BEQ('.done')                               # a) len is zero
        ADDW(R20);_BRA('.memcpy4')                  # b) len is larger than 0x8000
        label('.memcpy2')
        ADDW(R20);_BLE('.memcpy5')                  # c) len is smaller than -R20
        label('.memcpy4')
        STW(R10)                                    # d) len is larger than -R20
        LDI(0);SUBW(R20);STW(R20);SYS(cycs)
        LDW(R21);ADDW(R20);STW(R21);STW('sysArgs0')
        LDW(R9);ADDW(R20);STW(R9);STW('sysArgs2')
        _BRA('.loop')
        label('.memcpy5')
        LDW(R10);SYS(cycs)
        label('.done')
        LDW(R8);tryhop(2);POP();RET();
           
    module(name='memcpy.s',
           code=[('EXPORT', 'memcpy'),
                 ('CODE', 'memcpy', code0) ])
           

# This variant uses vCPU only
# Peak rate slightly above 1 byte/scanline.
def scope_vcpu():
           
    def code0():
        nohop()
        # copy without page crossings
        # takes destination ptr in sysArgs0/1
        # takes source ptr in sysArgs2/3
        # takes length in sysArgs4 (not vAC)
        label('_memcpy0')
        # single byte
        LD('sysArgs4');ANDI(1);_BEQ('.cpy2')
        LDW('sysArgs2');PEEK();POKE('sysArgs0')
        INC('sysArgs2');INC('sysArgs0')
        LD('sysArgs4');ANDI(0xfe);ST('sysArgs4');_BEQ('.cpydone')
        # even length
        label('.cpy2')
        label('.cpy2loop')
        LDW('sysArgs2');DEEK();DOKE('sysArgs0')
        INC('sysArgs2');INC('sysArgs0')
        INC('sysArgs2');INC('sysArgs0')
        LD('sysArgs4');SUBI(2);ST('sysArgs4');_BNE('.cpy2loop')
        label('.cpydone')
        RET()

    def code1():
        label('memcpy');                            # R8=d, R9=s, R10=l
        PUSH()
        LDW(R8);STW(R21);STW('sysArgs0')
        LDW(R9);STW('sysArgs2')
        label('.loop')
        LD(R8);STW(R20)
        LD(R9);SUBW(R20);_BLE('.memcpy1')
        LD(R9);STW(R20)
        label('.memcpy1')
        LDI(255);ST(R20+1)                          # R20 is minus count to page boundary
        LDW(R10);_BGT('.memcpy2')
        _BEQ('.done')                               # a) len is zero
        ADDW(R20);_BRA('.memcpy4')                  # b) len is larger than 0x8000
        label('.memcpy2')
        ADDW(R20);_BLE('.memcpy5')                  # c) len is smaller than -R20
        label('.memcpy4')
        STW(R10)                                    # d) len is larger than -R20
        LDI(0);SUBW(R20);STW(R20)
        STW('sysArgs4');_CALLJ('_memcpy0')
        LDW(R8);ADDW(R20);STW(R8);STW('sysArgs0')
        LDW(R9);ADDW(R20);STW(R9);STW('sysArgs2')
        _BRA('.loop')
        label('.memcpy5')
        LDW(R10);STW('sysArgs4');_CALLJ('_memcpy0')
        label('.done')
        LDW(R21);tryhop(2);POP();RET();

    module(name='memcpy.s',
           code=[('EXPORT', 'memcpy'),
                 ('CODE', '_memcpy0', code0),
                 ('CODE', 'memcpy', code1) ])

if args.cpu >= 7:
    scope_copy_op()
elif 'has_SYS_CopyMemory' in rominfo:
    scope_syscopymemory()
else:
    scope_vcpu()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():
    
    # memset(d,v,l)

    def code0():
        '''version that uses either FILL or Sys_SetMemory_v2_54'''
        nohop()
        label('memset');                            # R8=d, R9=v, R10=l
        LDW(R8);STW(T2);ADDW(R10);STW(R20)
        if args.cpu >= 7:
            LD(R9);STW(T3);_BRA('.test')
            label('.loop')
            LDI(0);SUBW(T2);MOVQB(1,vACH);FILL()
            MOVQB(0,T2);INC(T2+1)
            label('.test')
            LDW(T2);XORW(R20);_BEQ('.done')
            LD(vACH);_BNE('.loop')
            LDW(R20);SUBW(T2);INC(vACH);FILL()
        else:
            LD(R9);ST('sysArgs1')
            _MOVIW('SYS_SetMemory_v2_54','sysFn')
            _BRA('.test')
            label('.loop')
            LDI(0);SUBW(T2);ST('sysArgs0')
            LDI(0);ST(T2);INC(T2+1)
            SYS(54)
            label('.test')
            LDW(T2);STW('sysArgs2');XORW(R20);_BEQ('.done')
            LD(vACH);_BNE('.loop')
            LDW(R20);SUBW(T2);ST('sysArgs0')
            SYS(54)
        label('.done')
        LDW(R8);RET()


    return [('EXPORT', 'memset'),
            ('CODE', 'memset', code0) ]

module(code=scope(), name='memset.s');

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():

    def code0():
        nohop()
        label('raise')                       # void raise(int signo);
        _MOVIW(0,R9)
        label('_raisem')                     # void _raisem(int signo, const char *msg);
        LDW(R8);ANDI(0xf8);_BEQ('.raise1');
        _LDI(-1);RET()
        label('.raise1')
        _MOVW(R9,T0)                         # store message in T0 
        LDW(R8)
        label('__@raisem')                   # signo in vAC, msg in T0, vSP_v7 long aligned!
        STW(T1)                              # store signo in T1
        label('_raise_disposition', pc()+1)
        LDWI(0)
        _BEQ('.raise2')
        PUSH()             # warning vSP_v7 % 4 unknown
        CALL(vAC)          # dispatcher (no return)
        label('.raise2')
        _MOVIW(20,R8);
        _MOVW(T0,R9);      # saved message
        _CALLJ('_exitm')
        HALT()

    module(name='raise.s',
           code=[ ('IMPORT', '_exitm'),
                  ('EXPORT', 'raise'),
                  ('EXPORT', '_raisem'),
                  ('EXPORT', '__@raisem'),
                  ('EXPORT', '_raise_disposition'),
                  ('CODE', 'raise', code0) ] )

    def code1():
        nohop()
        label('_raise_sets_code')
        LDWI('_raise_code');STW(T2)
        LDW(T1);DOKE(T2)
        POP();RET()
        align(2);
        label('_raise_code')
        words(0)

    module(name='raise_sets_code.s',
           code=[ ('EXPORT', '_raise_sets_code'),
                  ('EXPORT', '_raise_code'),
                  ('CODE', '_raise_sets_code', code1) ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
	


# int setjmp(jmp_buf)

def code0():
    label('setjmp')
    tryhop(4);LDW(vLR);STW(R22)
    # save SP, vLR, vSP, R0-R7
    if args.cpu >= 6:
        LDW(R8);DOKEA(SP);ADDI(2);DOKEA(R22)
        ADDI(2);DOKEA(vSP);ADDI(2);STW(T2)
        MOVQW(R0,T3);COPYN(16)
    else:
        LDW(SP);DOKE(R8);LDI(2);ADDW(R8);STW(R8)
        LDW(R22);DOKE(R8);LDI(2);ADDW(R8);STW(R8)
        LDW(vSP);DOKE(R8);LDI(2);ADDW(R8);STW(R8)
        LDI(R0);STW(T3);LDW(R8);STW(T2);LDI(R8);STW(T1);_CALLJ('_@_wcopy')
    # return 0
    LDW(R22);tryhop(5);STW(vLR);LDI(0);RET()

# void longjmp(jmp_buf, int)

def code1():
    label('longjmp')
    # restore SP, R22, R0-R7
    if args.cpu >= 6:
        LDW(R8);DEEKA(SP);ADDI(2);DEEKA(R22)
        if vSP != SP:
            ADDI(2);DEEK()
            STW(vSP) if args.cpu >= 7 else ST(vSP)
    else:
        LDW(R8);DEEK();STW(SP)
        LDI(2);ADDW(R8);DEEK();STW(R22);
        LDI(4);ADDW(R8);DEEK();ST(vSP);
    LDI(6);ADDW(R8);STW(T3)
    if args.cpu >= 6:
        MOVQW(R0,T2);COPYN(16)
    else:
        ADDI(16);STW(T1);LDI(R0);STW(T2);_CALLJ('_@_wcopy')
    # return R9
    LDW(R22);tryhop(5);STW(vLR);LDW(R9);RET()
    
module(name='setjmp.s',
       code=[ ('EXPORT', 'setjmp'),
              ('EXPORT', 'longjmp'),
              ('IMPORT', '_@_wcopy') if args.cpu < 6 else ('NOP',),
              ('CODE', 'setjmp', code0),
              ('CODE', 'longjmp', code1) ])

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
def scope():

    # LCOPY [T3..T3+3] --> [T2..]
    # -- Copy an even-aligned long. Trashes T[1-3].
    #    The COPYN alternative also uses sysArgs[2-7].

    def code1():
        nohop()
        if args.cpu >= 6:
            warning("cpu6: use COPYN instead of calling _@_lcopy")
        label('_@_lcopy')
        LDW(T3);DEEK();DOKE(T2)
        LDI(2);ADDW(T2);STW(T2)
        LDI(2);ADDW(T3);DEEK();DOKE(T2)
        RET()

    module(name='rt_lcopy.s',
           code=[ ('EXPORT', '_@_lcopy'),
                  ('CODE', '_@_lcopy', code1) ] )

    # FCOPYZ LCOPYZ: [vACL..] --> [vACH..]
    # -- Zero page copy for floats and longs withing page zero
    #    with a short call sequence LDWI(<dst><src>);CALLI(..)
    #    Trashes T[2-3]. The MOVF/MOVL alternatives use sysArgs
    #    but we use T[2-3] to share code with FCOPYNC.

    # FCOPYNC: [T3..T3+4] --> [T2..]
    # -- Float copy when no page crossings. Trashes T[2-3].
    #    The COPYN alternatives also trashes sysArgs[2-7].

    def code2():
        nohop()
        if args.cpu >= 6:
            warning("cpu6: use MOVL/MOVF instead of _@_fcopyz/_@_lcopyz")
        label('_@_fcopync')
        LDW(T3)
        BRA('.cont5')
        label('_@_fcopyz')
        ST(T3);LD(vACH);STW(T2)
        LD(T3);STW(T3)
        label('.cont5')
        PEEK();POKE(T2)
        INC(T2);INC(T3);LDW(T3)
        BRA('.cont4')
        label('_@_lcopyz')
        ST(T3);LD(vACH);STW(T2)
        LD(T3);STW(T3)
        label('.cont4')
        DEEK();DOKE(T2)
        INC(T2);INC(T2)
        INC(T3);INC(T3);LDW(T3)
        DEEK();DOKE(T2)
        RET()

    module(name='rt_copyz.s',
           code=[ ('EXPORT', '_@_lcopyz'),
                  ('EXPORT', '_@_fcopyz'),
                  ('EXPORT', '_@_fcopync'),
                  ('CODE', '_@_fcopyz', code2) ])


    # FCOPY [T3..T3+5) --> [T2..T2+5)
    # BCOPY [T3..T1) --> [T2..]
    # -- Copy a float or a structure byte per byte. Trashes T[1-3].
    #    The COPYN alternative also trashes sysArgs[2-7]

    def code3():
        nohop()
        if args.cpu >= 6:
            warning("cpu6: use COPYN instead of _@_fcopy/_@_bcopy")
        label('_@_fcopy')
        LDI(5);ADDW(T3);STW(T1)
        label('_@_bcopy')
        _PEEKV(T3);POKE(T2)
        LDI(1);ADDW(T2);STW(T2)
        LDI(1);ADDW(T3);STW(T3)
        XORW(T1);_BNE('_@_bcopy')
        RET()

    module(name='rt_bcopy.s',
           code=[ ('EXPORT', '_@_bcopy'),
                  ('EXPORT', '_@_fcopy'),
                  ('CODE', '_@_bcopy', code3) ])

    # WCOPY [T3..T1) --> [T2..]
    # -- Copy a structure word by word. Trashes T[1-3].
    #    The COPYN alternative also trashes sysArgs[2-7]
    def code4():
        nohop()
        if args.cpu >= 6:
            warning("cpu6: use COPYN instead of _@_wcopy")
        label('_@_wcopy')
        _DEEKV(T3);DOKE(T2)
        LDI(2);ADDW(T2);STW(T2)
        LDI(2);ADDW(T3);STW(T3)
        XORW(T1);_BNE('_@_wcopy')
        RET()

    module(name='rt_wcopy.s',
           code=[ ('EXPORT', '_@_wcopy'),
                  ('CODE', '_@_wcopy', code4) ])

    # LEXTS: (vAC<0) ? -1 : 0 --> vAC
    def code5():
        nohop()
        label('_@_lexts')
        if args.cpu >= 7:
            LDSB(vACH);LDSB(vACH)
            RET()
        else:
            _BLT('.m1')
            LDI(0);RET();
            label('.m1')
            _LDI(-1);RET()

    module(name='rt_lexts.s',
           code=[ ('EXPORT', '_@_lexts'),
                  ('CODE', '_@_lexts', code5) ])

    # The following are merely markers indicating that _MOVL or _MOVF
    # is used somewhere. These are useful to decide whether to import
    # printf support for longs or floats.

    def code_dummy():
        label('_@_using_lmov', 1)

    module(name='rt_lmov',
           code=[('EXPORT', '_@_using_lmov'),
                 ('DATA', '_@_using_lmov', code_dummy, 0, 1) ] )

    def code_dummy():
        label('_@_using_fmov', 1)

    module(name='rt_fmov',
           code=[('EXPORT', '_@_using_fmov'),
                 ('DATA', '_@_using_fmov', code_dummy, 0, 1) ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
def scope():

    XV = v('sysArgs0'); YV = v('sysArgs2')
    RV = v('sysArgs4'); MV = v('sysArgs6')
    assert YV != T3
    assert XV != T3

    if 'has_SYS_Divide_u16' in rominfo:
        # Divide using SYS call
        morecode = []
        needbig = False
        info = rominfo['has_SYS_Divide_u16']
        addr = int(str(info['addr']),0)
        cycs = int(str(info['cycs']),0)
        def CallWorker():
            _LDI(addr);STW('sysFn');SYS(cycs)

    elif 'has_at67_SYS_Divide_s16' in rominfo:
        # Divide using SYS call
        morecode = []
        needbig = True
        info = rominfo['has_at67_SYS_Divide_s16']
        addr = int(str(info['addr']),0)
        cycs = int(str(info['cycs']),0)
        def CallWorker():
            LDI(0);STW(RV)
            LDI(1);STW(MV)
            _LDI(addr);STW('sysFn');SYS(cycs)

    elif args.cpu < 7:
        # Divide using vCPU
        needbig = True
        morecode = [('IMPORT', '__@divworker')]
        def code0():
            nohop()
            label('__@divworker')
            LDI(0);STW(RV);ST(MV)
            label('.div0')
            LDW(XV);_BGE('.div1')
            LSLW();STW(XV);
            LDW(RV);LSLW();ORI(1);_BRA('.div2')
            label('.div1')
            LSLW();STW(XV);
            LDW(RV);LSLW()
            label('.div2')
            STW(RV);SUBW(YV);_BLT('.div3')
            STW(RV);INC(XV)
            label('.div3')
            INC(MV);LD(MV);XORI(16);_BNE('.div0')
            RET()
        module(name='rt_divworker.s',
               code=[ ('CODE', '__@divworker', code0),
                      ('EXPORT', '__@divworker') ] )
        def CallWorker():
            _CALLJ('__@divworker')


    # ----------------------------------------
    # DIVU: T3/vAC -> vAC
    # ----------------------------------------

    def code2():
        """ Computes unsigned T3/vAC into vAC.
            May raise zdiv signal.
            Trashes sysArgs[0-7], T[013]. """
        label('_@_divu')
        if args.cpu >= 7:
            nohop()
            JEQ('_@_raise_zdiv_nopop')       # divide by zero error
            RDIVU(T3)
            RET()
        else:
            PUSH()
            if args.cpu >= 6:
                JEQ('_@_raise_zdiv')         # divide by zero error
            else:
                _BNE('.divu1')
                _CALLJ('_@_raise_zdiv')      # divide by zero error
                label('.divu1')
            STW(YV)
            if needbig:
                _BLT('.bigy')
            LDW(T3);STW(XV)
            if needbig:
                _BLT('.bigx')
            label('.divu2')
            CallWorker()
            if needbig:
                LDW(XV)
            tryhop(2);POP();RET()
        # special cases
        if needbig:
            label('.bigx')                          # x >= 0x8000
            LD(YV+1);ANDI(0x40);_BEQ('.divu2')      # - but y is small enough
            label('.bigy')                          # y large
            LDI(0);STW(MV)                          # - repeated subtractions
            assert MV != T3
            LDW(T3);STW(XV)
            BRA('.loop1')
            label('.loop0')                         #   (loops at most 3 times)
            INC(MV)
            LDW(XV);SUBW(YV);STW(XV)
            label('.loop1')
            _CMPWU(YV);_BGE('.loop0')
            LDW(XV);STW(RV)                         # - for modu
            LD(MV)
            tryhop(2);POP();RET()

    module(name='rt_divu.s',
           code=[ ('CODE', '_@_divu', code2),
                  ('IMPORT', '_@_raise_zdiv_nopop') if args.cpu >= 7 else ('NOP',),
                  ('IMPORT', '_@_raise_zdiv') if args.cpu < 7 else ('NOP',),
                  ('EXPORT', '_@_divu') ] + morecode )


    # ----------------------------------------
    # MODU: T3 % vAC -> vAC, T3 / vAC in T1
    # ----------------------------------------

    assert(RV != T1)

    def code2():
        """ Computes unsigned T3%vAC into vAC. Saves quotient in T1
            May raise zdiv signal. Trashes sysArgs[0-7], T[013]. """
        label('_@_modu')
        nohop()
        if args.cpu >= 7:
            JEQ('_@_raise_zdiv_nopop')
            RDIVU(T3)
        else:
            PUSH()
            _CALLI('_@_divu')
            tryhop(6);POP();
        STW(T1)         # quotient
        LDW(RV)         # remainder
        RET()

    module(name='rt_modu.s',
           code=[ ('CODE', '_@_modu', code2),
                  ('EXPORT', '_@_modu'),
                  ('IMPORT', '_@_raise_zdiv_nopop') if args.cpu >= 7 else ('NOP',),
                  ('IMPORT', '_@_divu') if args.cpu < 7 else ('NOP',)
                 ] )

    # ----------------------------------------
    # DIVS:  T3/vAC -> vAC
    # ----------------------------------------

    assert YV != T3

    def code2():
        """ Computes signed T3/vAC into vAC.
            May raise zdiv signal. Trashes sysArgs[0-7], T[0123]. """
        label('_@_divs')
        if args.cpu >= 7:
            nohop()
            JEQ('_@_raise_zdiv_nopop')       # divide by zero error
            RDIVS(T3)
            RET()
        else:
            PUSH()
            if args.cpu >= 6:
                JEQ('_@_raise_zdiv')         # divide by zero error
            else:
                _BNE('.divs0')
                _CALLJ('_@_raise_zdiv')      # divide by zero error
                label('.divs0')
            STW(YV)
            if args.cpu >= 6:
                MOVQB(0,T2)
                _BGT('.divs1')
                NEGV(YV);INC(T2)
                label('.divs1')
                LDW(T3);STW(XV);_BGE('.divs2')
                NEGV(XV)
            else:
                LDI(0);ST(T2)
                LDW(YV);_BGT('.divs1')
                LDI(0);SUBW(YV);STW(YV);INC(T2)
                label('.divs1')
                LDW(T3);STW(XV);_BGE('.divs2')
                LDI(0);SUBW(T3);STW(XV)
            LD(T2);XORI(3);ST(T2)
            label('.divs2')
            CallWorker()
            LD(T2);ANDI(2);_BEQ('.divs3')
            if args.cpu >= 6:
                NEGV(RV)
            else:
                LDI(0);SUBW(RV);STW(RV)
            label('.divs3')
            LD(T2);ANDI(1);_BEQ('.divs4')
            if args.cpu >= 6:
                NEGV(XV)
            else:
                LDI(0);SUBW(XV);STW(XV)
            label('.divs4')
            LDW(XV)
            tryhop(2);POP();RET()

    module(name='rt_divs.s',
           code=[ ('CODE', '_@_divs', code2),
                  ('IMPORT', '_@_raise_zdiv_nopop') if args.cpu >= 7 else ('NOP',),
                  ('IMPORT', '_@_raise_zdiv') if args.cpu < 7 else ('NOP',),
                  ('EXPORT', '_@_divs') ] + morecode )

    # ----------------------------------------
    # MODS: T3 % vAC -> AC  T3 / vAC -> T1
    # ----------------------------------------

    assert RV != T1

    def code2():
        label('_@_mods')
        """ Computes signed T3%vAC into vAC. Saves quotient in T1
            May raise zdiv signal. Trashes sysArgs[0-7], T[0123]. """
        if args.cpu >= 7:
            JEQ('_@_raise_zdiv_nopop')
            RDIVS(T3)
        else:
            PUSH()
            _CALLI('_@_divs')
            tryhop(6);POP();
        STW(T1)         # quotient
        LDW(RV)         # remainder
        RET()

    module(name='rt_mods.s',
           code=[ ('CODE', '_@_mods', code2),
                  ('EXPORT', '_@_mods'),
                  ('IMPORT', '_@_raise_zdiv_nopop') if args.cpu >= 7 else ('NOP',),
                  ('IMPORT', '_@_divs') if args.cpu < 7 else ('NOP',)
                 ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
# Floating point routines
# using the Microsoft Floating Point format (5 bytes)
#
#  EEEEEEEE SAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD
#  =  (-1)^S * 2^(EEEEEEEE-128) * 0.1AAAAAAABBBBBBBBCCCCCCCCDDDDDDDD (base 2)
#  = 0 when EEEEEEEE is zero
#
# The floating point routines operate on a floating point accumulator
# FAC whose mantissa overlaps the extended and long accumulator LAC/LAC
# Register FAC is composed of a sign byte AS, an exponent byte AE and
# and a 40 bits mantissa AM. The routines internally use a second register
# FARG whose exponent BE and mantissa BM overlap T0/T1/sysArgs[0-4].
# Bit 7 of AS indicates whether FAC is negative. Bit 1 indicates
# whether FAC and FARG have different signs. The exponent AE (resp BE)
# is 0 when FAC (resp FARG) is zero and and equal to EEEEEEEE otherwise.

def scope():

    AS = FAS      # FAC sign (bit7) FARG sign (bit7^bit1)
    AE = FAE      # FAC exponent
    AM = LAX      # 40 bits FAC mantissa    (aka LAX)
    BM = T0       # 40 bits FARG mantissa   (aka sysArgs[0..4], T0-T1)
    BE = T2       # FARG exponent           (overlaps T2 CM)
    CM = T2       # extra 32 bits register  (overlaps T2-T3)

    # naming convention for exported symbols
    # '_@_xxxx' are the public api.  See their docstrings below.
    # '__@xxxx' are private and should not be relied upon.

    avoid_cmpw = (args.cpu <= 4) or ("without_CmpOps" in rominfo)

    # ==== common things

    def code_fexception():
        '''All exceptions call _@_raise_ferr or _@_raise_fovf which are defined
           in the C library proper. If these functions return, what they leave in FAC
           is returned by the API function (or more precisely by whathever
           function called __@savevsp).'''
        nohop()
        label('__@fexception')   ### SIGFPE/exception
        _CALLJ('__@frestorevsp')
        _CALLJ('_@_raise_ferr')
        label('__@foverflow')    ### SIGFPE/overflow
        _CALLJ('__@frestorevsp')
        _LDI(0xffff);STW(AM+1);STW(AM+3);ST(AE);_MOVIB(0,AM)
        _CALLJ('_@_raise_fovf')

    def code_fsavevsp():
        nohop()
        label('__@fsavevsp')
        if args.cpu >= 6:
            LDWI('.vspfpe');DOKEA(vSP);RET()
        else:
            LDWI('.vspfpe');STW(T2)
            LDW(vSP);DOKE(T2);RET()
        label('__@frestorevsp')
        label('.vspfpe',pc()+1)
        LDWI(0)  # this instruction is patched by fsavevsp.
        if args.cpu >= 7:
            STW(vSP)
        else:
            ST(vSP)
        RET()

    module(name='rt_fexception.s',
           code=[ ('IMPORT', '_@_raise_ferr'),
                  ('IMPORT', '_@_raise_fovf'),
                  ('EXPORT', '__@fexception'),
                  ('EXPORT', '__@foverflow'),
                  ('EXPORT', '__@fsavevsp'),
                  ('EXPORT', '__@frestorevsp'),
                  ('CODE', '__@fexception', code_fexception),
                  ('CODE', '__@fsavevsp', code_fsavevsp) ] )

    def code_clrfac():
        '''_@_clrfac: -- Set FAC to zero
           _@_rndfac: -- Round FAC to 32 bit mantissa.'''
        nohop()
        label('_@_clrfac')
        LDI(0);STW(AE)        # [AE,AM]
        STW(AM+1);STW(AM+3)   # [AM+1,AM+2] [AM+3,AM+4]
        RET()
        ## Round fac
        label('_@_rndfac')
        LD(AE);_BEQ('_@_clrfac')
        LDW(AM-1);_BGE('.rnd0')
        if args.cpu >= 6:
            INCVL(AM+1);LDW(AM+3);_BNE('.rnd0')
        else:
            LDI(1);ADDW(AM+1);STW(AM+1);_BNE('.rnd0')
            LDI(1);ADDW(AM+3);STW(AM+3);_BNE('.rnd0')
        _MOVIB(128,AM+4);INC(AE);LD(AE);_BNE('.rnd0')
        SUBI(1);STW(AM+1);STW(AM+3);ST(AE) # overflow
        label('.rnd0')
        _MOVIB(0,AM)
        RET()

    module(name='rt_rndfac.s',
           code=[ ('EXPORT', '_@_rndfac'),
                  ('EXPORT', '_@_clrfac'),
                  ('CODE', '_@_clrfac', code_clrfac) ] )

    # ==== Load/store

    def code_fldfac():
        '''_@_fldfac: Load the float at address vAC into FAC: [vAC]->FAC'''
        nohop()
        if args.cpu >= 7:
            label('__@fldfac_t3')
            LDW(T3)
            label('_@_fldfac')
            LDFAC()
            RET()
            warning("cpu7: use LDFAC instead of _@_fldfac")
        elif args.cpu >= 6:
            label('_@_fldfac')
            STW(T3)
            label('__@fldfac_t3')
            MOVQB(0,AM)
            PEEKV(T3);ST(AE);_BEQ('.fldz')
            INCV(T3);PEEKV(T3);ST(vACH);ORI(0x80);ST(AM+4)
            XORW(AS-1);_BGE('.fld1')
            LD(AS);XORI(0x81);ST(AS)
            label('.fld1')
            INCV(T3);PEEKV(T3);ST(AM+3)
            INCV(T3);PEEKV(T3);ST(AM+2)
            INCV(T3);PEEKV(T3);ST(AM+1)
            RET()
            label('.fldz')
            STW(AM+1);STW(AM+2);RET()
        else:
            label('_@_fldfac')
            STW(T3)
            label('__@fldfac_t3')
            LDI(0);ST(AM)
            LDW(T3);PEEK();ST(AE);_BEQ('.fldz')
            LDI(4);ADDW(T3);PEEK();ST(AM+1)
            LDI(3);ADDW(T3);PEEK();ST(AM+2)
            LDI(2);ADDW(T3);PEEK();ST(AM+3)
            LDI(1);ADDW(T3);PEEK();ST(vACH);ORI(0x80);ST(AM+4)
            XORW(AS-1);_BGE('.fld1')
            LD(AS);XORI(0x81);ST(AS)
            label('.fld1')
            RET()
            label('.fldz')
            STW(AM+1);STW(AM+2);RET()

    module(name='rt_fldfac.s',
           code=[ ('EXPORT', '_@_fldfac'),
                  ('EXPORT', '__@fldfac_t3'),
                  ('CODE', '_@_fldfac', code_fldfac) ] )

    def code_fldarg():
        # [vAC]->FARG
        nohop()
        if args.cpu >= 7:
            label('__@fldarg_t3')
            LDW(T3)
            label('__@fldarg')
            LDFARG()
            MOVQB(0, BE+1)
            RET()
            warning("cpu7: use LDFARG instead of __@fldarg")
        elif args.cpu >= 6:
            label('__@fldarg')
            STW(T3)
            label('__@fldarg_t3')
            MOVQB(0,BM);
            PEEKV(T3);STW(BE);_BEQ('.fldz')
            INCV(T3);PEEKV(T3);ST(vACH);ORI(0x80);ST(BM+4)
            XORW(AS-1);_BGE('.fldp')
            LD(AS);ORI(1);_BRA('.fldc')
            label('.fldp')
            LD(AS);ANDI(0xfe)
            label('.fldc')
            ST(AS)
            INCV(T3);PEEKV(T3);ST(BM+3)
            INCV(T3);PEEKV(T3);ST(BM+2)
            INCV(T3);PEEKV(T3);ST(BM+1)
            RET()
            label('.fldz')
            STW(BM+1);STW(BM+2);RET()
        else:
            label('__@fldarg')
            STW(T3)
            label('__@fldarg_t3')
            LDI(0);ST(BM)
            LDW(T3);PEEK();STW(BE);_BEQ('.fldz')
            LDI(4);ADDW(T3);PEEK();ST(BM+1)
            LDI(3);ADDW(T3);PEEK();ST(BM+2)
            LDI(2);ADDW(T3);PEEK();ST(BM+3)
            LDI(1);ADDW(T3);PEEK();ST(vACH);ORI(0x80);ST(BM+4)
            XORW(AS-1);_BGE('.fldp')
            LD(AS);ORI(1);ST(AS);RET()
            label('.fldz')
            STW(BM+1);STW(BM+2)
            label('.fldp')
            LD(AS);ANDI(0xfe);ST(AS);RET()

    module(name='rt_fldarg.s',
           code=[ ('EXPORT', '__@fldarg'),
                  ('EXPORT', '__@fldarg_t3'),
                  ('CODE', '__@fldarg', code_fldarg) ] )

    def code_fstfac():
        '''_@_fstfac: Store FAC at address vAC: FAC->[vAC]'''
        nohop()
        label('_@_fstfac')
        if args.cpu >= 7:
            STFAC()
            warning("cpu7: use STFAC instead of _@_fstfac")
        elif args.cpu >= 6:
            STW(T3);LD(AE);POKE(T3);_BNE('.fst1')
            STW(AM+1);STW(AM+3)
            label('.fst1')
            LD(AS);ORI(0x7f);ANDW(AM+4);INCV(T3);POKE(T3)
            LD(AM+3);INCV(T3);POKE(T3)
            LD(AM+2);INCV(T3);POKE(T3)
            LD(AM+1);INCV(T3);POKE(T3)
            RET()
        else:
            STW(T3);LD(AE);POKE(T3);_BNE('.fst1')
            STW(AM+1);STW(AM+3)
            label('.fst1')
            LDI(1);ADDW(T3);STW(T3);LD(AS);ORI(0x7f);ANDW(AM+4);POKE(T3)
            LDI(1);ADDW(T3);STW(T3);LD(AM+3);POKE(T3)
            LDI(1);ADDW(T3);STW(T3);LD(AM+2);POKE(T3)
            LDI(1);ADDW(T3);STW(T3);LD(AM+1);POKE(T3)
            RET()

    module(name = 'rt_fstfac.s',
           code = [ ('EXPORT', '_@_fstfac'),
                    ('IMPORT', '_@_clrfac'),
                    ('CODE', '_@_fstfac', code_fstfac) ] )

    def code_fac2farg():
        # Copy FAC to FARG
        nohop()
        label('__@fac2farg')
        LD(AE);STW(BE)
        LD(AS);ANDI(0xfe);ST(AS)
        # Copy AM to BM
        label('__@am2bm40')
        if args.cpu >= 6:
            MOVF(AM,BM)
        else:
            LD(AM);ST(BM)
            label('__@am2bm32')
            LDW(AM+1);STW(BM+1)
            LDW(AM+3);STW(BM+3)
        RET()

    module(name='rt_fac2farg.s',
           code=[ ('EXPORT', '__@fac2farg'),
                  ('EXPORT', '__@am2bm40'),
                  ('EXPORT', '__@am2bm32'),
                  ('CODE', '_@fac2farg', code_fac2farg) ] )

    # ==== shift left

    def code_amshl1():
        nohop()
        label('__@amshl1')
        if args.cpu >= 7:
            warning('cpu7: use LSLXA instead of __@amshl1')
            LDI(1);LSLXA()
        elif args.cpu >= 6:
            LSLVL(AM+1)
            LD(AM);ADDW(AM);STW(AM)
        else:
            LDW(AM+3);LSLW();STW(AM+3);
            LDW(AM+1);_BGE('.amshl1b');INC(AM+3)
            label('.amshl1b')
            LSLW();STW(AM+1)
            LD(AM);ADDW(AM);STW(AM)
        RET()

    module(name='rt_amshl1.s',
           code=[ ('EXPORT', '__@amshl1'),
                  ('CODE', '__@amshl1', code_amshl1) ] )

    def code_cmshl1():
        nohop()
        label('__@cmshl1')
        if args.cpu >= 6:
            warning('cpu6: use LSLVL instead of __@cmshl1')
            LSLVL(CM)
        else:
            LDW(CM+2);LSLW();STW(CM+2)
            LDW(CM);_BGE('.cmshl1b');INC(CM+2)
            label('.cmshl1b')
            LSLW();STW(CM)
        RET()

    module(name='rt_cmshl1.s',
           code=[ ('EXPORT', '__@cmshl1'),
                  ('CODE', '__@cmshl1', code_cmshl1) ] )


    # ==== shift right

    def code_amshr8():
        nohop()
        label('__@amshr8')
        LDW(AM+1);STW(AM);
        LDW(AM+3);STW(AM+2)
        _MOVIB(0,AM+4)
        RET()

    module(name='rt_amshr8.s',
           code=[ ('EXPORT', '__@amshr8'),
                  ('CODE', '__@amshr8', code_amshr8) ] )

    def code_amshra():
        # shift am right by vAC positions
        nohop()
        label('__@amshra')
        SUBI(40);_BLT('.shra1')
        LDI(0);ST(AM);STW(AM+1);STW(AM+3);RET()
        label('.shra1')
        if args.cpu >= 7:
            ADDI(40);LSRXA()
            RET()
        else:
            PUSH();
            ADDI(40-8);_BRA('.shra3')
            label('.shra2')
            _CALLJ('__@amshr8')
            LD(T5);SUBI(8)
            label('.shra3')
            ST(T5);_BGE('.shra2')
            if args.cpu < 5:
                LDWI('__@shrsysfn');STW('sysFn')
            LD(T5);ANDI(7);_BNE('.shra4')
            POP();RET()
            label('.shra4')
            if args.cpu < 5:
                CALL('sysFn')
            else:
                CALLI('__@shrsysfn')
            POP()
            label('__@amshrx')
            LDW(AM);SYS(52);ST(AM)
            LDW(AM+1);SYS(52);ST(AM+1)
            LDW(AM+2);SYS(52);ST(AM+2)
            LDW(AM+3);SYS(52);STW(AM+3)
            RET()

    module(name='rt_amshra.s',
           code=[ ('EXPORT', '__@amshra'),
                  ('EXPORT', '__@amshrx'),
                  ('IMPORT', '__@shrsysfn') if args.cpu < 7 else ('NOP',),
                  ('IMPORT', '__@amshr8') if args.cpu < 7 else ('NOP',),
                  ('CODE', '__@amshra', code_amshra) ] )

    # ==== two complement

    def code_amneg():
        nohop()
        label('__@amneg')
        if args.cpu >= 7:
            warning("cpu7: use NEGX instead of __@amneg")
            NEGX()
        else:
            LDI(0);SUBW(AM);STW(AM);_BNE('.amneg2')
            SUBW(AM+2);STW(AM+2);_BNE('.amneg4')
            SUBW(AM+4);ST(AM+4)
            RET()
            label('.amneg2')
            _LDI(0xffff);XORW(AM+2);STW(AM+2)
            label('.amneg4')
            LD(AM+4);XORI(0xff);ST(AM+4)
            RET()

    module(name='rt_amneg.s',
           code=[ ('EXPORT', '__@amneg'),
                  ('CODE', '__@amneg', code_amneg) ])


    # ==== normalization

    def code_fnorm():
        # Normalize FAC
        nohop()
        label('__@fnorm')
        LDW(AM+3);_BLT('.ret')
        if args.cpu >= 7:
            MOVQW(0,T3);_BNE('.norm1a') # known >=0
            ADDSV(16,T3);LDW(AM+1);_BNE('.norm1b')
            ADDSV(16,T3);LD(AM);ST(vACH);_BNE('.norm1b')
            JEQ('_@_clrfac')
            label('.norm1a')
            LSLW();INC(T3)
            label('.norm1b')
            _BGE('.norm1a')
            LD(AE);SUBW(T3);JLT('_@_clrfac');ST(AE)
            LD(T3);LSLXA();
        else:
            PUSH();_BNE('.norm1')
            LD(AM);ORW(AM+1);_BEQ('.normz')
            label('.norm1')
            LD(AM+4);_BNE('.norm3')
            LD(AE);SUBI(8);_BLT('.normz');ST(AE)
            LDW(AM+2);STW(AM+3);LDW(AM);STW(AM+1);_MOVIB(0,AM)
            _BRA('.norm1')
            label('.norm2')
            LD(AE);SUBI(1);_BLT('.normz');ST(AE)
            _CALLJ('__@amshl1')
            label('.norm3')
            LDW(AM+3);_BGE('.norm2')
            tryhop(2);POP();RET()
            label('.normz')
            _CALLJ('_@_clrfac')
            tryhop(2);POP()
        label('.ret')
        RET()

    module(name='rt_fnorm.s',
           code=[ ('EXPORT', '__@fnorm'),
                  ('CODE', '__@fnorm', code_fnorm),
                  ('IMPORT', '_@_clrfac'),
                  ('IMPORT', '__@amshl1') if args.cpu < 7 else ('NOP',) ] )


    # ==== conversions

    def code_fcv():
        '''_@_fcvu: Loads FAC with the unsigned long LAC.
           _@_fcvi: Loads FAC with the signed long LAC.'''
        nohop()
        label('_@_fcvu')
        PUSH()
        LDI(0);ST(AM);ST(AS);_BRA('.fcv1')
        label('_@_fcvi')
        PUSH()
        _MOVIB(0,AM)
        LD(AM+4);ANDI(128);STW(AS);_BEQ('.fcv1')
        if args.cpu >= 7:
            NEGVL(AM+1)
        else:
            _CALLJ('__@amneg')
        label('.fcv1')
        _LDI(160);ST(AE)
        if args.cpu >= 6:
            tryhop(4);POP();JNE('__@fnorm')
        else:
            _CALLJ('__@fnorm')
            tryhop(2);POP();RET()

    module(name='rt_fcv.s',
           code=[ ('EXPORT', '_@_fcvi'),
                  ('EXPORT', '_@_fcvu'),
                  ('IMPORT', '__@fnorm'),
                  ('IMPORT', '__@amneg') if args.cpu < 7 else ('NOP',),
                  ('CODE', '_@_fcvi', code_fcv) ] )

    def code_ftoi():
        '''_@_ftoi: Convert FAC into a signed long in LAC.
           _@_ftou: Convert FAC into an unsigned long in LAC.
           Both return 0x80000000 on overflow.'''
        nohop()
        label('_@_ftoi')
        PUSH()
        LD(AE);SUBI(160);_BLT('.ok')
        label('.ovf')
        _CALLJ('_@_clrfac')
        LDI(128);ST(LAC+3)
        tryhop(2);POP();RET()
        label('_@_ftou')
        PUSH()
        LD(AS);ANDI(128);_BNE('.ovf')
        LD(AE);SUBI(160);_BGT('.ovf')
        label('.ok')
        if args.cpu >= 6:
            NEGV(vAC)
        else:
            XORI(255);ANDI(255);INC(vAC)
        _CALLI('__@amshra')
        LD(AS);ANDI(128);_BEQ('.ret')
        _LNEG()
        label('.ret')
        tryhop(2);POP();RET()

    module(name='rt_fto.s',
           code=[ ('EXPORT', '_@_ftoi'),
                  ('EXPORT', '_@_ftou'),
                  ('IMPORT', '__@amshra'),
                  ('IMPORT', '_@_clrfac'),
                  ('CODE', '_@_ftoi', code_ftoi) ] )

    # ==== additions and subtractions

    def code_amaddbm():
        nohop()
        if args.cpu >= 6:
            label('__@amaddbm40')
            LD(BM);ADDW(AM);ST(AM);XORW(AM);_BEQ('__@amaddbm32')
            INCVL(LAC)
            label('__@amaddbm32')
            LDI(BM+1);ADDL()
            RET()
        else:
            label('__@amaddbm40')
            LD(BM);ADDW(AM);ST(AM);XORW(AM);_BEQ('__@amaddbm32')
            LDI(1);ADDW(BM+1);_BRA('.a0')
            label('__@amaddbm32')
            LDW(BM+1);
            label('.a0')
            PUSH();STW(vLR)
            ADDW(AM+1);STW(AM+1);_BLT('.a2')
            SUBW(vLR);ORW(BM+1);_BLT('.a3')
            label('.a1')
            LDW(BM+3);BRA('.a4')
            label('.a2')
            SUBW(vLR);ANDW(BM+1);_BGE('.a1')
            label('.a3')
            LDI(1);ADDW(BM+3)
            label('.a4')
            ADDW(AM+3);STW(AM+3)
            POP();RET()

    module(name='rt_amaddbm.s',
           code=[ ('EXPORT', '__@amaddbm32'),
                  ('EXPORT', '__@amaddbm40'),
                  ('CODE', '__@amaddbm', code_amaddbm) ])

    def code_fadd_t3_ss():
        nohop()
        # addition branch
        label('__@fadd_t3_ss')
        LD(AM+4);XORI(128);ST(T3+1)
        if args.cpu >= 6:
            LDI(BM+1);ADDL()
        else:
            _CALLJ('__@amaddbm32')
        LDW(AM+3);ANDW(T3)
        _BLT('.faddx1')
        # carry
        if args.cpu >= 7:
            LDI(1);RORX()
        elif args.cpu == 6:
            _LDI(0xffff);RORX(cpu6exact=False)
        else:
            LDWI('SYS_LSRW1_48');STW('sysFn');_CALLI('__@amshrx')
            LD(AM+4);ORI(128);ST(AM+4)
        INC(AE);LD(AE)
        if args.cpu >= 6:
            JEQ('__@foverflow')
        else:
            BNE('.faddx1')
            _CALLJ('__@foverflow')
        label('.faddx1')
        _CALLJ('_@_rndfac')
        tryhop(2);POP();RET()

    def code_fadd_t3():
        label('__@fadd_t3')
        PUSH()
        _CALLJ('__@fsavevsp')
        _PEEKV(T3);STW(BE)
        LD(AE);_BEQ('.fadd1');SUBW(BE);_BGT('.fadd1')
        if args.cpu >= 7:
            LDW(T3);LDFARG()
        else:
            _CALLJ('__@fldarg_t3')       # FAC exponent <= arg exponent
        _BRA('.fadd2')
        label('.fadd1')
        _CALLJ('__@fac2farg')            # Otherwise swap
        if args.cpu >= 7:
            LDW(T3);LDFAC()
        else:
            _CALLJ('__@fldfac_t3')       # FAC exponent <= arg exponent
        label('.fadd2')
        LD(AE);STW(T3)                   # - we don't need T3 anymore
        LD(BE);_BEQ('.fadd3')            # - adding zero is simple
        ST(AE)                           # - assume arg exponent
        SUBW(T3)
        _CALLI('__@amshra')              # - align fac mantissa
        LD(AS);ANDI(1)
        if args.cpu >= 6:
            JEQ('__@fadd_t3_ss')         # > same sign branch
        else:
            _BNE('.fsubx1')              # - are signs different?
            _CALLJ('__@fadd_t3_ss')      # > same sign branch (no return)
        # different sign
        label('.fsubx1')
        if args.cpu >= 6:
            LD(AM+4);XORI(0x80);ST(T3+1)
            LDI(BM+1);SUBL()             # - subtract
            LDW(AM+3);ORW(T3)
        else:
            LD(AS);XORI(0x80);ST(AS)     # - assume farg sign
            LD(AM+4);ST(T3+1)
            _CALLJ('__@amneg')           # - negate fac
            _CALLJ('__@amaddbm32')       # - add
            LDW(AM+3);ANDW(T3)
        _BGE('.fsubx2')                  # > normalize
        LD(AS);XORI(129);ST(AS)          # - negate fac
        if args.cpu >= 7:
            NEGX()
        else:
            _CALLJ('__@amneg')
        label('.fsubx2')
        _CALLJ('__@fnorm')               # - normalize
        label('.fadd3')
        _CALLJ('_@_rndfac')
        tryhop(2);POP();RET()

    module(name='rt_faddt3.s',
           code=[ ('EXPORT', '__@fadd_t3'),
                  ('IMPORT', '__@fsavevsp'),
                  ('IMPORT', '__@foverflow'),
                  ('IMPORT', '__@amshra'),
                  ('IMPORT', '__@amneg') if args.cpu < 7 else ('NOP',),
                  ('IMPORT', '__@fac2farg'),
                  ('IMPORT', '__@fldfac_t3') if args.cpu < 7 else ('NOP',),
                  ('IMPORT', '__@fldarg_t3') if args.cpu < 7 else ('NOP',),
                  ('IMPORT', '__@amaddbm32') if args.cpu < 6 else ('NOP',),
                  ('IMPORT', '__@fnorm'),
                  ('IMPORT', '_@_rndfac'),
                  ('CODE', '__@fadd_t3_ss', code_fadd_t3_ss),
                  ('CODE', '__@fadd_t3', code_fadd_t3) ] )

    def code_fadd():
        '''_@_fadd: Add the float at address vAC to FAC'''
        nohop()
        label('_@_fadd')
        STW(T3)
        if args.cpu >= 6:
            JNE('__@fadd_t3');RET()
        else:
            BRA('.fa')
        label('_@_fsubr')
        STW(T3)
        LD(AS);XORI(0x81);ST(AS)
        if args.cpu >= 6:
            JGE('__@fadd_t3')
        else:
            label('.fa')
            PUSH();_CALLJ('__@fadd_t3');POP()
            RET()

    module(name='rt_fadd.s',
           code=[ ('EXPORT', '_@_fadd'),
                  ('EXPORT', '_@_fsubr'),
                  ('CODE', '_@_fadd', code_fadd),
                  ('IMPORT', '__@fadd_t3') ] )

    def code_fsub():
        '''_@_fsub: Subtract the float at address vAC from FAC'''
        nohop()
        label('_@_fsub')
        STW(T3)
        LD(AS);XORI(0x81);ST(AS)
        PUSH();_CALLJ('__@fadd_t3');POP()
        label('_@_fneg')
        LD(AS);XORI(0x81);ST(AS)
        RET()

    module(name='rt_fsub.s',
           code=[ ('EXPORT', '_@_fsub'),
                  ('EXPORT', '_@_fneg'),
                  ('CODE', '_@_fsub', code_fsub),
                  ('IMPORT', '__@fadd_t3') ] )


    # ==== multiplication

    def code_macx():
        '''Emulation of DEV7ROM's MACX opcode.
           * Add vACL (8 bits) times sysArgs[0..3] (32 bits) to LAX (40 bits)
           * LAC := LAX + sysArgs[3..0] * vACL.
           * Trashes sysArgs[4-7] like MACX'''
        nohop()
        if args.cpu >= 7:
            warning("cpu7: use MACX instead of __@macx")
            label('__@macxsha')
            ST(T5);LDI(8);LSRXA();LD(T5)
            label('__@macx')
            MACX();RET()
        else:
            label('__@macxsha')
            ST(T5);PUSH()
            _CALLJ('__@amshr8')
            _BRA('.macx0')
            label('__@macx')
            ST(T5);PUSH()
            label('.macx0')
            _MOVIB(0,BM+4)  # BM+4 is T4L
            LDI(1)          # Use T4H for mask
            label('.macx1')
            ST(T4+1);ANDW(T5);_BEQ('.macx2')
            if args.cpu >= 6:
                LD(BM);ADDW(AM);ST(AM);XORW(AM);_BEQ('.macx1a')
                INCVL(LAC)
                label('.macx1a')
                LDI(BM+1);ADDL()
            else:
                _CALLJ('__@amaddbm40')
            label('.macx2')
            if args.cpu >= 6:
                LSLVL(BM+1)
            else:
                LDW(BM+3);LSLW();STW(BM+3)
                LDW(BM+1);_BGE('.sh1');INC(BM+3)
                label('.sh1')
                LSLW();STW(BM+1)
            LD(BM);ADDW(BM);STW(BM)
            LD(T4+1);LSLW();ANDI(255);_BNE('.macx1')
            POP()
            label('__@bmshr8')
            LDW(BM+1);STW(BM);
            LDW(BM+3);STW(BM+2)
            RET()

    module(name='rt_macx.s',
           code=[ ('EXPORT', '__@macxsha'),
                  ('EXPORT', '__@macx'),
                  ('EXPORT', '__@bmshr8'),
                  ('IMPORT', '__@amaddbm40') if args.cpu < 6 else ('NOP',),
                  ('IMPORT', '__@amshr8') if args.cpu < 7 else ('NOP',),
                  ('CODE', '__@macx', code_macx) ] )

    def code_fmulm():
        nohop();
        label('__@fmulm')
        LDI(0);ST(AM);STW(AM+1);STW(AM+3)
        if args.cpu >= 7:
            LDI(4);ADDW(T3);PEEK();MACX();LDI(8);LSRXA()
            LDI(3);ADDW(T3);PEEK();MACX();LDI(8);LSRXA()
            LDI(2);ADDW(T3);PEEK();MACX();LDI(8);LSRXA()
            LDI(1);ADDW(T3);PEEK();ORI(0x80);MACX()
        elif args.cpu >= 5:
            PUSH()
            LDI(4);ADDW(T3);PEEK();_CALLI('__@macx')
            LDI(3);ADDW(T3);PEEK();_CALLI('__@macxsha')
            LDI(2);ADDW(T3);PEEK();_CALLI('__@macxsha')
            LDI(1);ADDW(T3);PEEK();ORI(0x80);_CALLI('__@macxsha')
        else:
            PUSH()
            LDWI('__@macx');STW('sysFn')
            LDI(4);ADDW(T3);PEEK();CALL('sysFn')
            LDWI('__@macxsha');STW('sysFn')
            LDI(3);ADDW(T3);PEEK();CALL('sysFn')
            LDI(2);ADDW(T3);PEEK();CALL('sysFn')
            LDI(1);ADDW(T3);PEEK();ORI(0x80);CALL('sysFn')
        LDW(AM+3);_BGE('.muln')
        LDWI(-128)
        if args.cpu < 7:
            POP()
        RET()
        label('.muln')          # normalization
        if args.cpu >= 7:
            LDI(1);LSLXA()
        elif args.cpu >= 6:
            LSLVL(AM+1)
            LD(AM);ADDW(AM);STW(AM)
        else:
            _CALLJ('__@amshl1')
        LDWI(-129)
        if args.cpu < 7:
            POP()
        RET()


    def code_fmul():
        '''_@_fmul: Multiply FAC by the float at address vAC.'''
        nohop()
        label('_@_fmul')
        PUSH();STW(T3)
        ADDI(1);PEEK();XORW(AS);ST(AS)     # sign
        _CALLJ('__@fsavevsp')
        _PEEKV(T3);STW(BE);_BEQ('.zero')   # exponent
        LD(AE);_BEQ('.zero')
        if args.cpu >= 7:
            ADDV(BE)            # result exponent (+128)
        else:
            ADDW(BE);STW(BE)
        if args.cpu >= 6:       # move am32 to bm
            MOVL(AM+1,BM)
        else:
            LDW(AM+1);STW(BM)
            LDW(AM+3);STW(BM+2)
        _CALLJ('__@fmulm')      # multiply mantissa
        ADDW(BE);ST(AE)         # exponent
        _BLE('.zero')
        LD(vACH)
        if args.cpu >= 6:
            JNE('__@foverflow')
            POP();JEQ('_@_rndfac')
            label('.zero')
            POP();JLE('_@_clrfac')
        else:
            BNE('.ovf')
            _CALLJ('_@_rndfac')
            tryhop(2);POP();RET()
            label('.ovf')
            _CALLJ('__@foverflow')
            label('.zero')
            _CALLJ('_@_clrfac')
            tryhop(2);POP();RET()

    module(name='rt_fmul.s',
           code=[ ('EXPORT', '_@_fmul'),
                  ('IMPORT', '__@fsavevsp'),
                  ('IMPORT', '__@foverflow'),
                  ('IMPORT', '_@_clrfac'),
                  ('IMPORT', '_@_rndfac'),
                  ('IMPORT', '__@macx') if args.cpu < 7 else ('NOP',),
                  ('IMPORT', '__@macxsha') if args.cpu < 7 else ('NOP',),
                  ('IMPORT', '__@amshl1') if args.cpu < 7 else ('NOP',),
                  ('CODE', '_@_fmulm', code_fmulm),
                  ('CODE', '_@_fmul', code_fmul) ] )

    # ==== division

    def code_fdivloop():
        '''[vSP] is the quotient exponent which is reduced by one whenever one
           shifts one bit into CM.  This function repeats the division
           loop until either the high bit is set or [vSP] reaches 0.'''
        nohop()
        label('__@fdivloop')
        qexp = 0              # - stack offset of quotient exponent
        if args.cpu < 6 or avoid_cmpw:
            qexp = 2; PUSH()
        if args.cpu >= 6:     # - working with the low 32 bits of BM
            _MOVW(BM+1,BM)
            _MOVW(BM+3,BM+2)
        else:
            _CALLJ('__@bmshr8')
        LDI(0);STW(CM);STW(CM+2)
        _BRA('.fdl2')
        label('.fdl0')
        LDLW(qexp);SUBI(1);_BLT('.fdl5');STLW(qexp)
        if args.cpu >= 6:
            LSLVL(CM)
            LDW(AM+3);LSLVL(AM+1);_BLT('.fdl3')
            label('.fdl2')
            LDI(BM);CMPLU()
        else:
            _CALLJ('__@cmshl1')
            LDW(AM+3);_BGE('.fdl1')
            _CALLJ('__@amshl1');_BRA('.fdl3')
            label('.fdl1')
            _CALLJ('__@amshl1')
            label('.fdl2')
            if avoid_cmpw:
                _CALLJ('__@lcmpu_t0t1')
            else:
                LDW(AM+3);_CMPWU(BM+2);_BNE('.fdl2a')
                LDW(AM+1);_CMPWU(BM);label('.fdl2a')
        _BLT('.fdl4')
        label('.fdl3')
        INC(CM)
        if args.cpu >= 6:
            LDI(BM);SUBL()
        else:
            _CALLJ('__@lsub_t0t1')
        label('.fdl4')
        LDW(CM+2);_BGE('.fdl0')
        label('.fdl5')
        if args.cpu < 6 or avoid_cmpw:
            tryhop(2);POP()
        RET()

    def code_fdivrnd():
        nohop()
        label('__@fdivrnd')
        if args.cpu < 6 or avoid_cmpw:
            PUSH()
        LDW(AM+3);_BLT('.fdr1')
        if args.cpu >= 6:
            LSLVL(AM+1)
            LDI(BM);CMPLU()
        else:
            _CALLJ('__@amshl1')
            if avoid_cmpw:
                _CALLJ('__@lcmpu_t0t1')
            else:
                LDW(AM+3);_CMPWU(BM+2);_BNE('.fdr2')
                LDW(AM+1);_CMPWU(BM);label('.fdr2')
        _BLT('.fdr0')
        label('.fdr1')
        if args.cpu >= 6:
            INCVL(CM);LDW(CM+2);_BNE('.fdr0')
        else:
            LDI(1);ADDW(CM);STW(CM);_BNE('.fdr0')
            LDI(1);ADDW(CM+2);STW(CM+2);_BNE('.fdr0')
        SUBI(1);STW(CM);STW(CM+2)
        label('.fdr0')
        if args.cpu < 6 or avoid_cmpw:
            tryhop(2);POP()
        RET()

    module(name='rt_fdivloop.s',
           code=[ ('EXPORT', '__@fdivloop'),
                  ('EXPORT', '__@fdivrnd'),
                  ('IMPORT', '__@amshl1') if args.cpu < 7 else ('NOP',),
                  ('IMPORT', '__@cmshl1') if args.cpu < 6 else ('NOP',),
                  ('IMPORT', '__@lsub_t0t1') if args.cpu < 6 else ('NOP',),
                  ('IMPORT', '__@lcmpu_t0t1') if avoid_cmpw else ('NOP',),
                  ('CODE', '__@fdivloop', code_fdivloop),
                  ('CODE', '__@fdivrnd', code_fdivrnd) ] )

    def code_fdiv():
        '''_@_fdiv: Divide FAC by the float at address vAC.'''
        label('_@_fdiv')
        PUSH();STW(T3)
        _CALLJ('__@fsavevsp')
        if args.cpu >= 7:
            LDW(T3);LDFARG()
        else:
            _CALLJ('__@fldarg_t3')
        label('__@fdivfa')
        LD(AS);ANDI(1);ADDI(127);ST(AS)  # - sign
        LD(BE)
        if args.cpu >= 7:
            STW(BE)
        if args.cpu >= 6:
            JEQ('__@fexception')         # - divisor is zero -> exception
        else:
            _BNE('.fdiv0')
            _CALLJ('__@fexception')      # - divisor is zero -> exception
            label('.fdiv0')
        LD(AE);_BEQ('.zero')             # - dividend is zero -> result is zero
        SUBW(BE);ADDI(160)
        _BLE('.zero')                    # - hopeless underflow
        ALLOC(-2);STLW(0)
        _CALLJ('__@fdivloop')
        _CALLJ('__@fdivrnd')
        LDLW(0);ALLOC(2)
        ST(AE);_BLE('.zero')             # - copy exponent and test for overflow
        LD(vACH)
        if args.cpu >= 6:
            JNE('__@foverflow')
        else:
            _BNE('.ovf')
        ST(AM)                           # - copy quotient into AM
        _MOVW(CM, AM+1)
        _MOVW(CM+2, AM+3)
        tryhop(2);POP();RET()
        if args.cpu >= 6:
            label('.zero')
            POP();JLE('_@_clrfac')
        else:
            label('.ovf')
            _CALLJ('__@foverflow')
            label('.zero')
            _CALLJ('_@_clrfac')
            tryhop(2);POP();RET()

    module(name='rt_fdiv.s',
           code=[ ('EXPORT', '_@_fdiv'),
                  ('EXPORT', '__@fdivfa'),
                  ('IMPORT', '__@fsavevsp'),
                  ('IMPORT', '__@fldarg_t3') if args.cpu < 7 else ('NOP',),
                  ('IMPORT', '__@fexception'),
                  ('IMPORT', '__@fdivloop'),
                  ('IMPORT', '__@fdivrnd'),
                  ('IMPORT', '_@_clrfac'),
                  ('IMPORT', '__@foverflow'),
                  ('CODE', '_@_fdiv', code_fdiv) ] )

    def code_fdivr():
        '''_@_fdiv: Divide the float at address vAC by FAC, result in FAC.'''
        label('_@_fdivr')
        PUSH();STW(T3)
        _CALLJ('__@fsavevsp')
        _CALLJ('__@fac2farg')
        if args.cpu >= 7:
            LDW(T3);LDFAC()
        else:
            _CALLJ('__@fldfac_t3')
        _CALLJ('__@fdivfa') # no return

    module(name='rt_fdivr.s',
           code=[ ('EXPORT', '_@_fdivr'),
                  ('IMPORT', '__@fsavevsp'),
                  ('IMPORT', '__@fac2farg'),
                  ('IMPORT', '__@fldfac_t3') if args.cpu < 7 else ('NOP',),
                  ('IMPORT', '__@fdivfa'),
                  ('CODE', '_@_fdivr', code_fdivr) ] )

    # ==== fmod

    def code_fmod():
        '''_@_fmod: Leaves in FAC the floating point remainder FAC % [vAC]
           that is FAC - n * [vAC] where n is the quotient FAC/[vAC]
           rounded toward zero to an integer. Returns the 16 low bits
           of n into vAC'''
        nohop()
        label('_@_fmod')
        PUSH();STW(T3)
        _CALLJ('__@fsavevsp')
        if args.cpu >= 7:
            LDW(T3);LDFARG()
        else:
            _CALLJ('__@fldarg_t3')
        LD(BE);STW(BE);_BEQ('.zero')
        LD(AE);_BEQ('.zero')
        SUBW(BE);_BLT('.zquo')
        ALLOC(-2);STLW(0)
        LD(BE);ST(AE)
        _CALLJ('__@fdivloop')
        LDLW(0);ALLOC(2)
        _BNE('.zero')
        _CALLJ('__@fnorm')
        label('.ret')
        LDW(CM)
        tryhop(2);POP();RET()
        label('.zero')
        _CALLJ('_@_clrfac')
        label('.zquo')
        LDI(0)
        tryhop(2);POP();RET()

    module(name='rt_fmod.s',
           code=[ ('EXPORT', '_@_fmod'),
                  ('CODE', '_@_fmod', code_fmod),
                  ('IMPORT', '__@fsavevsp'),
                  ('IMPORT', '_@_rndfac'),
                  ('IMPORT', '__@fldarg_t3') if args.cpu < 7 else ('NOP',),
                  ('IMPORT', '__@fdivloop'),
                  ('IMPORT', '_@_clrfac'),
                  ('IMPORT', '__@fnorm') ] )

    # ==== comparisons

    def code_fcmp():
        '''_@_fcmp: Compare FAC with the float at address vAC and return -1,
           0, or +1.  Note that because of the absence of subnormal
           numbers, this function might declare that two very small
           numbers are different even though subtracting one from the
           other might underflow and return zero.'''
        label('_@_fcmp')
        if args.cpu >= 7:
            LDFARG()
            def cPOP(): pass
        else:
            PUSH()
            STW(T3);_CALLJ('__@fldarg_t3')
            def cPOP(): tryhop(2); POP()
        LD(BE);STW(BE);_BNE('.fcmp0')
        LD(AE);_BEQ('.zero')
        label('.pm1')
        XORW(AS-1);_BGE('.p1')
        LDWI(-1);cPOP();RET();
        label('.p1')
        LDI(1);cPOP();RET();
        label('.fcmp0')     # comparing sign
        LD(AS);ANDI(1);_BNE('.pm1')
        label('.fcmp1')     # comparing exponents
        LD(AE);SUBW(BE);_BNE('.pm1')
        label('.fcmp2')     # comparing mantissa
        if args.cpu >= 6:
            LDI(BM+1);CMPLU();_BNE('.pm1')
        elif avoid_cmpw:
            _CALLJ('__@bmshr8');_CALLJ('__@lcmpu_t0t1');_BNE('.pm1')
        else:
            LDW(AM+3);_CMPWU(BM+3);_BNE('.pm1')
            LDW(AM+1);_CMPWU(BM+1);_BNE('.pm1')
        label('.zero')
        LDI(0);cPOP();RET()

    module(name='rt_fcmp.s',
           code=[ ('EXPORT', '_@_fcmp'),
                  ('IMPORT', '_@_rndfac'),
                  ('IMPORT', '__@fldarg_t3') if args.cpu < 7 else ('NOP',),
                  ('IMPORT', '__@lcmpu_t0t1') if avoid_cmpw else ('NOP',),
                  ('IMPORT', '__@bmshr8') if avoid_cmpw else ('NOP',),
                  ('CODE', '_@_fcmp', code_fcmp) ] )

    def code_fsign():
        '''_@_fsign: return the sign of FAC into AC (-1/0/+1)'''
        nohop()
        label('_@_fsign')
        LD(AE);_BEQ('.done')
        LD(AS);ANDI(128);_BEQ('.plus')
        _LDI(-2)
        label('.plus')
        INC(vAC)
        label('.done')
        tryhop(2);RET()

    module(name='rt_fsign.s',
           code=[ ('EXPORT', '_@_fsign'),
                  ('IMPORT', '_@_rndfac'),
                  ('CODE', '_@_fsign', code_fsign) ] )

    # ==== misc

    def code_frexp():
        '''_@_frexp: Return x in FAC and exp in vAC such
           that FAC = x * 2^exp with 0.5<=x<1.'''
        nohop()
        label('_@_frexp')
        LD(AE);_BEQ('.frexp2')
        SUBI(128);STW(T3)
        LDI(128);ST(AE)
        LDW(T3)
        label('.frexp2')
        RET()

    module(name='rt_frexp.s',
           code=[ ('IMPORT', '__@fnorm'),
                  ('EXPORT', '_@_frexp'),
                  ('CODE', '_@_frexp', code_frexp) ] )

    def code_fscalb():
        '''_@_fscalb: Multiplies FAC by 2^vAC'''
        nohop()
        label('_@_fscalb')
        STW(T3);LD(AE);ADDW(T3)
        if args.cpu >= 6:
            JLE('_@_clrfac')
        else:
            _BLE('.zero')
        ST(AE);LD(vACH);_BEQ('.ret')
        PUSH()
        _CALLJ('__@fsavevsp')
        _CALLJ('__@foverflow')
        if args.cpu < 6:
            label('.zero')
            PUSH()
            _CALLJ('_@_clrfac')
            tryhop(2);POP()
        label('.ret')
        RET()

    module(name='rt_fscalb.s',
           code=[ ('IMPORT', '__@fsavevsp'),
                  ('IMPORT', '__@foverflow'),
                  ('IMPORT', '_@_clrfac'),
                  ('EXPORT', '_@_fscalb'),
                  ('CODE', '_@_fscalb', code_fscalb) ] )


    def code_fscald():
        '''_@_fscald: Given x in FAC and m >= 0 in vACL,
               returns y in FAC and n >= 0 in vAC such that x and y
               have the same exponent and x * 10^m = y * 2^n.
               Calling _@_fscalb afterwards gives x * 10^m.'''
        label('_@_fscald')
        PUSH()
        STW(T3);_BEQ('.ret');_MOVIW(0,T2)
        label('.loop')
        if args.cpu >= 7:
            MOVF(AM,BM)
            LDI(2);LSRXA() 
            LD(BM);ADDW(AM);ST(AM);XORW(AM);_BEQ('.a0')
            INCVL(LAC)
            label('.a0')
            LDI(BM+1);ADDL()
        elif args.cpu >= 6:
            MOVF(AM,BM)
            LDWI('SYS_LSRW2_52');STW('sysFn');_CALLI('__@amshrx')
            LD(BM);ADDW(AM);ST(AM);XORW(AM);_BEQ('.a0')
            INCVL(LAC)
            label('.a0')
            LDI(BM+1);ADDL()
        else:
            _CALLJ('__@am2bm40')
            LDWI('SYS_LSRW2_52');STW('sysFn');_CALLI('__@amshrx')
            _CALLJ('__@amaddbm40')
        LDW(AM+3);_BLT('.a1')
        if args.cpu >= 7:
            LDI(1);RORX()
        elif args.cpu == 6:
            _LDI(0xffff);RORX(cpu6exact=False)
        else:
            LDWI('SYS_LSRW1_48');STW('sysFn');_CALLI('__@amshrx')
            LD(AM+4);ORI(128);ST(AM+4)
        LDI(4);_BRA('.a2')
        label('.a1')
        LDI(3)
        label('.a2')
        if args.cpu >= 7:
            ADDV(T2)
        else:
            ADDW(T2);STW(T2)
        label('.tst')
        if args.cpu >= 6:
            DBNE(T3,'.loop');
        else:
            LD(T3);SUBI(1);ST(T3);_BNE('.loop')
        _CALLJ('_@_rndfac')
        LDW(T2)
        label('.ret')
        tryhop(2);POP();RET()

    module(name='rt_fscald.s',
           code=[ ('EXPORT', '_@_fscald'),
                  ('IMPORT', '__@am2bm40') if args.cpu < 6 else ('NOP',),
                  ('IMPORT', '__@amaddbm40') if args.cpu < 6 else ('NOP',),
                  ('IMPORT', '__@amshrx') if args.cpu < 7 else ('NOP',),
                  ('IMPORT', '_@_rndfac'),
                  ('CODE', '_@_fscald', code_fscald) ] )


    def code_frndz():
        '''_@_frndz: Make FAC integer, rounding towards zero'''
        nohop()
        label('_@_frndz')
        LD(AE);SUBI(160);_BGE('.ret')
        if args.cpu >= 6:
            NEGV(vAC)
        else:
            XORI(255);ANDI(255);INC(vAC)
        PUSH()
        _CALLI('__@amshra')
        LDI(160);STW(AE) # AE=160 and AM=0
        if args.cpu >= 6:
            POP();JNE('__@fnorm')
        else:
            _CALLI('__@fnorm');POP()
        label('.ret')
        RET()

    module(name='rt_frndz.s',
           code=[ ('IMPORT', '__@amshra'),
                  ('IMPORT', '__@fnorm'),
                  ('EXPORT', '_@_frndz'),
                  ('CODE', '_@_frndz', code_frndz) ] )


# create all the modules
scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
def scope():

    # LAC + [vAC] --> LAC
    def code0():
        nohop()
        if args.cpu >= 6:
            label('__@ladd_t0t1')
            LDI(T0)
            label('_@_ladd')
            ADDL();RET()
            warning("Cpu6: should ADDL instead of calling _@_ladd")
        else:
            label('_@_ladd')
            # load arg into T0/T1
            STW(T3);DEEK();STW(T0)
            LDI(2);ADDW(T3);DEEK();STW(T1)
            label('__@ladd_t0t1')
            LDW(LAC);ADDW(T0);STW(LAC);_BLT('.a1')
            SUBW(T0);ORW(T0);_BLT('.a2')
            label('.a0')
            LDW(LAC+2);BRA('.a3')
            label('.a1')
            SUBW(T0);ANDW(T0);_BGE('.a0')
            label('.a2')
            LDI(1);ADDW(LAC+2)
            label('.a3')
            ADDW(T1);STW(LAC+2)
            RET()

    module(name='rt_ladd.s',
           code= [ ('EXPORT', '_@_ladd'),
                   ('EXPORT', '__@ladd_t0t1'),
                   ('CODE', '_@_ladd', code0) ] )


    # LAC - [vAC] --> LAC
    def code0():
        nohop()
        if args.cpu >= 6:
            label('__@lsub_t0t1')
            LDI(T0)
            label('_@_lsub')
            SUBL();RET()
            warning("Cpu6: should SUBL instead of calling _@_lsub")
        else:
            label('_@_lsub')
            # load arg into T0/T1
            STW(T3);DEEK();STW(T0)
            LDI(2);ADDW(T3);DEEK();STW(T1)
            label('__@lsub_t0t1')
            LDW(LAC);_BLT('.a1')
            SUBW(T0);STW(LAC);ORW(T0);_BLT('.a2')
            label('.a0')
            LDW(LAC+2);BRA('.a3')
            label('.a1')
            SUBW(T0);STW(LAC);ANDW(T0);_BGE('.a0')
            label('.a2')
            LDW(LAC+2);SUBI(1)
            label('.a3')
            SUBW(T1);STW(LAC+2)
            RET()

    module(name='rt_lsub.s',
           code=[ ('EXPORT', '_@_lsub'),
                  ('EXPORT', '__@lsub_t0t1'),
                  ('CODE', '_@_lsub', code0) ])

    # -LAC --> LAC
    def code1():
        nohop()
        label('_@_lneg')
        if args.cpu >= 6:
            NEGVL(LAC);RET()
            warning("Cpu6: should NEGVL instead of calling _@_lneg")
        else:
            LDI(0);SUBW(LAC);STW(LAC);BEQ('.lneg1')
            LDWI(0xffff)
            label('.lneg1')
            SUBW(LAC+2);STW(LAC+2);RET()
            
    module(name='rt_lneg.s',
           code= [ ('EXPORT', '_@_lneg'),
                   ('CODE', '_@_lneg', code1) ] )

    # LNEG_T0T1 : -TOT1 --> TOT1
    def code1():
        nohop()
        label('__@lneg_t0t1')
        if args.cpu >= 6:
            NEGVL(T0);RET()
            warning("Cpu6: should NEGVL instead of calling __@lneg_t0t1")
        else:
            LDI(0);SUBW(T0);STW(T0);BEQ('.lneg1')
            LDWI(0xffff)
            label('.lneg1')
            SUBW(T0+2);STW(T0+2);RET()

    module(name='rt_lnegt0t1.s',
           code=[ ('EXPORT', '__@lneg_t0t1'),
                  ('CODE', '__@lneg_t0t1', code1) ])


scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
def scope():

    def code0():
        nohop()
        label('_@_lcom')
        if args.cpu >= 6:
            NOTVL(LAC)
            warning("cpu6: should use NOTVL instead of _@_lcom")
        else:
            _LDI(0xffff);XORW(LAC);STW(LAC)
            _LDI(0xffff);XORW(LAC+2);STW(LAC+2)
        RET()

    module(name='rt_lcom.s',
           code=[ ('EXPORT', '_@_lcom'),
                  ('CODE', '_@_lcom', code0) ])

    def code1():
        nohop()
        label('_@_land')
        if args.cpu >= 6:
            ANDL()
            warning("cpu6: should use ANDL instead of _@_land")
        else:
            STW(T3);DEEK();ANDW(LAC);STW(LAC)
            LDI(2);ADDW(T3);DEEK();ANDW(LAC+2);STW(LAC+2)
        RET()

    module(name='rt_land.s',
           code=[ ('EXPORT', '_@_land'),
                  ('CODE', '_@_land', code1) ])

    def code2():
        nohop()
        label('_@_lor')
        if args.cpu >= 6:
            ORL()
            warning("cpu6: should use ORL instead of _@_lor")
        else:
            STW(T3);DEEK();ORW(LAC);STW(LAC)
            LDI(2);ADDW(T3);DEEK();ORW(LAC+2);STW(LAC+2)
        RET()

    module(name='rt_lor.s',
           code=[ ('EXPORT', '_@_lor'),
                  ('CODE', '_@_lor', code2) ])

    def code3():
        nohop()
        label('_@_lxor')
        if args.cpu >= 6:
            XORL()
            warning("cpu6: should use XORL instead of _@_lxor")
        else:
            STW(T3);DEEK();XORW(LAC);STW(LAC)
            LDI(2);ADDW(T3);DEEK();XORW(LAC+2);STW(LAC+2)
        RET()

    module(name='rt_lxor.s',
           code=[ ('EXPORT', '_@_lxor'),
                  ('CODE', '_@_lxor', code3) ])

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
def scope():

    # LCMPS, LCMPU compare(LAC,[vAC])
    # Trashes T[01]

    avoid_cmpw = (args.cpu <= 4) or ("without_CmpOps" in rominfo)

    def code0():
        nohop()
        if args.cpu >= 6:
            warning("cpu6: use CMPLU/CMPLS instead of _@_lcmps/_@_lcmpu")
            label('__@lcmps_t0t1')
            LDI(T0)
            label('_@_lcmps')
            CMPLS()
            RET()
            label('__@lcmpu_t0t1')
            LDI(T0)
            label('_@_lcmpu')
            CMPLU()
            RET()
        else:
            label('_@_lcmps')
            STW(T3);DEEK();STW(T0)
            LDI(2);ADDW(T3);DEEK();STW(T1)
            label('__@lcmps_t0t1')
            LDW(LAC+2)
            if avoid_cmpw:
                XORW(T1);_BEQ('.lcmp1');_BGE('.lcmp0')
                LDW(LAC+2); _BRA('.lcmp2')
            else:
                _CMPWS(T1);_BEQ('.lcmp1'); RET()
            label('_@_lcmpu')
            STW(T3);DEEK();STW(T0)
            LDI(2);ADDW(T3);DEEK();STW(T1)
            label('__@lcmpu_t0t1')
            LDW(LAC+2)
            if avoid_cmpw:
                XORW(T1);_BEQ('.lcmp1');_BGE('.lcmp0')
                LDW(T1); _BRA('.lcmp2')
                label('.lcmp0')
                LDW(LAC+2); SUBW(T1); RET()
            else:
                _CMPWU(T1);_BEQ('.lcmp1'); RET()
            label('.lcmp1')
            LDW(LAC)
            if avoid_cmpw:
                XORW(T0);_BGE('.lcmp3')
                LDW(T0); label('.lcmp2'); ORI(1); RET()
                label('.lcmp3')
                LDW(LAC); SUBW(T0); RET()
            else:
                _CMPWU(T0);RET()


    module(name='lcmp.s',
           code= [ ('EXPORT', '_@_lcmps'),
                   ('EXPORT', '_@_lcmpu'),
                   ('EXPORT', '__@lcmps_t0t1'),
                   ('EXPORT', '__@lcmpu_t0t1'),
                   ('CODE', '_@_lcmps', code0) ])


    # LCMPX: compare(LAC,[vAC]) for equality only
    def code1():
        nohop()
        label('_@_lcmpx')
        if args.cpu >= 6:
            CMPLS()
            warning("cpu6: use CMPLS instead of _@_lcmpx")
        else:
            STW(T3);DEEK();XORW(LAC);_BNE('.lcmpx1')
            LDI(2);ADDW(T3);DEEK();XORW(LAC+2)
            label('.lcmpx1')
        RET()

    module(name='lcmpx.s',
           code= [ ('EXPORT', '_@_lcmpx'),
                   ('CODE', '_@_lcmpx', code1) ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():

    # Long division helper using vCPU
    #  LAC:  in: dividend  out: remainder
    #  T0T1: in: divisor
    #  T2T3: out: quotient
    # Clobbers sysArgs4

    def CallWorker():
        _CALLJ('__@ldivworker')

    def code_ldivworker():
        nohop()                    # 92 bytes
        label('__@ldivworker')
        if args.cpu < 6:
            PUSH()
        _MOVW(LAC,T2);_MOVW(LAC+2,T2+2)
        LDI(0);STW(LAC);STW(LAC+2)
        label('.ldiv0')
        if args.cpu >= 6:
            LSLVL(LAC)
            LDW(T2+2);_BGE('.ldw1');INC(LAC)
            label('.ldw1')
            LSLVL(T2)
        else:
            LDW(LAC+2);LSLW();STW(LAC+2)
            LDW(LAC);_BGE('.ldw1');INC(LAC+2)
            label('.ldw1');LSLW();STW(LAC)
            LDW(T2+2);_BGE('.ldw2');INC(LAC)
            label('.ldw2');LSLW();STW(T2+2)
            LDW(T2);_BGE('.ldw3');INC(T2+2)
            label('.ldw3');LSLW();STW(T2)
        if args.cpu >= 6:
            LDI(T0);CMPLU()
        else:
            _CALLJ('__@lcmpu_t0t1')
        _BLT('.ldiv1')
        if args.cpu >= 6:
            LDI(T0);SUBL()
        else:
            _CALLJ('__@lsub_t0t1')
        INC(T2)
        label('.ldiv1')
        if args.cpu >= 6:
            DBNE(T4,'.ldiv0')
        else:
            INC(T4);LD(T4);_BNE('.ldiv0')
        if args.cpu < 6:
            tryhop(2);POP()
        RET()

    module(name='rt_ldivworker.s',
           code=[ ('EXPORT', '__@ldivworker'),
                  ('IMPORT', '__@lsub_t0t1') if args.cpu < 6 else ('NOP',),
                  ('IMPORT', '__@lcmpu_t0t1') if args.cpu < 6 else ('NOP',),
                  ('CODE', '__@ldivworker', code_ldivworker) ])

    def code_ldivprep():
        nohop()
        label('__@ldivprep')
        STW(T3);DEEK();STW(T0);
        LDW(T3);ADDI(2);DEEK();STW(T0+2);
        if args.cpu >= 6:
            ORW(T0);JEQ('_@_raise_zdiv')
            LDI(32)
        else:
            ORW(T0);_BNE('.ldp1')
            _CALLJ('_@_raise_zdiv')
            label('.ldp1')
            LDI(256-32)
        STW(T4)
        RET()

    module(name='rt_ldivprep.s',
           code=[ ('EXPORT', '__@ldivprep'),
                  ('IMPORT', '_@_raise_zdiv'),
                  ('CODE',   '__@ldivprep', code_ldivprep) ] )

    # ----------------------------------------
    # LDIVU: LAC / [vAC] -> LAC
    # ----------------------------------------

    def code_ldivu():
        """ Unsigned division LAC / [vAC] -> LAC.
            Thrashes T[0-5] sysArgs[0-7]."""
        label('_@_ldivu')
        PUSH()
        _CALLI('__@ldivprep')
        CallWorker()
        _MOVW(T2,LAC);_MOVW(T2+2,LAC+2)
        tryhop(2);POP();RET()

    module(name='rt_ldivu.s',
           code=[ ('EXPORT', '_@_ldivu'),
                  ('IMPORT', '__@ldivprep'),
                  ('CODE',   '_@_ldivu', code_ldivu),
                  ('IMPORT', '__@ldivworker') ] )


    # ----------------------------------------
    # LMODU: LAC%[vAC]->vAC, LAC/[vAC]->T0T1
    # ----------------------------------------

    def code_lmodu():
        """ Unsigned modulo LAC % [vAC] -> LAC.
            Returns quotient in T[01]
            Thrashes T[0-5] sysArgs[0-7]."""
        label('_@_lmodu')
        PUSH()
        _CALLI('__@ldivprep')
        CallWorker()
        LDW(T2);STW(T0);LDW(T2+2);STW(T0+2)
        tryhop(2);POP();RET()

    module(name='rt_lmodu.s',
           code=[ ('EXPORT', '_@_lmodu'),
                  ('IMPORT', '__@ldivprep'),
                  ('CODE',   '_@_lmodu', code_lmodu),
                  ('IMPORT', '__@ldivworker') ] )


    # ----------------------------------------

    def code_ldivsign():
        # Signed division helper
        # T4H bit 7 : quotient sign
        # T4H bit 6 : remainder sign
        label('__@ldivsign')
        PUSH()
        LDW(LAC+2);_BGE('.lds1')
        if args.cpu >= 6:
            NEGVL(LAC)
        else:
            _CALLJ('_@_lneg')
        LD(T4+1);XORI(0xc0);ST(T4+1)
        label('.lds1')
        LDW(T0+2);_BGE('.lds2')
        if args.cpu >= 6:
            NEGVL(T0)
        else:
            _CALLJ('__@lneg_t0t1')
        LD(T4+1);XORI(0x80);ST(T4+1)
        label('.lds2')
        tryhop(2);POP();RET()

    module(name='rt_ldivsign.s',
           code=[ ('EXPORT', '__@ldivsign'),
                  ('IMPORT', '__@lneg_t0t1') if args.cpu < 6 else ('NOP',),
                  ('IMPORT', '_@_lneg') if args.cpu < 6 else ('NOP',),
                  ('CODE',   '__@ldivsign', code_ldivsign) ] )

    # ----------------------------------------
    # LDIVS: LAC / [vAC] -> LAC
    # ----------------------------------------

    def code_ldivs():
        """ Signed division LAC / [vAC] -> LAC.
            Thrashes T[0-3] sysArgs[0-7]."""
        label('_@_ldivs')
        PUSH()
        _CALLI('__@ldivprep')
        _CALLJ('__@ldivsign')
        CallWorker()
        _MOVW(T2,LAC);_MOVW(T2+2,LAC+2)
        LDW(T4);_BGE('.ret')
        if args.cpu >= 6:
            NEGVL(LAC)
        else:
            _CALLJ('_@_lneg')
        label('.ret')
        tryhop(2);POP();RET()

    module(name='rt_ldivs.s',
           code=[ ('EXPORT', '_@_ldivs'),
                  ('IMPORT', '__@ldivprep'),
                  ('IMPORT', '__@ldivsign'),
                  ('IMPORT', '_@_lneg') if args.cpu < 6 else ('NOP',),
                  ('CODE',   '_@_ldivs', code_ldivs),
                  ('IMPORT', '__@ldivworker') ] )

    # ----------------------------------------
    # LMODS: LAC%[vAC]->vAC, LAC/[vAC]->T0T1
    # ----------------------------------------

    def code_lmods():
        """ Signed modulo LAC % [vAC] -> LAC.
            Returns quotient in T[01]
            Thrashes T[0-3] sysArgs[0-7]."""
        label('_@_lmods')
        PUSH()
        _CALLI('__@ldivprep')
        _CALLJ('__@ldivsign')
        CallWorker()
        _MOVW(T2,T0);_MOVW(T2+2,T0+2)
        LDW(T4);_BGE('.lms1')
        if args.cpu >= 6:
            NEGVL(T0)
        else:
            _CALLJ('__@lneg_t0t1')
        label('.lms1')
        LD(T4+1);ANDI(0x40);_BEQ('.lms2')
        if args.cpu >= 6:
            NEGVL(LAC)
        else:
            _CALLJ('_@_lneg')
        label('.lms2')
        tryhop(2);POP();RET()

    module(name='rt_lmods.s',
           code=[ ('EXPORT', '_@_lmods'),
                  ('IMPORT', '__@ldivprep'),
                  ('IMPORT', '__@ldivsign'),
                  ('IMPORT', '__@lneg_t0t1') if args.cpu < 6 else ('NOP',),
                  ('IMPORT', '_@_lneg') if args.cpu < 6 else ('NOP',),
                  ('CODE',   '_@_lmods', code_lmods),
                  ('IMPORT', '__@ldivworker') ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:


# Multiplication heler
# LAC += T0T1 * T2 , T0T1 <<= 16
# Trashes T4 i.e. sysArgs[45]

def code1():
   label('__@mac32x16')
   PUSH()
   LDI(1)
   label('.mac2')
   STW(T4);ANDW(T2);_BEQ('.mac3')
   if args.cpu >= 6:
      LDI(T0);ADDL()
   else:
      _CALLJ('__@ladd_t0t1')
   label('.mac3')
   if args.cpu >= 6:
      LSLVL(T0)
   else:
      _CALLJ('__@lshl1_t0t1')
   LDW(T4);LSLW()
   _BNE('.mac2')
   tryhop(2);POP();RET()

# ----------------------------------------
# LMUL:   LAC <-- LAC * [vAC]
# ----------------------------------------

def code2():
   """ Long multiplication LAC * [vAC] -> LAC
       Thrashes T[0-5] sysArgs[0-7] sysFn"""
   label('_@_lmul')
   if args.cpu >= 7:
      STW(T3);ADDI(2);DEEK();MULW(LAC)
      MOVL(LAC,T0);STW(LAC);LDI(0);ST(LAX)
      LDI(1);ADDW(T3);PEEK();MACX();LDI(8);LSLXA()
      PEEKV(T3);MACX();LDI(8);LSLXA()
      RET()
   elif 'has_at67_SYS_Multiply_s16' in rominfo:
      info = rominfo['has_at67_SYS_Multiply_s16']
      addr = int(str(info['addr']),0)
      cycs = int(str(info['cycs']),0)
      PUSH()
      STW(T3);DEEK();STW(T2);
      LDW(LAC);STW(T0);LDW(LAC+2);STW(T0+2);
      LDI(0);STW(LAC);STW(LAC+2);
      _CALLJ('__@mac32x16')
      LDI(2);ADDW(T3);DEEK();STW(T0);_BEQ('.skip')
      _LDI(addr);STW('sysFn');LDW(LAC+2);STW(T4);LDI(1);STW(T5)
      SYS(cycs);STW(LAC+2)
      label('.skip')
      tryhop(2);POP();RET()
   else:
      PUSH()
      STW(T3);DEEK();STW(T2);
      LDW(LAC);STW(T0);LDW(LAC+2);STW(T0+2);
      LDI(0);STW(LAC);STW(LAC+2);
      _CALLJ('__@mac32x16')
      LDI(2);ADDW(T3);DEEK();STW(T2);_BEQ('.skip')
      _CALLJ('__@mac32x16')
      label('.skip')
      tryhop(2);POP();RET()

code= [ ('EXPORT', '_@_lmul'),
        ('IMPORT', '__@ladd_t0t1') if args.cpu < 6 else ('NOP',),
        ('IMPORT', '__@lshl1_t0t1') if args.cpu < 6 else ('NOP',),
        ('CODE', '__@mac32x16', code1) if args.cpu < 7 else ('NOP',),
        ('CODE', '_@_lmul', code2) ]

module(code=code, name='rt_lmul.s');

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():


    # ----------------------------------------
    # LSHL1 : LAC <-- LAC << 1
    # ----------------------------------------

    def code0():
        """Left shift LAC. No other side effect. """
        nohop()
        label('_@_lshl1')
        if args.cpu >= 6:
            LSLVL(LAC)
            warning('cpu6: use LSLVL instead of _@_lshl1')
        else:
            LDW(LAC+2);LSLW();STW(LAC+2)
            LDW(LAC);_BGE('.l1');INC(LAC+2)
            label('.l1')
            LSLW();STW(LAC)
        RET()

    module(name='rt_lshl1.s',
           code=[ ('EXPORT', '_@_lshl1'),
                  ('CODE', '_@_lshl1', code0) ])


    # ----------------------------------------
    # LSHL1_T0T1:   T0T1 <-- T0T1 << 1
    # ----------------------------------------

    def code1():
        """Left shift T0T1. No other side effect. """
        nohop()
        label('__@lshl1_t0t1')
        if args.cpu >= 6:
            LSLVL(T0)
            warning('cpu6: use LSLVL instead of _@_lshl1')
        else:
            LDW(T1);LSLW();STW(T1)
            LDW(T0);_BGE('.l1');INC(T1)
            label('.l1')
            LSLW();STW(T0)
        RET()

    module(name='rt_lshl1t0t1.s',
           code=[ ('EXPORT', '__@lshl1_t0t1'),
                  ('CODE', '__@lshl1_t0t1', code1) ] )

    # ----------------------------------------
    # LSHL : LAC <-- LAC << vAC
    # ----------------------------------------

    def code2():
        """Left shift LAC by vAC bits.
           Trashes T5 i.e. sysArgs[67] like the alternative opcode LSLXA.
        """
        label('_@_lshl')
        if args.cpu >= 7:
            warning('cpu7: use LSLXA instead of _@_lshl')
            MOVQB(0,LAX);LSLXA();RET()
        else:
            PUSH()
            ST(T5);ANDI(16);_BEQ('.l4')
            LDW(LAC);STW(LAC+2);_MOVIW(0,LAC)
            label('.l4')
            LD(T5);ANDI(8);_BEQ('.l5')
            LDW(LAC+1);STW(LAC+2)
            LDW(LAC-1);ORI(0xff);XORI(0xff);STW(LAC)
            label('.l5')
            LD(T5);ANDI(4);_BEQ('.l6')
            LDWI('SYS_LSLW4_46');STW('sysFn')
            LDW(LAC+2);SYS(46);LD(vACH);ST(LAC+3)
            LDW(LAC+1);SYS(46);LD(vACH);ST(LAC+2)
            LDW(LAC);SYS(46);STW(LAC)
            label('.l6')
            LD(T5);ANDI(3);_BEQ('.ret')
            if args.cpu >= 6:
                ST(T5)
                label('.l7')
                LSLVL(LAC)
                DBNE(T5,'.l7')
            else:
                label('.l7')
                ST(T5)
                _CALLJ('_@_lshl1')
                LD(T5);SUBI(1);_BNE('.l7')
            label('.ret')
            tryhop(2);POP();RET()

    module(name='rt_lshl.s',
           code=[ ('EXPORT', '_@_lshl'),
                  ('IMPORT', '_@_lshl1') if args.cpu < 6 else ('NOP',),
                  ('CODE', '_@_lshl', code2) ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():

    # ----------------------------------------
    # LSHRU : LAC <-- LAC >> vAC
    # ----------------------------------------

    def code0():
        """ Logical right shift LAC by vAC bits.
            Thrashes T5 i.e. sysArgs[67] like its LSRXA counterpart.
            Also thrashes sysFn. """
        nohop()
        if args.cpu >= 7:
            warning('cpu7: use LSRXA instead of _@_lshru')
            label('_@_lshru')
            ANDI(0x1f);LSRXA();RET()
        else:
            label('_@_lshru')
            ST(T5)
            label('__@lshru_t5')
            PUSH()
            LD(T5);ANDI(16);_BEQ('.l4')
            LDW(LAC+2);STW(LAC);LDI(0);STW(LAC+2)
            label('.l4')
            LD(T5);ANDI(8);_BEQ('.l5')
            LDW(LAC+1);STW(LAC);LD(LAC+3);STW(LAC+2)
            label('.l5')
            if args.cpu < 5:
                LDWI('__@shrsysfn');STW('sysFn')
            LD(T5);ANDI(7);_BEQ('.ret')
            if args.cpu < 5:
                CALL('sysFn')
            else:
                CALLI('__@shrsysfn')
            LDW(LAC);SYS(52);ST(LAC)
            LDW(LAC+1);SYS(52);ST(LAC+1)
            LDW(LAC+2);SYS(52);STW(LAC+2)
            label('.ret')
            tryhop(2);POP();RET()

    module(name='rt_lshru.s',
           code= [ ('EXPORT', '_@_lshru'),
                   ('EXPORT', '__@lshru_t5'),
                   ('IMPORT', '__@shrsysfn') if args.cpu < 7 else ('NOP',),
                   ('CODE', '_@_lshru', code0) ])

    # ----------------------------------------
    # LSHRS : LAC <-- LAC >> vAC
    # ----------------------------------------

    def code1():
        """ Arithmetical right shift LAC by vAC bits.
            Thrashes T[45] i.e. sysArgs[4567], sysFn."""
        if args.cpu >= 7:
            nohop()
            label('_@_lshrs')
            ANDI(0x1f);ST(T5);LDW(LAC+2);_BLT('.s1')
            LD(T5);LSRXA();RET()
            label('.s1')
            LD(T5);NOTVL(LAC);LSRXA();NOTVL(LAC);RET()
        else:
            label('_@_lshrs')
            PUSH();ST(T5)
            LDW(LAC+2);_BLT('.s1')
            _CALLJ('__@lshru_t5');_BRA('.sret')
            label('.s1')
            LDWI(0xffff);STW(T4);XORW(LAC);STW(LAC)
            LDW(T4);XORW(LAC+2);STW(LAC+2)
            _CALLJ('__@lshru_t5')
            LDW(T4);XORW(LAC);STW(LAC)
            LDW(T4);XORW(LAC+2);STW(LAC+2)
            label('.sret')
            tryhop(2);POP();RET()

    module(name='rt_lshrs.s',
           code= [ ('EXPORT', '_@_lshrs'),
                   ('IMPORT', '__@lshru_t5') if args.cpu < 7 else ('NOP',),
                   ('CODE', '_@_lshrs', code1) ])

scope()


# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
def scope():


    # ----------------------------------------
    # MUL: T3 * vAC -> vAC
    # ----------------------------------------

    
    if 'has_SYS_Multiply_s16' in rominfo:
        info = rominfo['has_SYS_Multiply_s16']
        addr = int(str(info['addr']),0)
        cycs = int(str(info['cycs']),0)
        def code1():
            """ This is the dev7 SYS_Multiply_s16 version of MUL
                which requires less setup than the old version.
                Trashes T[01] sysArgs[0-7], sysFn. """
            nohop()
            label('_@_mul')             # T3*vAC -> vAC  (traditional entry point)
            STW('sysArgs2')
            LDW(T3);STW('sysArgs0')
            BRA('.1')
            label('_@_at67_mul')        # sysArgs0*vAC -> vAC  (faster entry point)
            STW('sysArgs2')
            label('.1')
            LDWI(addr);STW('sysFn')
            LDI(0);STW('sysArgs4')
            SYS(cycs)
            RET()

        module(name='rt_at67_mul.s',
               code= [ ('EXPORT', '_@_mul'),
                       ('EXPORT', '_@_at67_mul'),
                       ('CODE', '_@_mul', code1) ] )
    
    elif 'has_at67_SYS_Multiply_s16' in rominfo:
        # Multiply using SYS call
        info = rominfo['has_at67_SYS_Multiply_s16']
        addr = int(str(info['addr']),0)
        cycs = int(str(info['cycs']),0)
        def code1():
            """ This is the v6 SYS_Multiply_s16 version of MUL
                which requires more setup than the old version.
                Trashes sysArgs[0-7], sysFn. """
            nohop()
            label('_@_mul')             # T3*vAC -> vAC  (traditional entry point)
            STW('sysArgs2')
            LDW(T3);STW('sysArgs0')
            BRA('.1')
            label('_@_at67_mul')        # sysArgs0*vAC -> vAC  (faster entry point)
            STW('sysArgs2')
            label('.1')
            LDWI(addr);STW('sysFn')
            LDI(0);STW('sysArgs4');LDI(1);STW('sysArgs6')
            SYS(cycs)
            RET()

        module(name='rt_mul.s',
               code= [ ('EXPORT', '_@_mul'),
                       ('EXPORT', '_@_at67_mul'),
                       ('CODE', '_@_mul', code1) ] )

    else:
        # Muliply using vCPU
        def code0():
            """ This is the vCPU multiplication.
                Trashes sysArgs[0-7]. """
            nohop()
            label('_@_mul')             # T3*vAC --> vAC
            _BGE('.mul1');_BEQ('.ret')
            label('.mul2')
            STW(T0);LDW(T3);STW(T1);_BNE('.go');RET()
            label('.mul1')
            STW(T1);LDW(T3);STW(T0);_BEQ('.ret')
            label('.go')
            LDI(0);STW(T4);_LDI(0xffff);STW(T5)
            label('.loop')
            LDI(0);SUBW(T5);ANDW(T1);_BEQ('.shift')
            LDW(T4);ADDW(T0);STW(T4)
            label('.shift')
            LDW(T0);LSLW();STW(T0)
            LDW(T5);LSLW();STW(T5);ANDW(T1);_BNE('.loop')
            LDW(T4)
            label('.ret')
            RET()
      
        module(name='rt_mul.s',
               code= [ ('EXPORT', '_@_mul'),
                       ('CODE', '_@_mul', code0) ] )


scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:

def scope():

    def savemask(i):
        return (0xff << i) & 0xff
    def savename(i):
        return "_@_save_%02x" % savemask(i)
    def rtrnname(i):
        return "_@_rtrn_%02x" % savemask(i)


    if args.cpu < 7:

        def code0():
            """ Prologue helper
                - Writes callee-savee registers at address vAC (T2 on ROMv4)
                  then writes vLR which must have been saved in register T0.
                  Potentially use T[12345]."""
            nohop()
            if args.cpu >= 6:
                for i in range(0,8):
                    label(savename(i))
                    DOKEA(R0+i+i);ADDI(2)
                label(savename(8))
                DOKEA(T0)
            elif args.cpu >= 5:
                for i in range(0,8):
                    label(savename(i))
                    STW(T2);LDW(R0+i+i);DOKE(T2)
                    LDI(2);ADDW(T2)
                label(savename(8))
                STW(T2);LDW(T0);DOKE(T2)
            else:
                for i in range(0,8):
                    label(savename(i))
                    LDW(R0+i+i);DOKE(T2)
                    LDI(2);ADDW(T2);STW(T2)
                label(savename(8))
                LDW(T0);DOKE(T2)
            RET()

        def code1():
            """ Epilogue helper
                 - Restores callee-saved registers from address vAC (T3 on ROMv4)
                   then restores vLR, adjust stack by T0, then returns.
                   Potentially uses T[12345] """
            nohop()
            if args.cpu >= 6:
                for i in range(0,8):
                    label(rtrnname(i))
                    DEEKA(R0+i+i);ADDI(2)
                label(rtrnname(8))
                DEEKA(vLR)
            else:
                for i in range(0,8):
                    label(rtrnname(i))
                    STW(T3);DEEK();STW(R0+i+i)
                    LDI(2);ADDW(T3)
                label(rtrnname(8))
                DEEK();STW(vLR)
            # return
            if args.cpu >= 7:
                LDW(T0);ADDV(SP)
            else:
                LDW(T0);ADDW(SP);STW(SP)
            LDW(R8);RET()


        module(name='rt_save.s',
               code=[ ('EXPORT', savename(i)) for i in range(0,9) ] \
               +    [ ('EXPORT', rtrnname(i)) for i in range(0,9) ] \
               +    [ ('CODE', savename(0), code0),
                      ('CODE', rtrnname(0), code1) ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
def scope():


    # T3<<vAC -> vAC
    def code0():
        nohop()
        label('_@_shl')
        PUSH()
        ANDI(0xf);SUBI(8);_BLT('.try4')
        if args.cpu >= 7:
            MOVW(T3-1,T3);MOVQB(0,T3)
        else:
            ST(T5);LDW(T3-1);ORI(255);XORI(255);STW(T3);LD(T5)
        label('.try4')
        if args.cpu >= 7:
            MOVIW('.ret',T5);ANDI(7);SUBV(T5)
        else:
            ANDI(7);STW(T5);LDWI('.ret');SUBW(T5);STW(T5)
        LDW(T3);CALL(T5)
        for _ in range(7): LSLW()
        label('.ret')
        POP();RET()

    module(name='rt_shl.s',
           code=[ ('EXPORT', '_@_shl'),
                  ('CODE', '_@_shl', code0) ] )

scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:


def scope():
   
    def code0():
        nohop()
        label('__@shrsysfn')
        LSLW()
        if args.cpu >= 6:
            ADDWI(v('.shrtable')-2)
        else:
            PUSH();STW(vLR);LDWI(v('.shrtable')-2);ADDW(vLR);POP()
        DEEK();STW('sysFn')
        RET()
        label(".shrtable")
        words("SYS_LSRW1_48")
        words("SYS_LSRW2_52")
        words("SYS_LSRW3_52")
        words("SYS_LSRW4_50")
        words("SYS_LSRW5_50")
        words("SYS_LSRW6_48")
        words('SYS_LSRW7_30')

    module(name='rt_shrtable.s',
           code=[('EXPORT', '__@shrsysfn'),
                 ('CODE', '__@shrsysfn', code0) ] )

    # SHRU: T3>>vAC -> vAC  (unsigned)
    # Trashes T5
    def code1():
        nohop()
        label('_@_shrs')
        ST(T5);LDW(T3);_BGE('.shr0')
        LDWI(0xffff);STW(T4);XORW(T3);STW(T3)
        BRA('.shr1')
        label('_@_shru')
        ST(T5)
        label('.shr0')
        _MOVIW(0,T4)
        label('.shr1')
        if args.cpu < 5:
            LDWI('__@shrsysfn');STW('sysFn')
        LD(T5);ANDI(8);_BEQ('.shr2')
        LD(T3+1);STW(T3)
        label('.shr2')
        LD(T5);ANDI(7);_BEQ('.shr3')
        if args.cpu < 5:
            PUSH();CALL('sysFn');POP()
        else:
            PUSH();CALLI('__@shrsysfn');POP()
        LDW(T3);SYS(52);XORW(T4);RET()
        label('.shr3')
        LDW(T3);XORW(T4);RET()

    module(name='rt_shr.s',
           code=[('EXPORT', '_@_shru'),
                 ('EXPORT', '_@_shrs'),
                 ('IMPORT', '__@shrsysfn'),
                 ('CODE', '_@_shr', code1) ] )


    # SHRU1/SHRS1 : AC <-- AC >> 1 (unsigned)
    # clobbers T[45]
    def code0():
        nohop()
        if args.cpu >= 7:
            label('_@_shrs1')
            _BGE('_@_shru1')
            MOVIW(0x8000,T4)
            BRA('.shr')
            label('_@_shru1')
            MOVQW(0,T4)
            label('.shr')
            MOVIW('SYS_LSRW1_48','sysFn')
        else:
            label('_@_shrs1')
            _BGE('_@_shru1')
            STW(T5);_MOVIW(0x8000,T4)
            BRA('.shr')
            label('_@_shru1')
            STW(T5);_MOVIW(0,T4)
            label('.shr')
            _MOVIW('SYS_LSRW1_48','sysFn')
            LDW(T5)
        SYS(48);ORW(T4)
        RET()

    module(name='rt_shr1.s',
           code=[('EXPORT', '_@_shrs1'),
                 ('EXPORT', '_@_shru1'),
                 ('CODE', '_@_shr1', code0) ] )
   
scope()

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
